//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.0

use sea_orm::entity::prelude::*;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "taskmodel")]
pub struct Model {
	#[sea_orm(primary_key, auto_increment = false, column_type = "Text")]
	pub task_id: String,
	#[sea_orm(column_type = "Text")]
	pub task_type: String,
	#[sea_orm(column_type = "Text")]
	pub status: String,
	#[sea_orm(column_type = "Text")]
	pub reference_task_name: String,
	pub retry_count: Option<i32>,
	pub seq: i32,
	#[sea_orm(column_type = "Text", nullable)]
	pub correlation_id: Option<String>,
	pub poll_count: i32,
	#[sea_orm(column_type = "Text")]
	pub task_def_name: String,
	pub scheduled_time: DateTime,
	pub start_time: DateTime,
	pub end_time: Option<DateTime>,
	pub update_time: Option<DateTime>,
	pub start_delay_in_seconds: i64,
	#[sea_orm(column_type = "Text", nullable)]
	pub retried_task_id: Option<String>,
	pub retried: bool,
	pub executed: bool,
	pub callback_from_worker: bool,
	pub response_timeout_seconds: Option<i64>,
	#[sea_orm(column_type = "Text", nullable)]
	pub workflow_instance_id: Option<String>,
	#[sea_orm(column_type = "Text", nullable)]
	pub workflow_type: Option<String>,
	#[sea_orm(column_type = "Text", nullable)]
	pub reason_for_incompletion: Option<String>,
	pub callback_after_seconds: i64,
	#[sea_orm(column_type = "Text", nullable)]
	pub worker_id: Option<String>,
	#[sea_orm(column_type = "Text")]
	pub workflow_task: String,
	#[sea_orm(column_type = "Text", nullable)]
	pub domain: Option<String>,
	#[sea_orm(column_type = "JsonBinary", nullable)]
	pub input_message: Option<Json>,
	#[sea_orm(column_type = "JsonBinary", nullable)]
	pub output_message: Option<Json>,
	pub rate_limit_per_frequency: Option<i32>,
	pub rate_limit_frequency_in_seconds: Option<i32>,
	#[sea_orm(column_type = "Text", nullable)]
	pub external_input_payload_storage_path: Option<String>,
	#[sea_orm(column_type = "Text", nullable)]
	pub external_output_payload_storage_path: Option<String>,
	pub workflow_priority: i16,
	#[sea_orm(column_type = "Text", nullable)]
	pub execution_name_space: Option<String>,
	#[sea_orm(column_type = "Text", nullable)]
	pub isolation_group_id: Option<String>,
	pub iteration: i32,
	#[sea_orm(column_type = "Text", nullable)]
	pub sub_workflow_id: Option<String>,
	pub subworkflow_changed: bool,
	pub wait_timeout: Option<i64>,
	#[sea_orm(column_type = "Text", nullable)]
	pub buissness_rule_id: Option<String>,
	#[sea_orm(column_type = "Text", nullable)]
	pub do_while_id: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
	#[sea_orm(
		belongs_to = "super::buissnessrule::Entity",
		from = "Column::BuissnessRuleId",
		to = "super::buissnessrule::Column::Id",
		on_update = "NoAction",
		on_delete = "NoAction"
	)]
	Buissnessrule,
	#[sea_orm(
		belongs_to = "super::dowhile::Entity",
		from = "Column::DoWhileId",
		to = "super::dowhile::Column::Id",
		on_update = "NoAction",
		on_delete = "NoAction"
	)]
	Dowhile,
	#[sea_orm(
		belongs_to = "super::taskconfig::Entity",
		from = "Column::WorkflowTask",
		to = "super::taskconfig::Column::TaskId",
		on_update = "NoAction",
		on_delete = "NoAction"
	)]
	Taskconfig,
}

impl Related<super::buissnessrule::Entity> for Entity {
	fn to() -> RelationDef {
		Relation::Buissnessrule.def()
	}
}

impl Related<super::dowhile::Entity> for Entity {
	fn to() -> RelationDef {
		Relation::Dowhile.def()
	}
}

impl Related<super::taskconfig::Entity> for Entity {
	fn to() -> RelationDef {
		Relation::Taskconfig.def()
	}
}

impl ActiveModelBehavior for ActiveModel {}
