//! `SeaORM` Entity, @generated by sea-orm-codegen 0.1.0

use actix_web::Result;
use prost::encoding::{
	decode_key, encode_varint, encoded_len_varint, message, DecodeContext, WireType,
};
use prost::Message;
use prost_build::Config;
use prost_types::{DescriptorProto, FileDescriptorProto};
use std::collections::BTreeMap;
#[derive(Clone, Debug)]
pub struct DynamicMessage {
	pub name: String,
	pub descriptor: DescriptorProto,
	pub fields: BTreeMap<u32, FieldValue>,
}
#[derive(Clone, Debug)]
pub enum FieldValue {
	Bool(bool),
	Bytes(Vec<u8>),
	Double(f64),
	Fixed32(u32),
	Fixed64(u64),
	Float(f32),
	Int32(i32),
	Int64(i64),
	Sfixed32(i32),
	Sfixed64(i64),
	Sint32(i32),
	Sint64(i64),
	String(String),
	Uint32(u32),
	Uint64(u64),
	Vec(Box<FieldValue>),
}
pub enum ComplexType {}
impl FieldValue {
	pub fn encode(&self, tag: u32, buf: &mut impl prost::bytes::BufMut) {
		match self {
			FieldValue::Bool(val) => prost::encoding::bool::encode(tag, &val, buf),
			FieldValue::Bytes(val) => prost::encoding::bytes::encode(tag, val, buf),
			FieldValue::Double(val) => prost::encoding::double::encode(tag, &val, buf),
			FieldValue::Fixed32(val) => prost::encoding::fixed32::encode(tag, &val, buf),
			FieldValue::Fixed64(val) => prost::encoding::fixed64::encode(tag, &val, buf),
			FieldValue::Float(val) => prost::encoding::float::encode(tag, &val, buf),
			FieldValue::Int32(val) => prost::encoding::int32::encode(tag, &val, buf),
			FieldValue::Int64(val) => prost::encoding::int64::encode(tag, &val, buf),
			FieldValue::Sfixed32(val) => prost::encoding::sfixed32::encode(tag, &val, buf),
			FieldValue::Sfixed64(val) => prost::encoding::sfixed64::encode(tag, &val, buf),
			FieldValue::Sint32(val) => prost::encoding::sint32::encode(tag, &val, buf),
			FieldValue::Sint64(val) => prost::encoding::sint64::encode(tag, &val, buf),
			FieldValue::String(val) => prost::encoding::string::encode(tag, &val, buf),
			FieldValue::Uint32(val) => prost::encoding::uint32::encode(tag, &val, buf),
			FieldValue::Uint64(val) => prost::encoding::uint64::encode(tag, &val, buf),
			FieldValue::Vec(val) => val.encode(tag, buf),
		};
	}
	pub fn merge_field(
		&mut self,
		tag: u32,
		wire_type: WireType,
		buf: &mut impl prost::bytes::Buf,
		ctx: DecodeContext,
	) -> Result<(), prost::DecodeError> {
		match self {
			FieldValue::Bool(val) => prost::encoding::bool::merge(wire_type, val, buf, ctx),
			FieldValue::Bytes(val) => prost::encoding::bytes::merge(wire_type, val, buf, ctx),
			FieldValue::Double(val) => prost::encoding::double::merge(wire_type, val, buf, ctx),
			FieldValue::Fixed32(val) => prost::encoding::fixed32::merge(wire_type, val, buf, ctx),
			FieldValue::Fixed64(val) => prost::encoding::fixed64::merge(wire_type, val, buf, ctx),
			FieldValue::Float(val) => prost::encoding::float::merge(wire_type, val, buf, ctx),
			FieldValue::Int32(val) => prost::encoding::int32::merge(wire_type, val, buf, ctx),
			FieldValue::Int64(val) => prost::encoding::int64::merge(wire_type, val, buf, ctx),
			FieldValue::Sfixed32(val) => prost::encoding::sfixed32::merge(wire_type, val, buf, ctx),
			FieldValue::Sfixed64(val) => prost::encoding::sfixed64::merge(wire_type, val, buf, ctx),
			FieldValue::Sint32(val) => prost::encoding::sint32::merge(wire_type, val, buf, ctx),
			FieldValue::Sint64(val) => prost::encoding::sint64::merge(wire_type, val, buf, ctx),
			FieldValue::String(val) => prost::encoding::string::merge(wire_type, val, buf, ctx),
			FieldValue::Uint32(val) => prost::encoding::uint32::merge(wire_type, val, buf, ctx),
			FieldValue::Uint64(val) => prost::encoding::uint64::merge(wire_type, val, buf, ctx),
			FieldValue::Vec(val) => val.merge_field(tag, wire_type, buf, ctx),
		}
	}
	pub fn encoded_len(&self, tag: u32) -> usize {
		match self {
			FieldValue::Bool(val) => prost::encoding::bool::encoded_len(tag, val),
			FieldValue::Bytes(val) => prost::encoding::bytes::encoded_len(tag, val),
			FieldValue::Double(val) => prost::encoding::double::encoded_len(tag, val),
			FieldValue::Fixed32(val) => prost::encoding::fixed32::encoded_len(tag, val),
			FieldValue::Fixed64(val) => prost::encoding::fixed64::encoded_len(tag, val),
			FieldValue::Float(val) => prost::encoding::float::encoded_len(tag, val),
			FieldValue::Int32(val) => prost::encoding::int32::encoded_len(tag, val),
			FieldValue::Int64(val) => prost::encoding::int64::encoded_len(tag, val),
			FieldValue::Sfixed32(val) => prost::encoding::sfixed32::encoded_len(tag, val),
			FieldValue::Sfixed64(val) => prost::encoding::sfixed64::encoded_len(tag, val),
			FieldValue::Sint32(val) => prost::encoding::sint32::encoded_len(tag, val),
			FieldValue::Sint64(val) => prost::encoding::sint64::encoded_len(tag, val),
			FieldValue::String(val) => prost::encoding::string::encoded_len(tag, val),
			FieldValue::Uint32(val) => prost::encoding::uint32::encoded_len(tag, val),
			FieldValue::Uint64(val) => prost::encoding::uint64::encoded_len(tag, val),
			FieldValue::Vec(val) => val.encoded_len(tag),
		}
	}
}
impl Default for DynamicMessage {
	fn default() -> Self {
		DynamicMessage {
			descriptor: DescriptorProto::default(),
			name: String::new(),
			fields: BTreeMap::new(),
		}
	}
}
impl DynamicMessage {
	pub fn new() -> Self {
		Default::default()
	}
}
impl Message for DynamicMessage {
	fn encode_raw(&self, buf: &mut impl prost::bytes::BufMut)
	where
		Self: Sized,
	{
		if !self.fields.is_empty() {
			self.fields.clone().into_iter().for_each(|(tag, field)| field.encode(tag, buf));
		}
	}
	fn merge_field(
		&mut self,
		tag: u32,
		wire_type: WireType,
		buf: &mut impl prost::bytes::Buf,
		ctx: DecodeContext,
	) -> std::result::Result<(), prost::DecodeError>
	where
		Self: Sized,
	{
		match self.fields.get(&tag) {
			Some(field) => field.clone().merge_field(tag, wire_type, buf, ctx),
			None => prost::encoding::skip_field(wire_type, tag, buf, ctx),
		}?;
		Ok(())
	}
	fn encoded_len(&self) -> usize {
		self.fields.clone().into_iter().map(|(tag, field)| field.encoded_len(tag)).sum()
	}
	fn clear(&mut self) {
		self.fields.clear();
	}
}
pub struct Parser {
	file_descriptors: BTreeMap<String, FileDescriptorProto>,
	messages: BTreeMap<String, FileDescriptorProto>,
}
impl Parser {
	pub fn new() -> Self {
		Self {
			messages: BTreeMap::new(),
			file_descriptors: BTreeMap::new(),
		}
	}
	pub fn parse_proto(&mut self) -> Result<(), Box<dyn std::error::Error>> {
		let mut parser = protobuf_parse::Parser::new();
		parser.protoc();
		parser
			.input("./link/common/src/plugin/proto/user.proto")
			.include("./link/common/src/plugin/proto/");
		Ok(())
	}
}
