//! `SeaORM` Entity, @generated by sea-orm-codegen 0.1.0

use crate::public::entities::{prelude::*, sea_orm_active_enums};
use actix_web::{web, HttpResponse, Responder};
use sea_orm::prelude::*;
use sea_orm::Set;
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
pub struct ProductVariantParmns {
	id: String,
}

pub fn configure(cfg: &mut web::ServiceConfig) {
	cfg.service(
		web::scope("/product_variant")
			.route("/", web::get().to(GetProductVariant::route))
			.route("/", web::post().to(CreateProductVariant::route))
			.route("/list", web::get().to(ListProductVariant::route))
			.route("/{id}", web::put().to(UpdateProductVariant::route))
			.route("/{id}", web::get().to(DeleteProductVariant::route)),
	);
}

#[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct GetProductVariant {
	pub id: Option<String>,
	pub title: Option<String>,
	pub product_id: Option<String>,
	pub sku: Option<String>,
	pub barcode: Option<String>,
	pub ean: Option<String>,
	pub upc: Option<String>,
	pub inventory_quantity: Option<i32>,
	pub allow_backorder: Option<bool>,
	pub manage_inventory: Option<bool>,
	pub hs_code: Option<String>,
	pub origin_country: Option<String>,
	pub mid_code: Option<String>,
	pub material: Option<String>,
	pub weight: Option<i32>,
	pub length: Option<i32>,
	pub height: Option<i32>,
	pub width: Option<i32>,
	pub created_at: Option<DateTimeWithTimeZone>,
	pub updated_at: Option<DateTimeWithTimeZone>,
	pub deleted_at: Option<DateTimeWithTimeZone>,
	pub metadata: Option<Json>,
	pub variant_rank: Option<i32>,
}

impl GetProductVariant {
	async fn route(
		db: web::Data<DatabaseConnection>,
		json_data: Option<web::Json<GetProductVariant>>,
	) -> impl Responder {
		let model = match json_data {
			Some(model) => model.into_inner(),
			None => GetProductVariant::default(),
		};
		let mut query = ProductVariant::find();
		if let Some(id) = &model.id {
			query = query.filter(ProductVariantColumn::Id.eq(id.clone()));
		}
		if let Some(title) = &model.title {
			query = query.filter(ProductVariantColumn::Title.eq(title.clone()));
		}
		if let Some(product_id) = &model.product_id {
			query = query.filter(ProductVariantColumn::ProductId.eq(product_id.clone()));
		}
		if let Some(sku) = &model.sku {
			query = query.filter(ProductVariantColumn::Sku.eq(sku.clone()));
		}
		if let Some(barcode) = &model.barcode {
			query = query.filter(ProductVariantColumn::Barcode.eq(barcode.clone()));
		}
		if let Some(ean) = &model.ean {
			query = query.filter(ProductVariantColumn::Ean.eq(ean.clone()));
		}
		if let Some(upc) = &model.upc {
			query = query.filter(ProductVariantColumn::Upc.eq(upc.clone()));
		}
		if let Some(inventory_quantity) = &model.inventory_quantity {
			query = query
				.filter(ProductVariantColumn::InventoryQuantity.eq(inventory_quantity.clone()));
		}
		if let Some(allow_backorder) = &model.allow_backorder {
			query = query.filter(ProductVariantColumn::AllowBackorder.eq(allow_backorder.clone()));
		}
		if let Some(manage_inventory) = &model.manage_inventory {
			query =
				query.filter(ProductVariantColumn::ManageInventory.eq(manage_inventory.clone()));
		}
		if let Some(hs_code) = &model.hs_code {
			query = query.filter(ProductVariantColumn::HsCode.eq(hs_code.clone()));
		}
		if let Some(origin_country) = &model.origin_country {
			query = query.filter(ProductVariantColumn::OriginCountry.eq(origin_country.clone()));
		}
		if let Some(mid_code) = &model.mid_code {
			query = query.filter(ProductVariantColumn::MidCode.eq(mid_code.clone()));
		}
		if let Some(material) = &model.material {
			query = query.filter(ProductVariantColumn::Material.eq(material.clone()));
		}
		if let Some(weight) = &model.weight {
			query = query.filter(ProductVariantColumn::Weight.eq(weight.clone()));
		}
		if let Some(length) = &model.length {
			query = query.filter(ProductVariantColumn::Length.eq(length.clone()));
		}
		if let Some(height) = &model.height {
			query = query.filter(ProductVariantColumn::Height.eq(height.clone()));
		}
		if let Some(width) = &model.width {
			query = query.filter(ProductVariantColumn::Width.eq(width.clone()));
		}
		if let Some(created_at) = &model.created_at {
			query = query.filter(ProductVariantColumn::CreatedAt.eq(created_at.clone()));
		}
		if let Some(updated_at) = &model.updated_at {
			query = query.filter(ProductVariantColumn::UpdatedAt.eq(updated_at.clone()));
		}
		if let Some(deleted_at) = &model.deleted_at {
			query = query.filter(ProductVariantColumn::DeletedAt.eq(deleted_at.clone()));
		}
		if let Some(metadata) = &model.metadata {
			query = query.filter(ProductVariantColumn::Metadata.eq(metadata.clone()));
		}
		if let Some(variant_rank) = &model.variant_rank {
			query = query.filter(ProductVariantColumn::VariantRank.eq(variant_rank.clone()));
		}
		let result = query.one(db.get_ref()).await;
		match result {
			Ok(response) => match response {
				Some(res) => HttpResponse::Ok().json(res),
				None => HttpResponse::NotFound().finish(),
			},
			Err(err) => {
				HttpResponse::InternalServerError().body(format!("Database query error: {}", err))
			}
		}
	}
}

#[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ListProductVariant {
	pub id: Option<String>,
	pub title: Option<String>,
	pub product_id: Option<String>,
	pub sku: Option<String>,
	pub barcode: Option<String>,
	pub ean: Option<String>,
	pub upc: Option<String>,
	pub inventory_quantity: Option<i32>,
	pub allow_backorder: Option<bool>,
	pub manage_inventory: Option<bool>,
	pub hs_code: Option<String>,
	pub origin_country: Option<String>,
	pub mid_code: Option<String>,
	pub material: Option<String>,
	pub weight: Option<i32>,
	pub length: Option<i32>,
	pub height: Option<i32>,
	pub width: Option<i32>,
	pub created_at: Option<DateTimeWithTimeZone>,
	pub updated_at: Option<DateTimeWithTimeZone>,
	pub deleted_at: Option<DateTimeWithTimeZone>,
	pub metadata: Option<Json>,
	pub variant_rank: Option<i32>,
}

impl ListProductVariant {
	async fn route(
		db: web::Data<DatabaseConnection>,
		json_data: Option<web::Json<ListProductVariant>>,
	) -> impl Responder {
		let model = match json_data {
			Some(model) => model.into_inner(),
			None => ListProductVariant::default(),
		};
		let mut query = ProductVariant::find();
		if let Some(id) = &model.id {
			query = query.filter(ProductVariantColumn::Id.eq(id.clone()));
		}
		if let Some(title) = &model.title {
			query = query.filter(ProductVariantColumn::Title.eq(title.clone()));
		}
		if let Some(product_id) = &model.product_id {
			query = query.filter(ProductVariantColumn::ProductId.eq(product_id.clone()));
		}
		if let Some(sku) = &model.sku {
			query = query.filter(ProductVariantColumn::Sku.eq(sku.clone()));
		}
		if let Some(barcode) = &model.barcode {
			query = query.filter(ProductVariantColumn::Barcode.eq(barcode.clone()));
		}
		if let Some(ean) = &model.ean {
			query = query.filter(ProductVariantColumn::Ean.eq(ean.clone()));
		}
		if let Some(upc) = &model.upc {
			query = query.filter(ProductVariantColumn::Upc.eq(upc.clone()));
		}
		if let Some(inventory_quantity) = &model.inventory_quantity {
			query = query
				.filter(ProductVariantColumn::InventoryQuantity.eq(inventory_quantity.clone()));
		}
		if let Some(allow_backorder) = &model.allow_backorder {
			query = query.filter(ProductVariantColumn::AllowBackorder.eq(allow_backorder.clone()));
		}
		if let Some(manage_inventory) = &model.manage_inventory {
			query =
				query.filter(ProductVariantColumn::ManageInventory.eq(manage_inventory.clone()));
		}
		if let Some(hs_code) = &model.hs_code {
			query = query.filter(ProductVariantColumn::HsCode.eq(hs_code.clone()));
		}
		if let Some(origin_country) = &model.origin_country {
			query = query.filter(ProductVariantColumn::OriginCountry.eq(origin_country.clone()));
		}
		if let Some(mid_code) = &model.mid_code {
			query = query.filter(ProductVariantColumn::MidCode.eq(mid_code.clone()));
		}
		if let Some(material) = &model.material {
			query = query.filter(ProductVariantColumn::Material.eq(material.clone()));
		}
		if let Some(weight) = &model.weight {
			query = query.filter(ProductVariantColumn::Weight.eq(weight.clone()));
		}
		if let Some(length) = &model.length {
			query = query.filter(ProductVariantColumn::Length.eq(length.clone()));
		}
		if let Some(height) = &model.height {
			query = query.filter(ProductVariantColumn::Height.eq(height.clone()));
		}
		if let Some(width) = &model.width {
			query = query.filter(ProductVariantColumn::Width.eq(width.clone()));
		}
		if let Some(created_at) = &model.created_at {
			query = query.filter(ProductVariantColumn::CreatedAt.eq(created_at.clone()));
		}
		if let Some(updated_at) = &model.updated_at {
			query = query.filter(ProductVariantColumn::UpdatedAt.eq(updated_at.clone()));
		}
		if let Some(deleted_at) = &model.deleted_at {
			query = query.filter(ProductVariantColumn::DeletedAt.eq(deleted_at.clone()));
		}
		if let Some(metadata) = &model.metadata {
			query = query.filter(ProductVariantColumn::Metadata.eq(metadata.clone()));
		}
		if let Some(variant_rank) = &model.variant_rank {
			query = query.filter(ProductVariantColumn::VariantRank.eq(variant_rank.clone()));
		}
		let result = query.all(db.get_ref()).await;
		match result {
			Ok(response) => HttpResponse::Ok().json(response),
			Err(err) => {
				HttpResponse::InternalServerError().body(format!("Database query error: {}", err))
			}
		}
	}
}

#[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CreateProductVariant {
	pub title: String,
	pub product_id: String,
	pub sku: Option<String>,
	pub barcode: Option<String>,
	pub ean: Option<String>,
	pub upc: Option<String>,
	pub inventory_quantity: i32,
	pub allow_backorder: bool,
	pub manage_inventory: bool,
	pub hs_code: Option<String>,
	pub origin_country: Option<String>,
	pub mid_code: Option<String>,
	pub material: Option<String>,
	pub weight: Option<i32>,
	pub length: Option<i32>,
	pub height: Option<i32>,
	pub width: Option<i32>,
	pub created_at: DateTimeWithTimeZone,
	pub updated_at: DateTimeWithTimeZone,
	pub deleted_at: Option<DateTimeWithTimeZone>,
	pub metadata: Option<Json>,
	pub variant_rank: Option<i32>,
}

impl CreateProductVariant {
	async fn route(
		db: web::Data<DatabaseConnection>,
		json_data: Option<web::Json<CreateProductVariant>>,
	) -> impl Responder {
		let model = match json_data {
			Some(model) => model.into_inner(),
			None => return HttpResponse::InternalServerError().body("Empty body received"),
		};
		let new_table = ProductVariantActiveModel {
			id: Set("id".to_string()),
			title: Set(model.title.clone()),
			product_id: Set(model.product_id.clone()),
			sku: Set(model.sku.clone()),
			barcode: Set(model.barcode.clone()),
			ean: Set(model.ean.clone()),
			upc: Set(model.upc.clone()),
			inventory_quantity: Set(model.inventory_quantity.clone()),
			allow_backorder: Set(model.allow_backorder.clone()),
			manage_inventory: Set(model.manage_inventory.clone()),
			hs_code: Set(model.hs_code.clone()),
			origin_country: Set(model.origin_country.clone()),
			mid_code: Set(model.mid_code.clone()),
			material: Set(model.material.clone()),
			weight: Set(model.weight.clone()),
			length: Set(model.length.clone()),
			height: Set(model.height.clone()),
			width: Set(model.width.clone()),
			created_at: Set(model.created_at.clone()),
			updated_at: Set(model.updated_at.clone()),
			deleted_at: Set(model.deleted_at.clone()),
			metadata: Set(model.metadata.clone()),
			variant_rank: Set(model.variant_rank.clone()),
		};
		let insert_result = new_table.insert(db.get_ref()).await;
		match insert_result {
			Ok(res) => HttpResponse::Created().json(res),
			Err(err) => {
				HttpResponse::InternalServerError().body(format!("Failed to insert: {}", err))
			}
		}
	}
}

#[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct UpdateProductVariant {
	pub title: Option<String>,
	pub product_id: Option<String>,
	pub sku: Option<String>,
	pub barcode: Option<String>,
	pub ean: Option<String>,
	pub upc: Option<String>,
	pub inventory_quantity: Option<i32>,
	pub allow_backorder: Option<bool>,
	pub manage_inventory: Option<bool>,
	pub hs_code: Option<String>,
	pub origin_country: Option<String>,
	pub mid_code: Option<String>,
	pub material: Option<String>,
	pub weight: Option<i32>,
	pub length: Option<i32>,
	pub height: Option<i32>,
	pub width: Option<i32>,
	pub created_at: Option<DateTimeWithTimeZone>,
	pub updated_at: Option<DateTimeWithTimeZone>,
	pub deleted_at: Option<DateTimeWithTimeZone>,
	pub metadata: Option<Json>,
	pub variant_rank: Option<i32>,
}

impl UpdateProductVariant {
	async fn route(
		db: web::Data<DatabaseConnection>,
		path: web::Path<ProductVariantParmns>,
		json_data: Option<web::Json<UpdateProductVariant>>,
	) -> impl Responder {
		let model = match json_data {
			Some(model) => model.into_inner(),
			None => return HttpResponse::InternalServerError().body("Empty body received"),
		};
		let old_table = ProductVariant::find_by_id(path.id.clone()).one(db.get_ref()).await;
		match old_table {
			Ok(old) => match old {
				Some(table) => {
					let mut model_active: ProductVariantActiveModel = table.into();
					if let Some(title) = &model.title {
						model_active.title = Set(title.clone());
					}
					if let Some(product_id) = &model.product_id {
						model_active.product_id = Set(product_id.clone());
					}
					model_active.sku = Set(model.sku);
					model_active.barcode = Set(model.barcode);
					model_active.ean = Set(model.ean);
					model_active.upc = Set(model.upc);
					if let Some(inventory_quantity) = &model.inventory_quantity {
						model_active.inventory_quantity = Set(inventory_quantity.clone());
					}
					if let Some(allow_backorder) = &model.allow_backorder {
						model_active.allow_backorder = Set(allow_backorder.clone());
					}
					if let Some(manage_inventory) = &model.manage_inventory {
						model_active.manage_inventory = Set(manage_inventory.clone());
					}
					model_active.hs_code = Set(model.hs_code);
					model_active.origin_country = Set(model.origin_country);
					model_active.mid_code = Set(model.mid_code);
					model_active.material = Set(model.material);
					model_active.weight = Set(model.weight);
					model_active.length = Set(model.length);
					model_active.height = Set(model.height);
					model_active.width = Set(model.width);
					if let Some(created_at) = &model.created_at {
						model_active.created_at = Set(created_at.clone());
					}
					if let Some(updated_at) = &model.updated_at {
						model_active.updated_at = Set(updated_at.clone());
					}
					model_active.deleted_at = Set(model.deleted_at);
					model_active.metadata = Set(model.metadata);
					model_active.variant_rank = Set(model.variant_rank);
					let update_result = model_active.update(db.get_ref()).await;
					match update_result {
						Ok(res) => HttpResponse::Ok().json(res),
						Err(err) => HttpResponse::InternalServerError()
							.body(format!("Failed to update: {}", err)),
					}
				}
				None => HttpResponse::NotFound().finish(),
			},
			Err(err) => HttpResponse::InternalServerError()
				.body(format!("Failed to find table to update: {}", err)),
		}
	}
}

#[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct DeleteProductVariant {
	pub id: String,
}

impl DeleteProductVariant {
	async fn route(
		db: web::Data<DatabaseConnection>,
		path: web::Path<ProductVariantParmns>,
	) -> impl Responder {
		let res = ProductVariant::delete_by_id(path.id.clone()).exec(db.get_ref()).await;
		match res {
			Ok(_) => HttpResponse::Ok().finish(),
			Err(err) => {
				HttpResponse::InternalServerError().body(format!("Failed to delete: {}", err))
			}
		}
	}
}

#[derive(Default, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ResponseProductVariant {
	pub id: String,
	pub title: String,
	pub product_id: String,
	pub sku: Option<String>,
	pub barcode: Option<String>,
	pub ean: Option<String>,
	pub upc: Option<String>,
	pub inventory_quantity: i32,
	pub allow_backorder: bool,
	pub manage_inventory: bool,
	pub hs_code: Option<String>,
	pub origin_country: Option<String>,
	pub mid_code: Option<String>,
	pub material: Option<String>,
	pub weight: Option<i32>,
	pub length: Option<i32>,
	pub height: Option<i32>,
	pub width: Option<i32>,
	pub created_at: DateTimeWithTimeZone,
	pub updated_at: DateTimeWithTimeZone,
	pub deleted_at: Option<DateTimeWithTimeZone>,
	pub metadata: Option<Json>,
	pub variant_rank: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum PaymentCollectionStatusEnum {
	Authorized,
	Awaiting,
	Canceled,
	NotPaid,
	PartiallyAuthorized,
}

impl PaymentCollectionStatusEnum {
	fn to_string(&self) -> String {
		match self {
			PaymentCollectionStatusEnum::Authorized => "Authorized".to_string(),
			PaymentCollectionStatusEnum::Awaiting => "Awaiting".to_string(),
			PaymentCollectionStatusEnum::Canceled => "Canceled".to_string(),
			PaymentCollectionStatusEnum::NotPaid => "NotPaid".to_string(),
			PaymentCollectionStatusEnum::PartiallyAuthorized => "PartiallyAuthorized".to_string(),
		}
	}
}

impl From<PaymentCollectionStatusEnum> for sea_orm_active_enums::PaymentCollectionStatusEnum {
	fn from(model: PaymentCollectionStatusEnum) -> Self {
		match model {
			PaymentCollectionStatusEnum::Authorized => {
				sea_orm_active_enums::PaymentCollectionStatusEnum::Authorized
			}
			PaymentCollectionStatusEnum::Awaiting => {
				sea_orm_active_enums::PaymentCollectionStatusEnum::Awaiting
			}
			PaymentCollectionStatusEnum::Canceled => {
				sea_orm_active_enums::PaymentCollectionStatusEnum::Canceled
			}
			PaymentCollectionStatusEnum::NotPaid => {
				sea_orm_active_enums::PaymentCollectionStatusEnum::NotPaid
			}
			PaymentCollectionStatusEnum::PartiallyAuthorized => {
				sea_orm_active_enums::PaymentCollectionStatusEnum::PartiallyAuthorized
			}
		}
	}
}
impl From<PaymentCollectionStatusEnum> for sea_orm::Value {
	fn from(model: PaymentCollectionStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum PaymentCollectionTypeEnum {
	OrderEdit,
}

impl PaymentCollectionTypeEnum {
	fn to_string(&self) -> String {
		match self {
			PaymentCollectionTypeEnum::OrderEdit => "OrderEdit".to_string(),
		}
	}
}

impl From<PaymentCollectionTypeEnum> for sea_orm_active_enums::PaymentCollectionTypeEnum {
	fn from(model: PaymentCollectionTypeEnum) -> Self {
		match model {
			PaymentCollectionTypeEnum::OrderEdit => {
				sea_orm_active_enums::PaymentCollectionTypeEnum::OrderEdit
			}
		}
	}
}
impl From<PaymentCollectionTypeEnum> for sea_orm::Value {
	fn from(model: PaymentCollectionTypeEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum CartTypeEnum {
	Claim,
	Default,
	DraftOrder,
	PaymentLink,
	Swap,
}

impl CartTypeEnum {
	fn to_string(&self) -> String {
		match self {
			CartTypeEnum::Claim => "Claim".to_string(),
			CartTypeEnum::Default => "Default".to_string(),
			CartTypeEnum::DraftOrder => "DraftOrder".to_string(),
			CartTypeEnum::PaymentLink => "PaymentLink".to_string(),
			CartTypeEnum::Swap => "Swap".to_string(),
		}
	}
}

impl From<CartTypeEnum> for sea_orm_active_enums::CartTypeEnum {
	fn from(model: CartTypeEnum) -> Self {
		match model {
			CartTypeEnum::Claim => sea_orm_active_enums::CartTypeEnum::Claim,
			CartTypeEnum::Default => sea_orm_active_enums::CartTypeEnum::Default,
			CartTypeEnum::DraftOrder => sea_orm_active_enums::CartTypeEnum::DraftOrder,
			CartTypeEnum::PaymentLink => sea_orm_active_enums::CartTypeEnum::PaymentLink,
			CartTypeEnum::Swap => sea_orm_active_enums::CartTypeEnum::Swap,
		}
	}
}
impl From<CartTypeEnum> for sea_orm::Value {
	fn from(model: CartTypeEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum ClaimItemReasonEnum {
	MissingItem,
	Other,
	ProductionFailure,
	WrongItem,
}

impl ClaimItemReasonEnum {
	fn to_string(&self) -> String {
		match self {
			ClaimItemReasonEnum::MissingItem => "MissingItem".to_string(),
			ClaimItemReasonEnum::Other => "Other".to_string(),
			ClaimItemReasonEnum::ProductionFailure => "ProductionFailure".to_string(),
			ClaimItemReasonEnum::WrongItem => "WrongItem".to_string(),
		}
	}
}

impl From<ClaimItemReasonEnum> for sea_orm_active_enums::ClaimItemReasonEnum {
	fn from(model: ClaimItemReasonEnum) -> Self {
		match model {
			ClaimItemReasonEnum::MissingItem => {
				sea_orm_active_enums::ClaimItemReasonEnum::MissingItem
			}
			ClaimItemReasonEnum::Other => sea_orm_active_enums::ClaimItemReasonEnum::Other,
			ClaimItemReasonEnum::ProductionFailure => {
				sea_orm_active_enums::ClaimItemReasonEnum::ProductionFailure
			}
			ClaimItemReasonEnum::WrongItem => sea_orm_active_enums::ClaimItemReasonEnum::WrongItem,
		}
	}
}
impl From<ClaimItemReasonEnum> for sea_orm::Value {
	fn from(model: ClaimItemReasonEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum ClaimOrderFulfillmentStatusEnum {
	Canceled,
	Fulfilled,
	NotFulfilled,
	PartiallyFulfilled,
	PartiallyReturned,
	PartiallyShipped,
	RequiresAction,
	Returned,
	Shipped,
}

impl ClaimOrderFulfillmentStatusEnum {
	fn to_string(&self) -> String {
		match self {
			ClaimOrderFulfillmentStatusEnum::Canceled => "Canceled".to_string(),
			ClaimOrderFulfillmentStatusEnum::Fulfilled => "Fulfilled".to_string(),
			ClaimOrderFulfillmentStatusEnum::NotFulfilled => "NotFulfilled".to_string(),
			ClaimOrderFulfillmentStatusEnum::PartiallyFulfilled => "PartiallyFulfilled".to_string(),
			ClaimOrderFulfillmentStatusEnum::PartiallyReturned => "PartiallyReturned".to_string(),
			ClaimOrderFulfillmentStatusEnum::PartiallyShipped => "PartiallyShipped".to_string(),
			ClaimOrderFulfillmentStatusEnum::RequiresAction => "RequiresAction".to_string(),
			ClaimOrderFulfillmentStatusEnum::Returned => "Returned".to_string(),
			ClaimOrderFulfillmentStatusEnum::Shipped => "Shipped".to_string(),
		}
	}
}

impl From<ClaimOrderFulfillmentStatusEnum>
	for sea_orm_active_enums::ClaimOrderFulfillmentStatusEnum
{
	fn from(model: ClaimOrderFulfillmentStatusEnum) -> Self {
		match model {
			ClaimOrderFulfillmentStatusEnum::Canceled => {
				sea_orm_active_enums::ClaimOrderFulfillmentStatusEnum::Canceled
			}
			ClaimOrderFulfillmentStatusEnum::Fulfilled => {
				sea_orm_active_enums::ClaimOrderFulfillmentStatusEnum::Fulfilled
			}
			ClaimOrderFulfillmentStatusEnum::NotFulfilled => {
				sea_orm_active_enums::ClaimOrderFulfillmentStatusEnum::NotFulfilled
			}
			ClaimOrderFulfillmentStatusEnum::PartiallyFulfilled => {
				sea_orm_active_enums::ClaimOrderFulfillmentStatusEnum::PartiallyFulfilled
			}
			ClaimOrderFulfillmentStatusEnum::PartiallyReturned => {
				sea_orm_active_enums::ClaimOrderFulfillmentStatusEnum::PartiallyReturned
			}
			ClaimOrderFulfillmentStatusEnum::PartiallyShipped => {
				sea_orm_active_enums::ClaimOrderFulfillmentStatusEnum::PartiallyShipped
			}
			ClaimOrderFulfillmentStatusEnum::RequiresAction => {
				sea_orm_active_enums::ClaimOrderFulfillmentStatusEnum::RequiresAction
			}
			ClaimOrderFulfillmentStatusEnum::Returned => {
				sea_orm_active_enums::ClaimOrderFulfillmentStatusEnum::Returned
			}
			ClaimOrderFulfillmentStatusEnum::Shipped => {
				sea_orm_active_enums::ClaimOrderFulfillmentStatusEnum::Shipped
			}
		}
	}
}
impl From<ClaimOrderFulfillmentStatusEnum> for sea_orm::Value {
	fn from(model: ClaimOrderFulfillmentStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum ClaimOrderPaymentStatusEnum {
	Na,
	NotRefunded,
	Refunded,
}

impl ClaimOrderPaymentStatusEnum {
	fn to_string(&self) -> String {
		match self {
			ClaimOrderPaymentStatusEnum::Na => "Na".to_string(),
			ClaimOrderPaymentStatusEnum::NotRefunded => "NotRefunded".to_string(),
			ClaimOrderPaymentStatusEnum::Refunded => "Refunded".to_string(),
		}
	}
}

impl From<ClaimOrderPaymentStatusEnum> for sea_orm_active_enums::ClaimOrderPaymentStatusEnum {
	fn from(model: ClaimOrderPaymentStatusEnum) -> Self {
		match model {
			ClaimOrderPaymentStatusEnum::Na => {
				sea_orm_active_enums::ClaimOrderPaymentStatusEnum::Na
			}
			ClaimOrderPaymentStatusEnum::NotRefunded => {
				sea_orm_active_enums::ClaimOrderPaymentStatusEnum::NotRefunded
			}
			ClaimOrderPaymentStatusEnum::Refunded => {
				sea_orm_active_enums::ClaimOrderPaymentStatusEnum::Refunded
			}
		}
	}
}
impl From<ClaimOrderPaymentStatusEnum> for sea_orm::Value {
	fn from(model: ClaimOrderPaymentStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum ClaimOrderTypeEnum {
	Refund,
	Replace,
}

impl ClaimOrderTypeEnum {
	fn to_string(&self) -> String {
		match self {
			ClaimOrderTypeEnum::Refund => "Refund".to_string(),
			ClaimOrderTypeEnum::Replace => "Replace".to_string(),
		}
	}
}

impl From<ClaimOrderTypeEnum> for sea_orm_active_enums::ClaimOrderTypeEnum {
	fn from(model: ClaimOrderTypeEnum) -> Self {
		match model {
			ClaimOrderTypeEnum::Refund => sea_orm_active_enums::ClaimOrderTypeEnum::Refund,
			ClaimOrderTypeEnum::Replace => sea_orm_active_enums::ClaimOrderTypeEnum::Replace,
		}
	}
}
impl From<ClaimOrderTypeEnum> for sea_orm::Value {
	fn from(model: ClaimOrderTypeEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum DiscountConditionOperatorEnum {
	In,
	NotIn,
}

impl DiscountConditionOperatorEnum {
	fn to_string(&self) -> String {
		match self {
			DiscountConditionOperatorEnum::In => "In".to_string(),
			DiscountConditionOperatorEnum::NotIn => "NotIn".to_string(),
		}
	}
}

impl From<DiscountConditionOperatorEnum> for sea_orm_active_enums::DiscountConditionOperatorEnum {
	fn from(model: DiscountConditionOperatorEnum) -> Self {
		match model {
			DiscountConditionOperatorEnum::In => {
				sea_orm_active_enums::DiscountConditionOperatorEnum::In
			}
			DiscountConditionOperatorEnum::NotIn => {
				sea_orm_active_enums::DiscountConditionOperatorEnum::NotIn
			}
		}
	}
}
impl From<DiscountConditionOperatorEnum> for sea_orm::Value {
	fn from(model: DiscountConditionOperatorEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum DiscountConditionTypeEnum {
	CustomerGroups,
	ProductCollections,
	ProductTags,
	ProductTypes,
	Products,
}

impl DiscountConditionTypeEnum {
	fn to_string(&self) -> String {
		match self {
			DiscountConditionTypeEnum::CustomerGroups => "CustomerGroups".to_string(),
			DiscountConditionTypeEnum::ProductCollections => "ProductCollections".to_string(),
			DiscountConditionTypeEnum::ProductTags => "ProductTags".to_string(),
			DiscountConditionTypeEnum::ProductTypes => "ProductTypes".to_string(),
			DiscountConditionTypeEnum::Products => "Products".to_string(),
		}
	}
}

impl From<DiscountConditionTypeEnum> for sea_orm_active_enums::DiscountConditionTypeEnum {
	fn from(model: DiscountConditionTypeEnum) -> Self {
		match model {
			DiscountConditionTypeEnum::CustomerGroups => {
				sea_orm_active_enums::DiscountConditionTypeEnum::CustomerGroups
			}
			DiscountConditionTypeEnum::ProductCollections => {
				sea_orm_active_enums::DiscountConditionTypeEnum::ProductCollections
			}
			DiscountConditionTypeEnum::ProductTags => {
				sea_orm_active_enums::DiscountConditionTypeEnum::ProductTags
			}
			DiscountConditionTypeEnum::ProductTypes => {
				sea_orm_active_enums::DiscountConditionTypeEnum::ProductTypes
			}
			DiscountConditionTypeEnum::Products => {
				sea_orm_active_enums::DiscountConditionTypeEnum::Products
			}
		}
	}
}
impl From<DiscountConditionTypeEnum> for sea_orm::Value {
	fn from(model: DiscountConditionTypeEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum DiscountRuleAllocationEnum {
	Item,
	Total,
}

impl DiscountRuleAllocationEnum {
	fn to_string(&self) -> String {
		match self {
			DiscountRuleAllocationEnum::Item => "Item".to_string(),
			DiscountRuleAllocationEnum::Total => "Total".to_string(),
		}
	}
}

impl From<DiscountRuleAllocationEnum> for sea_orm_active_enums::DiscountRuleAllocationEnum {
	fn from(model: DiscountRuleAllocationEnum) -> Self {
		match model {
			DiscountRuleAllocationEnum::Item => {
				sea_orm_active_enums::DiscountRuleAllocationEnum::Item
			}
			DiscountRuleAllocationEnum::Total => {
				sea_orm_active_enums::DiscountRuleAllocationEnum::Total
			}
		}
	}
}
impl From<DiscountRuleAllocationEnum> for sea_orm::Value {
	fn from(model: DiscountRuleAllocationEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum DiscountRuleTypeEnum {
	Fixed,
	FreeShipping,
	Percentage,
}

impl DiscountRuleTypeEnum {
	fn to_string(&self) -> String {
		match self {
			DiscountRuleTypeEnum::Fixed => "Fixed".to_string(),
			DiscountRuleTypeEnum::FreeShipping => "FreeShipping".to_string(),
			DiscountRuleTypeEnum::Percentage => "Percentage".to_string(),
		}
	}
}

impl From<DiscountRuleTypeEnum> for sea_orm_active_enums::DiscountRuleTypeEnum {
	fn from(model: DiscountRuleTypeEnum) -> Self {
		match model {
			DiscountRuleTypeEnum::Fixed => sea_orm_active_enums::DiscountRuleTypeEnum::Fixed,
			DiscountRuleTypeEnum::FreeShipping => {
				sea_orm_active_enums::DiscountRuleTypeEnum::FreeShipping
			}
			DiscountRuleTypeEnum::Percentage => {
				sea_orm_active_enums::DiscountRuleTypeEnum::Percentage
			}
		}
	}
}
impl From<DiscountRuleTypeEnum> for sea_orm::Value {
	fn from(model: DiscountRuleTypeEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum DraftOrderStatusEnum {
	Completed,
	Open,
}

impl DraftOrderStatusEnum {
	fn to_string(&self) -> String {
		match self {
			DraftOrderStatusEnum::Completed => "Completed".to_string(),
			DraftOrderStatusEnum::Open => "Open".to_string(),
		}
	}
}

impl From<DraftOrderStatusEnum> for sea_orm_active_enums::DraftOrderStatusEnum {
	fn from(model: DraftOrderStatusEnum) -> Self {
		match model {
			DraftOrderStatusEnum::Completed => {
				sea_orm_active_enums::DraftOrderStatusEnum::Completed
			}
			DraftOrderStatusEnum::Open => sea_orm_active_enums::DraftOrderStatusEnum::Open,
		}
	}
}
impl From<DraftOrderStatusEnum> for sea_orm::Value {
	fn from(model: DraftOrderStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum InviteRoleEnum {
	Admin,
	Developer,
	Member,
}

impl InviteRoleEnum {
	fn to_string(&self) -> String {
		match self {
			InviteRoleEnum::Admin => "Admin".to_string(),
			InviteRoleEnum::Developer => "Developer".to_string(),
			InviteRoleEnum::Member => "Member".to_string(),
		}
	}
}

impl From<InviteRoleEnum> for sea_orm_active_enums::InviteRoleEnum {
	fn from(model: InviteRoleEnum) -> Self {
		match model {
			InviteRoleEnum::Admin => sea_orm_active_enums::InviteRoleEnum::Admin,
			InviteRoleEnum::Developer => sea_orm_active_enums::InviteRoleEnum::Developer,
			InviteRoleEnum::Member => sea_orm_active_enums::InviteRoleEnum::Member,
		}
	}
}
impl From<InviteRoleEnum> for sea_orm::Value {
	fn from(model: InviteRoleEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum OrderFulfillmentStatusEnum {
	Canceled,
	Fulfilled,
	NotFulfilled,
	PartiallyFulfilled,
	PartiallyReturned,
	PartiallyShipped,
	RequiresAction,
	Returned,
	Shipped,
}

impl OrderFulfillmentStatusEnum {
	fn to_string(&self) -> String {
		match self {
			OrderFulfillmentStatusEnum::Canceled => "Canceled".to_string(),
			OrderFulfillmentStatusEnum::Fulfilled => "Fulfilled".to_string(),
			OrderFulfillmentStatusEnum::NotFulfilled => "NotFulfilled".to_string(),
			OrderFulfillmentStatusEnum::PartiallyFulfilled => "PartiallyFulfilled".to_string(),
			OrderFulfillmentStatusEnum::PartiallyReturned => "PartiallyReturned".to_string(),
			OrderFulfillmentStatusEnum::PartiallyShipped => "PartiallyShipped".to_string(),
			OrderFulfillmentStatusEnum::RequiresAction => "RequiresAction".to_string(),
			OrderFulfillmentStatusEnum::Returned => "Returned".to_string(),
			OrderFulfillmentStatusEnum::Shipped => "Shipped".to_string(),
		}
	}
}

impl From<OrderFulfillmentStatusEnum> for sea_orm_active_enums::OrderFulfillmentStatusEnum {
	fn from(model: OrderFulfillmentStatusEnum) -> Self {
		match model {
			OrderFulfillmentStatusEnum::Canceled => {
				sea_orm_active_enums::OrderFulfillmentStatusEnum::Canceled
			}
			OrderFulfillmentStatusEnum::Fulfilled => {
				sea_orm_active_enums::OrderFulfillmentStatusEnum::Fulfilled
			}
			OrderFulfillmentStatusEnum::NotFulfilled => {
				sea_orm_active_enums::OrderFulfillmentStatusEnum::NotFulfilled
			}
			OrderFulfillmentStatusEnum::PartiallyFulfilled => {
				sea_orm_active_enums::OrderFulfillmentStatusEnum::PartiallyFulfilled
			}
			OrderFulfillmentStatusEnum::PartiallyReturned => {
				sea_orm_active_enums::OrderFulfillmentStatusEnum::PartiallyReturned
			}
			OrderFulfillmentStatusEnum::PartiallyShipped => {
				sea_orm_active_enums::OrderFulfillmentStatusEnum::PartiallyShipped
			}
			OrderFulfillmentStatusEnum::RequiresAction => {
				sea_orm_active_enums::OrderFulfillmentStatusEnum::RequiresAction
			}
			OrderFulfillmentStatusEnum::Returned => {
				sea_orm_active_enums::OrderFulfillmentStatusEnum::Returned
			}
			OrderFulfillmentStatusEnum::Shipped => {
				sea_orm_active_enums::OrderFulfillmentStatusEnum::Shipped
			}
		}
	}
}
impl From<OrderFulfillmentStatusEnum> for sea_orm::Value {
	fn from(model: OrderFulfillmentStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum OrderItemChangeTypeEnum {
	ItemAdd,
	ItemRemove,
	ItemUpdate,
}

impl OrderItemChangeTypeEnum {
	fn to_string(&self) -> String {
		match self {
			OrderItemChangeTypeEnum::ItemAdd => "ItemAdd".to_string(),
			OrderItemChangeTypeEnum::ItemRemove => "ItemRemove".to_string(),
			OrderItemChangeTypeEnum::ItemUpdate => "ItemUpdate".to_string(),
		}
	}
}

impl From<OrderItemChangeTypeEnum> for sea_orm_active_enums::OrderItemChangeTypeEnum {
	fn from(model: OrderItemChangeTypeEnum) -> Self {
		match model {
			OrderItemChangeTypeEnum::ItemAdd => {
				sea_orm_active_enums::OrderItemChangeTypeEnum::ItemAdd
			}
			OrderItemChangeTypeEnum::ItemRemove => {
				sea_orm_active_enums::OrderItemChangeTypeEnum::ItemRemove
			}
			OrderItemChangeTypeEnum::ItemUpdate => {
				sea_orm_active_enums::OrderItemChangeTypeEnum::ItemUpdate
			}
		}
	}
}
impl From<OrderItemChangeTypeEnum> for sea_orm::Value {
	fn from(model: OrderItemChangeTypeEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum OrderPaymentStatusEnum {
	Awaiting,
	Canceled,
	Captured,
	NotPaid,
	PartiallyRefunded,
	Refunded,
	RequiresAction,
}

impl OrderPaymentStatusEnum {
	fn to_string(&self) -> String {
		match self {
			OrderPaymentStatusEnum::Awaiting => "Awaiting".to_string(),
			OrderPaymentStatusEnum::Canceled => "Canceled".to_string(),
			OrderPaymentStatusEnum::Captured => "Captured".to_string(),
			OrderPaymentStatusEnum::NotPaid => "NotPaid".to_string(),
			OrderPaymentStatusEnum::PartiallyRefunded => "PartiallyRefunded".to_string(),
			OrderPaymentStatusEnum::Refunded => "Refunded".to_string(),
			OrderPaymentStatusEnum::RequiresAction => "RequiresAction".to_string(),
		}
	}
}

impl From<OrderPaymentStatusEnum> for sea_orm_active_enums::OrderPaymentStatusEnum {
	fn from(model: OrderPaymentStatusEnum) -> Self {
		match model {
			OrderPaymentStatusEnum::Awaiting => {
				sea_orm_active_enums::OrderPaymentStatusEnum::Awaiting
			}
			OrderPaymentStatusEnum::Canceled => {
				sea_orm_active_enums::OrderPaymentStatusEnum::Canceled
			}
			OrderPaymentStatusEnum::Captured => {
				sea_orm_active_enums::OrderPaymentStatusEnum::Captured
			}
			OrderPaymentStatusEnum::NotPaid => {
				sea_orm_active_enums::OrderPaymentStatusEnum::NotPaid
			}
			OrderPaymentStatusEnum::PartiallyRefunded => {
				sea_orm_active_enums::OrderPaymentStatusEnum::PartiallyRefunded
			}
			OrderPaymentStatusEnum::Refunded => {
				sea_orm_active_enums::OrderPaymentStatusEnum::Refunded
			}
			OrderPaymentStatusEnum::RequiresAction => {
				sea_orm_active_enums::OrderPaymentStatusEnum::RequiresAction
			}
		}
	}
}
impl From<OrderPaymentStatusEnum> for sea_orm::Value {
	fn from(model: OrderPaymentStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum OrderStatusEnum {
	Archived,
	Canceled,
	Completed,
	Pending,
	RequiresAction,
}

impl OrderStatusEnum {
	fn to_string(&self) -> String {
		match self {
			OrderStatusEnum::Archived => "Archived".to_string(),
			OrderStatusEnum::Canceled => "Canceled".to_string(),
			OrderStatusEnum::Completed => "Completed".to_string(),
			OrderStatusEnum::Pending => "Pending".to_string(),
			OrderStatusEnum::RequiresAction => "RequiresAction".to_string(),
		}
	}
}

impl From<OrderStatusEnum> for sea_orm_active_enums::OrderStatusEnum {
	fn from(model: OrderStatusEnum) -> Self {
		match model {
			OrderStatusEnum::Archived => sea_orm_active_enums::OrderStatusEnum::Archived,
			OrderStatusEnum::Canceled => sea_orm_active_enums::OrderStatusEnum::Canceled,
			OrderStatusEnum::Completed => sea_orm_active_enums::OrderStatusEnum::Completed,
			OrderStatusEnum::Pending => sea_orm_active_enums::OrderStatusEnum::Pending,
			OrderStatusEnum::RequiresAction => {
				sea_orm_active_enums::OrderStatusEnum::RequiresAction
			}
		}
	}
}
impl From<OrderStatusEnum> for sea_orm::Value {
	fn from(model: OrderStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum PaymentSessionStatusEnum {
	Authorized,
	Canceled,
	Error,
	Pending,
	RequiresMore,
}

impl PaymentSessionStatusEnum {
	fn to_string(&self) -> String {
		match self {
			PaymentSessionStatusEnum::Authorized => "Authorized".to_string(),
			PaymentSessionStatusEnum::Canceled => "Canceled".to_string(),
			PaymentSessionStatusEnum::Error => "Error".to_string(),
			PaymentSessionStatusEnum::Pending => "Pending".to_string(),
			PaymentSessionStatusEnum::RequiresMore => "RequiresMore".to_string(),
		}
	}
}

impl From<PaymentSessionStatusEnum> for sea_orm_active_enums::PaymentSessionStatusEnum {
	fn from(model: PaymentSessionStatusEnum) -> Self {
		match model {
			PaymentSessionStatusEnum::Authorized => {
				sea_orm_active_enums::PaymentSessionStatusEnum::Authorized
			}
			PaymentSessionStatusEnum::Canceled => {
				sea_orm_active_enums::PaymentSessionStatusEnum::Canceled
			}
			PaymentSessionStatusEnum::Error => {
				sea_orm_active_enums::PaymentSessionStatusEnum::Error
			}
			PaymentSessionStatusEnum::Pending => {
				sea_orm_active_enums::PaymentSessionStatusEnum::Pending
			}
			PaymentSessionStatusEnum::RequiresMore => {
				sea_orm_active_enums::PaymentSessionStatusEnum::RequiresMore
			}
		}
	}
}
impl From<PaymentSessionStatusEnum> for sea_orm::Value {
	fn from(model: PaymentSessionStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum PriceListStatusEnum {
	Active,
	Draft,
}

impl PriceListStatusEnum {
	fn to_string(&self) -> String {
		match self {
			PriceListStatusEnum::Active => "Active".to_string(),
			PriceListStatusEnum::Draft => "Draft".to_string(),
		}
	}
}

impl From<PriceListStatusEnum> for sea_orm_active_enums::PriceListStatusEnum {
	fn from(model: PriceListStatusEnum) -> Self {
		match model {
			PriceListStatusEnum::Active => sea_orm_active_enums::PriceListStatusEnum::Active,
			PriceListStatusEnum::Draft => sea_orm_active_enums::PriceListStatusEnum::Draft,
		}
	}
}
impl From<PriceListStatusEnum> for sea_orm::Value {
	fn from(model: PriceListStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum PriceListTypeEnum {
	Override,
	Sale,
}

impl PriceListTypeEnum {
	fn to_string(&self) -> String {
		match self {
			PriceListTypeEnum::Override => "Override".to_string(),
			PriceListTypeEnum::Sale => "Sale".to_string(),
		}
	}
}

impl From<PriceListTypeEnum> for sea_orm_active_enums::PriceListTypeEnum {
	fn from(model: PriceListTypeEnum) -> Self {
		match model {
			PriceListTypeEnum::Override => sea_orm_active_enums::PriceListTypeEnum::Override,
			PriceListTypeEnum::Sale => sea_orm_active_enums::PriceListTypeEnum::Sale,
		}
	}
}
impl From<PriceListTypeEnum> for sea_orm::Value {
	fn from(model: PriceListTypeEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum ProductStatusEnum {
	Draft,
	Proposed,
	Published,
	Rejected,
}

impl ProductStatusEnum {
	fn to_string(&self) -> String {
		match self {
			ProductStatusEnum::Draft => "Draft".to_string(),
			ProductStatusEnum::Proposed => "Proposed".to_string(),
			ProductStatusEnum::Published => "Published".to_string(),
			ProductStatusEnum::Rejected => "Rejected".to_string(),
		}
	}
}

impl From<ProductStatusEnum> for sea_orm_active_enums::ProductStatusEnum {
	fn from(model: ProductStatusEnum) -> Self {
		match model {
			ProductStatusEnum::Draft => sea_orm_active_enums::ProductStatusEnum::Draft,
			ProductStatusEnum::Proposed => sea_orm_active_enums::ProductStatusEnum::Proposed,
			ProductStatusEnum::Published => sea_orm_active_enums::ProductStatusEnum::Published,
			ProductStatusEnum::Rejected => sea_orm_active_enums::ProductStatusEnum::Rejected,
		}
	}
}
impl From<ProductStatusEnum> for sea_orm::Value {
	fn from(model: ProductStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum RefundReasonEnum {
	Claim,
	Discount,
	Other,
	Return,
	Swap,
}

impl RefundReasonEnum {
	fn to_string(&self) -> String {
		match self {
			RefundReasonEnum::Claim => "Claim".to_string(),
			RefundReasonEnum::Discount => "Discount".to_string(),
			RefundReasonEnum::Other => "Other".to_string(),
			RefundReasonEnum::Return => "Return".to_string(),
			RefundReasonEnum::Swap => "Swap".to_string(),
		}
	}
}

impl From<RefundReasonEnum> for sea_orm_active_enums::RefundReasonEnum {
	fn from(model: RefundReasonEnum) -> Self {
		match model {
			RefundReasonEnum::Claim => sea_orm_active_enums::RefundReasonEnum::Claim,
			RefundReasonEnum::Discount => sea_orm_active_enums::RefundReasonEnum::Discount,
			RefundReasonEnum::Other => sea_orm_active_enums::RefundReasonEnum::Other,
			RefundReasonEnum::Return => sea_orm_active_enums::RefundReasonEnum::Return,
			RefundReasonEnum::Swap => sea_orm_active_enums::RefundReasonEnum::Swap,
		}
	}
}
impl From<RefundReasonEnum> for sea_orm::Value {
	fn from(model: RefundReasonEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum ReturnStatusEnum {
	Canceled,
	Received,
	Requested,
	RequiresAction,
}

impl ReturnStatusEnum {
	fn to_string(&self) -> String {
		match self {
			ReturnStatusEnum::Canceled => "Canceled".to_string(),
			ReturnStatusEnum::Received => "Received".to_string(),
			ReturnStatusEnum::Requested => "Requested".to_string(),
			ReturnStatusEnum::RequiresAction => "RequiresAction".to_string(),
		}
	}
}

impl From<ReturnStatusEnum> for sea_orm_active_enums::ReturnStatusEnum {
	fn from(model: ReturnStatusEnum) -> Self {
		match model {
			ReturnStatusEnum::Canceled => sea_orm_active_enums::ReturnStatusEnum::Canceled,
			ReturnStatusEnum::Received => sea_orm_active_enums::ReturnStatusEnum::Received,
			ReturnStatusEnum::Requested => sea_orm_active_enums::ReturnStatusEnum::Requested,
			ReturnStatusEnum::RequiresAction => {
				sea_orm_active_enums::ReturnStatusEnum::RequiresAction
			}
		}
	}
}
impl From<ReturnStatusEnum> for sea_orm::Value {
	fn from(model: ReturnStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum ShippingOptionPriceTypeEnum {
	Calculated,
	FlatRate,
}

impl ShippingOptionPriceTypeEnum {
	fn to_string(&self) -> String {
		match self {
			ShippingOptionPriceTypeEnum::Calculated => "Calculated".to_string(),
			ShippingOptionPriceTypeEnum::FlatRate => "FlatRate".to_string(),
		}
	}
}

impl From<ShippingOptionPriceTypeEnum> for sea_orm_active_enums::ShippingOptionPriceTypeEnum {
	fn from(model: ShippingOptionPriceTypeEnum) -> Self {
		match model {
			ShippingOptionPriceTypeEnum::Calculated => {
				sea_orm_active_enums::ShippingOptionPriceTypeEnum::Calculated
			}
			ShippingOptionPriceTypeEnum::FlatRate => {
				sea_orm_active_enums::ShippingOptionPriceTypeEnum::FlatRate
			}
		}
	}
}
impl From<ShippingOptionPriceTypeEnum> for sea_orm::Value {
	fn from(model: ShippingOptionPriceTypeEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum ShippingOptionRequirementTypeEnum {
	MaxSubtotal,
	MinSubtotal,
}

impl ShippingOptionRequirementTypeEnum {
	fn to_string(&self) -> String {
		match self {
			ShippingOptionRequirementTypeEnum::MaxSubtotal => "MaxSubtotal".to_string(),
			ShippingOptionRequirementTypeEnum::MinSubtotal => "MinSubtotal".to_string(),
		}
	}
}

impl From<ShippingOptionRequirementTypeEnum>
	for sea_orm_active_enums::ShippingOptionRequirementTypeEnum
{
	fn from(model: ShippingOptionRequirementTypeEnum) -> Self {
		match model {
			ShippingOptionRequirementTypeEnum::MaxSubtotal => {
				sea_orm_active_enums::ShippingOptionRequirementTypeEnum::MaxSubtotal
			}
			ShippingOptionRequirementTypeEnum::MinSubtotal => {
				sea_orm_active_enums::ShippingOptionRequirementTypeEnum::MinSubtotal
			}
		}
	}
}
impl From<ShippingOptionRequirementTypeEnum> for sea_orm::Value {
	fn from(model: ShippingOptionRequirementTypeEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum ShippingProfileTypeEnum {
	Custom,
	Default,
	GiftCard,
}

impl ShippingProfileTypeEnum {
	fn to_string(&self) -> String {
		match self {
			ShippingProfileTypeEnum::Custom => "Custom".to_string(),
			ShippingProfileTypeEnum::Default => "Default".to_string(),
			ShippingProfileTypeEnum::GiftCard => "GiftCard".to_string(),
		}
	}
}

impl From<ShippingProfileTypeEnum> for sea_orm_active_enums::ShippingProfileTypeEnum {
	fn from(model: ShippingProfileTypeEnum) -> Self {
		match model {
			ShippingProfileTypeEnum::Custom => {
				sea_orm_active_enums::ShippingProfileTypeEnum::Custom
			}
			ShippingProfileTypeEnum::Default => {
				sea_orm_active_enums::ShippingProfileTypeEnum::Default
			}
			ShippingProfileTypeEnum::GiftCard => {
				sea_orm_active_enums::ShippingProfileTypeEnum::GiftCard
			}
		}
	}
}
impl From<ShippingProfileTypeEnum> for sea_orm::Value {
	fn from(model: ShippingProfileTypeEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum SwapFulfillmentStatusEnum {
	Canceled,
	Fulfilled,
	NotFulfilled,
	PartiallyShipped,
	RequiresAction,
	Shipped,
}

impl SwapFulfillmentStatusEnum {
	fn to_string(&self) -> String {
		match self {
			SwapFulfillmentStatusEnum::Canceled => "Canceled".to_string(),
			SwapFulfillmentStatusEnum::Fulfilled => "Fulfilled".to_string(),
			SwapFulfillmentStatusEnum::NotFulfilled => "NotFulfilled".to_string(),
			SwapFulfillmentStatusEnum::PartiallyShipped => "PartiallyShipped".to_string(),
			SwapFulfillmentStatusEnum::RequiresAction => "RequiresAction".to_string(),
			SwapFulfillmentStatusEnum::Shipped => "Shipped".to_string(),
		}
	}
}

impl From<SwapFulfillmentStatusEnum> for sea_orm_active_enums::SwapFulfillmentStatusEnum {
	fn from(model: SwapFulfillmentStatusEnum) -> Self {
		match model {
			SwapFulfillmentStatusEnum::Canceled => {
				sea_orm_active_enums::SwapFulfillmentStatusEnum::Canceled
			}
			SwapFulfillmentStatusEnum::Fulfilled => {
				sea_orm_active_enums::SwapFulfillmentStatusEnum::Fulfilled
			}
			SwapFulfillmentStatusEnum::NotFulfilled => {
				sea_orm_active_enums::SwapFulfillmentStatusEnum::NotFulfilled
			}
			SwapFulfillmentStatusEnum::PartiallyShipped => {
				sea_orm_active_enums::SwapFulfillmentStatusEnum::PartiallyShipped
			}
			SwapFulfillmentStatusEnum::RequiresAction => {
				sea_orm_active_enums::SwapFulfillmentStatusEnum::RequiresAction
			}
			SwapFulfillmentStatusEnum::Shipped => {
				sea_orm_active_enums::SwapFulfillmentStatusEnum::Shipped
			}
		}
	}
}
impl From<SwapFulfillmentStatusEnum> for sea_orm::Value {
	fn from(model: SwapFulfillmentStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum SwapPaymentStatusEnum {
	Awaiting,
	Canceled,
	Captured,
	Confirmed,
	DifferenceRefunded,
	NotPaid,
	PartiallyRefunded,
	Refunded,
	RequiresAction,
}

impl SwapPaymentStatusEnum {
	fn to_string(&self) -> String {
		match self {
			SwapPaymentStatusEnum::Awaiting => "Awaiting".to_string(),
			SwapPaymentStatusEnum::Canceled => "Canceled".to_string(),
			SwapPaymentStatusEnum::Captured => "Captured".to_string(),
			SwapPaymentStatusEnum::Confirmed => "Confirmed".to_string(),
			SwapPaymentStatusEnum::DifferenceRefunded => "DifferenceRefunded".to_string(),
			SwapPaymentStatusEnum::NotPaid => "NotPaid".to_string(),
			SwapPaymentStatusEnum::PartiallyRefunded => "PartiallyRefunded".to_string(),
			SwapPaymentStatusEnum::Refunded => "Refunded".to_string(),
			SwapPaymentStatusEnum::RequiresAction => "RequiresAction".to_string(),
		}
	}
}

impl From<SwapPaymentStatusEnum> for sea_orm_active_enums::SwapPaymentStatusEnum {
	fn from(model: SwapPaymentStatusEnum) -> Self {
		match model {
			SwapPaymentStatusEnum::Awaiting => {
				sea_orm_active_enums::SwapPaymentStatusEnum::Awaiting
			}
			SwapPaymentStatusEnum::Canceled => {
				sea_orm_active_enums::SwapPaymentStatusEnum::Canceled
			}
			SwapPaymentStatusEnum::Captured => {
				sea_orm_active_enums::SwapPaymentStatusEnum::Captured
			}
			SwapPaymentStatusEnum::Confirmed => {
				sea_orm_active_enums::SwapPaymentStatusEnum::Confirmed
			}
			SwapPaymentStatusEnum::DifferenceRefunded => {
				sea_orm_active_enums::SwapPaymentStatusEnum::DifferenceRefunded
			}
			SwapPaymentStatusEnum::NotPaid => sea_orm_active_enums::SwapPaymentStatusEnum::NotPaid,
			SwapPaymentStatusEnum::PartiallyRefunded => {
				sea_orm_active_enums::SwapPaymentStatusEnum::PartiallyRefunded
			}
			SwapPaymentStatusEnum::Refunded => {
				sea_orm_active_enums::SwapPaymentStatusEnum::Refunded
			}
			SwapPaymentStatusEnum::RequiresAction => {
				sea_orm_active_enums::SwapPaymentStatusEnum::RequiresAction
			}
		}
	}
}
impl From<SwapPaymentStatusEnum> for sea_orm::Value {
	fn from(model: SwapPaymentStatusEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Serialize, Deserialize)]
pub enum UserRoleEnum {
	Admin,
	Developer,
	Member,
}

impl UserRoleEnum {
	fn to_string(&self) -> String {
		match self {
			UserRoleEnum::Admin => "Admin".to_string(),
			UserRoleEnum::Developer => "Developer".to_string(),
			UserRoleEnum::Member => "Member".to_string(),
		}
	}
}

impl From<UserRoleEnum> for sea_orm_active_enums::UserRoleEnum {
	fn from(model: UserRoleEnum) -> Self {
		match model {
			UserRoleEnum::Admin => sea_orm_active_enums::UserRoleEnum::Admin,
			UserRoleEnum::Developer => sea_orm_active_enums::UserRoleEnum::Developer,
			UserRoleEnum::Member => sea_orm_active_enums::UserRoleEnum::Member,
		}
	}
}
impl From<UserRoleEnum> for sea_orm::Value {
	fn from(model: UserRoleEnum) -> Self {
		sea_orm::Value::String(Some(Box::new(model.to_string())))
	}
}
