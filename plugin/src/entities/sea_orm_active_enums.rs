//! `SeaORM` Entity, @generated by sea-orm-codegen 0.1.0

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "PAYMENT_COLLECTION_STATUS_ENUM")]
pub enum PaymentCollectionStatusEnum {
	#[sea_orm(string_value = "authorized")]
	Authorized,
	#[sea_orm(string_value = "awaiting")]
	Awaiting,
	#[sea_orm(string_value = "canceled")]
	Canceled,
	#[sea_orm(string_value = "not_paid")]
	NotPaid,
	#[sea_orm(string_value = "partially_authorized")]
	PartiallyAuthorized,
}
impl PaymentCollectionStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(PaymentCollectionStatusEnum::Authorized),
			1 => Ok(PaymentCollectionStatusEnum::Awaiting),
			2 => Ok(PaymentCollectionStatusEnum::Canceled),
			3 => Ok(PaymentCollectionStatusEnum::NotPaid),
			4 => Ok(PaymentCollectionStatusEnum::PartiallyAuthorized),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: PaymentCollectionStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			PaymentCollectionStatusEnum::Authorized => 0,
			PaymentCollectionStatusEnum::Awaiting => 1,
			PaymentCollectionStatusEnum::Canceled => 2,
			PaymentCollectionStatusEnum::NotPaid => 3,
			PaymentCollectionStatusEnum::PartiallyAuthorized => 4,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "PAYMENT_COLLECTION_TYPE_ENUM")]
pub enum PaymentCollectionTypeEnum {
	#[sea_orm(string_value = "order_edit")]
	OrderEdit,
}
impl PaymentCollectionTypeEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(PaymentCollectionTypeEnum::OrderEdit),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: PaymentCollectionTypeEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			PaymentCollectionTypeEnum::OrderEdit => 0,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "cart_type_enum")]
pub enum CartTypeEnum {
	#[sea_orm(string_value = "claim")]
	Claim,
	#[sea_orm(string_value = "default")]
	Default,
	#[sea_orm(string_value = "draft_order")]
	DraftOrder,
	#[sea_orm(string_value = "payment_link")]
	PaymentLink,
	#[sea_orm(string_value = "swap")]
	Swap,
}
impl CartTypeEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(CartTypeEnum::Claim),
			1 => Ok(CartTypeEnum::Default),
			2 => Ok(CartTypeEnum::DraftOrder),
			3 => Ok(CartTypeEnum::PaymentLink),
			4 => Ok(CartTypeEnum::Swap),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: CartTypeEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			CartTypeEnum::Claim => 0,
			CartTypeEnum::Default => 1,
			CartTypeEnum::DraftOrder => 2,
			CartTypeEnum::PaymentLink => 3,
			CartTypeEnum::Swap => 4,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "claim_item_reason_enum")]
pub enum ClaimItemReasonEnum {
	#[sea_orm(string_value = "missing_item")]
	MissingItem,
	#[sea_orm(string_value = "other")]
	Other,
	#[sea_orm(string_value = "production_failure")]
	ProductionFailure,
	#[sea_orm(string_value = "wrong_item")]
	WrongItem,
}
impl ClaimItemReasonEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(ClaimItemReasonEnum::MissingItem),
			1 => Ok(ClaimItemReasonEnum::Other),
			2 => Ok(ClaimItemReasonEnum::ProductionFailure),
			3 => Ok(ClaimItemReasonEnum::WrongItem),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: ClaimItemReasonEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			ClaimItemReasonEnum::MissingItem => 0,
			ClaimItemReasonEnum::Other => 1,
			ClaimItemReasonEnum::ProductionFailure => 2,
			ClaimItemReasonEnum::WrongItem => 3,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "claim_order_fulfillment_status_enum")]
pub enum ClaimOrderFulfillmentStatusEnum {
	#[sea_orm(string_value = "canceled")]
	Canceled,
	#[sea_orm(string_value = "fulfilled")]
	Fulfilled,
	#[sea_orm(string_value = "not_fulfilled")]
	NotFulfilled,
	#[sea_orm(string_value = "partially_fulfilled")]
	PartiallyFulfilled,
	#[sea_orm(string_value = "partially_returned")]
	PartiallyReturned,
	#[sea_orm(string_value = "partially_shipped")]
	PartiallyShipped,
	#[sea_orm(string_value = "requires_action")]
	RequiresAction,
	#[sea_orm(string_value = "returned")]
	Returned,
	#[sea_orm(string_value = "shipped")]
	Shipped,
}
impl ClaimOrderFulfillmentStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(ClaimOrderFulfillmentStatusEnum::Canceled),
			1 => Ok(ClaimOrderFulfillmentStatusEnum::Fulfilled),
			2 => Ok(ClaimOrderFulfillmentStatusEnum::NotFulfilled),
			3 => Ok(ClaimOrderFulfillmentStatusEnum::PartiallyFulfilled),
			4 => Ok(ClaimOrderFulfillmentStatusEnum::PartiallyReturned),
			5 => Ok(ClaimOrderFulfillmentStatusEnum::PartiallyShipped),
			6 => Ok(ClaimOrderFulfillmentStatusEnum::RequiresAction),
			7 => Ok(ClaimOrderFulfillmentStatusEnum::Returned),
			8 => Ok(ClaimOrderFulfillmentStatusEnum::Shipped),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: ClaimOrderFulfillmentStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			ClaimOrderFulfillmentStatusEnum::Canceled => 0,
			ClaimOrderFulfillmentStatusEnum::Fulfilled => 1,
			ClaimOrderFulfillmentStatusEnum::NotFulfilled => 2,
			ClaimOrderFulfillmentStatusEnum::PartiallyFulfilled => 3,
			ClaimOrderFulfillmentStatusEnum::PartiallyReturned => 4,
			ClaimOrderFulfillmentStatusEnum::PartiallyShipped => 5,
			ClaimOrderFulfillmentStatusEnum::RequiresAction => 6,
			ClaimOrderFulfillmentStatusEnum::Returned => 7,
			ClaimOrderFulfillmentStatusEnum::Shipped => 8,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "claim_order_payment_status_enum")]
pub enum ClaimOrderPaymentStatusEnum {
	#[sea_orm(string_value = "na")]
	Na,
	#[sea_orm(string_value = "not_refunded")]
	NotRefunded,
	#[sea_orm(string_value = "refunded")]
	Refunded,
}
impl ClaimOrderPaymentStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(ClaimOrderPaymentStatusEnum::Na),
			1 => Ok(ClaimOrderPaymentStatusEnum::NotRefunded),
			2 => Ok(ClaimOrderPaymentStatusEnum::Refunded),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: ClaimOrderPaymentStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			ClaimOrderPaymentStatusEnum::Na => 0,
			ClaimOrderPaymentStatusEnum::NotRefunded => 1,
			ClaimOrderPaymentStatusEnum::Refunded => 2,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "claim_order_type_enum")]
pub enum ClaimOrderTypeEnum {
	#[sea_orm(string_value = "refund")]
	Refund,
	#[sea_orm(string_value = "replace")]
	Replace,
}
impl ClaimOrderTypeEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(ClaimOrderTypeEnum::Refund),
			1 => Ok(ClaimOrderTypeEnum::Replace),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: ClaimOrderTypeEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			ClaimOrderTypeEnum::Refund => 0,
			ClaimOrderTypeEnum::Replace => 1,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "discount_condition_operator_enum")]
pub enum DiscountConditionOperatorEnum {
	#[sea_orm(string_value = "in")]
	In,
	#[sea_orm(string_value = "not_in")]
	NotIn,
}
impl DiscountConditionOperatorEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(DiscountConditionOperatorEnum::In),
			1 => Ok(DiscountConditionOperatorEnum::NotIn),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: DiscountConditionOperatorEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			DiscountConditionOperatorEnum::In => 0,
			DiscountConditionOperatorEnum::NotIn => 1,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "discount_condition_type_enum")]
pub enum DiscountConditionTypeEnum {
	#[sea_orm(string_value = "customer_groups")]
	CustomerGroups,
	#[sea_orm(string_value = "product_collections")]
	ProductCollections,
	#[sea_orm(string_value = "product_tags")]
	ProductTags,
	#[sea_orm(string_value = "product_types")]
	ProductTypes,
	#[sea_orm(string_value = "products")]
	Products,
}
impl DiscountConditionTypeEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(DiscountConditionTypeEnum::CustomerGroups),
			1 => Ok(DiscountConditionTypeEnum::ProductCollections),
			2 => Ok(DiscountConditionTypeEnum::ProductTags),
			3 => Ok(DiscountConditionTypeEnum::ProductTypes),
			4 => Ok(DiscountConditionTypeEnum::Products),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: DiscountConditionTypeEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			DiscountConditionTypeEnum::CustomerGroups => 0,
			DiscountConditionTypeEnum::ProductCollections => 1,
			DiscountConditionTypeEnum::ProductTags => 2,
			DiscountConditionTypeEnum::ProductTypes => 3,
			DiscountConditionTypeEnum::Products => 4,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "discount_rule_allocation_enum")]
pub enum DiscountRuleAllocationEnum {
	#[sea_orm(string_value = "item")]
	Item,
	#[sea_orm(string_value = "total")]
	Total,
}
impl DiscountRuleAllocationEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(DiscountRuleAllocationEnum::Item),
			1 => Ok(DiscountRuleAllocationEnum::Total),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: DiscountRuleAllocationEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			DiscountRuleAllocationEnum::Item => 0,
			DiscountRuleAllocationEnum::Total => 1,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "discount_rule_type_enum")]
pub enum DiscountRuleTypeEnum {
	#[sea_orm(string_value = "fixed")]
	Fixed,
	#[sea_orm(string_value = "free_shipping")]
	FreeShipping,
	#[sea_orm(string_value = "percentage")]
	Percentage,
}
impl DiscountRuleTypeEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(DiscountRuleTypeEnum::Fixed),
			1 => Ok(DiscountRuleTypeEnum::FreeShipping),
			2 => Ok(DiscountRuleTypeEnum::Percentage),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: DiscountRuleTypeEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			DiscountRuleTypeEnum::Fixed => 0,
			DiscountRuleTypeEnum::FreeShipping => 1,
			DiscountRuleTypeEnum::Percentage => 2,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "draft_order_status_enum")]
pub enum DraftOrderStatusEnum {
	#[sea_orm(string_value = "completed")]
	Completed,
	#[sea_orm(string_value = "open")]
	Open,
}
impl DraftOrderStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(DraftOrderStatusEnum::Completed),
			1 => Ok(DraftOrderStatusEnum::Open),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: DraftOrderStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			DraftOrderStatusEnum::Completed => 0,
			DraftOrderStatusEnum::Open => 1,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "invite_role_enum")]
pub enum InviteRoleEnum {
	#[sea_orm(string_value = "admin")]
	Admin,
	#[sea_orm(string_value = "developer")]
	Developer,
	#[sea_orm(string_value = "member")]
	Member,
}
impl InviteRoleEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(InviteRoleEnum::Admin),
			1 => Ok(InviteRoleEnum::Developer),
			2 => Ok(InviteRoleEnum::Member),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: InviteRoleEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			InviteRoleEnum::Admin => 0,
			InviteRoleEnum::Developer => 1,
			InviteRoleEnum::Member => 2,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "order_fulfillment_status_enum")]
pub enum OrderFulfillmentStatusEnum {
	#[sea_orm(string_value = "canceled")]
	Canceled,
	#[sea_orm(string_value = "fulfilled")]
	Fulfilled,
	#[sea_orm(string_value = "not_fulfilled")]
	NotFulfilled,
	#[sea_orm(string_value = "partially_fulfilled")]
	PartiallyFulfilled,
	#[sea_orm(string_value = "partially_returned")]
	PartiallyReturned,
	#[sea_orm(string_value = "partially_shipped")]
	PartiallyShipped,
	#[sea_orm(string_value = "requires_action")]
	RequiresAction,
	#[sea_orm(string_value = "returned")]
	Returned,
	#[sea_orm(string_value = "shipped")]
	Shipped,
}
impl OrderFulfillmentStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(OrderFulfillmentStatusEnum::Canceled),
			1 => Ok(OrderFulfillmentStatusEnum::Fulfilled),
			2 => Ok(OrderFulfillmentStatusEnum::NotFulfilled),
			3 => Ok(OrderFulfillmentStatusEnum::PartiallyFulfilled),
			4 => Ok(OrderFulfillmentStatusEnum::PartiallyReturned),
			5 => Ok(OrderFulfillmentStatusEnum::PartiallyShipped),
			6 => Ok(OrderFulfillmentStatusEnum::RequiresAction),
			7 => Ok(OrderFulfillmentStatusEnum::Returned),
			8 => Ok(OrderFulfillmentStatusEnum::Shipped),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: OrderFulfillmentStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			OrderFulfillmentStatusEnum::Canceled => 0,
			OrderFulfillmentStatusEnum::Fulfilled => 1,
			OrderFulfillmentStatusEnum::NotFulfilled => 2,
			OrderFulfillmentStatusEnum::PartiallyFulfilled => 3,
			OrderFulfillmentStatusEnum::PartiallyReturned => 4,
			OrderFulfillmentStatusEnum::PartiallyShipped => 5,
			OrderFulfillmentStatusEnum::RequiresAction => 6,
			OrderFulfillmentStatusEnum::Returned => 7,
			OrderFulfillmentStatusEnum::Shipped => 8,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "order_item_change_type_enum")]
pub enum OrderItemChangeTypeEnum {
	#[sea_orm(string_value = "item_add")]
	ItemAdd,
	#[sea_orm(string_value = "item_remove")]
	ItemRemove,
	#[sea_orm(string_value = "item_update")]
	ItemUpdate,
}
impl OrderItemChangeTypeEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(OrderItemChangeTypeEnum::ItemAdd),
			1 => Ok(OrderItemChangeTypeEnum::ItemRemove),
			2 => Ok(OrderItemChangeTypeEnum::ItemUpdate),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: OrderItemChangeTypeEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			OrderItemChangeTypeEnum::ItemAdd => 0,
			OrderItemChangeTypeEnum::ItemRemove => 1,
			OrderItemChangeTypeEnum::ItemUpdate => 2,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "order_payment_status_enum")]
pub enum OrderPaymentStatusEnum {
	#[sea_orm(string_value = "awaiting")]
	Awaiting,
	#[sea_orm(string_value = "canceled")]
	Canceled,
	#[sea_orm(string_value = "captured")]
	Captured,
	#[sea_orm(string_value = "not_paid")]
	NotPaid,
	#[sea_orm(string_value = "partially_refunded")]
	PartiallyRefunded,
	#[sea_orm(string_value = "refunded")]
	Refunded,
	#[sea_orm(string_value = "requires_action")]
	RequiresAction,
}
impl OrderPaymentStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(OrderPaymentStatusEnum::Awaiting),
			1 => Ok(OrderPaymentStatusEnum::Canceled),
			2 => Ok(OrderPaymentStatusEnum::Captured),
			3 => Ok(OrderPaymentStatusEnum::NotPaid),
			4 => Ok(OrderPaymentStatusEnum::PartiallyRefunded),
			5 => Ok(OrderPaymentStatusEnum::Refunded),
			6 => Ok(OrderPaymentStatusEnum::RequiresAction),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: OrderPaymentStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			OrderPaymentStatusEnum::Awaiting => 0,
			OrderPaymentStatusEnum::Canceled => 1,
			OrderPaymentStatusEnum::Captured => 2,
			OrderPaymentStatusEnum::NotPaid => 3,
			OrderPaymentStatusEnum::PartiallyRefunded => 4,
			OrderPaymentStatusEnum::Refunded => 5,
			OrderPaymentStatusEnum::RequiresAction => 6,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "order_status_enum")]
pub enum OrderStatusEnum {
	#[sea_orm(string_value = "archived")]
	Archived,
	#[sea_orm(string_value = "canceled")]
	Canceled,
	#[sea_orm(string_value = "completed")]
	Completed,
	#[sea_orm(string_value = "pending")]
	Pending,
	#[sea_orm(string_value = "requires_action")]
	RequiresAction,
}
impl OrderStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(OrderStatusEnum::Archived),
			1 => Ok(OrderStatusEnum::Canceled),
			2 => Ok(OrderStatusEnum::Completed),
			3 => Ok(OrderStatusEnum::Pending),
			4 => Ok(OrderStatusEnum::RequiresAction),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: OrderStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			OrderStatusEnum::Archived => 0,
			OrderStatusEnum::Canceled => 1,
			OrderStatusEnum::Completed => 2,
			OrderStatusEnum::Pending => 3,
			OrderStatusEnum::RequiresAction => 4,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "payment_session_status_enum")]
pub enum PaymentSessionStatusEnum {
	#[sea_orm(string_value = "authorized")]
	Authorized,
	#[sea_orm(string_value = "canceled")]
	Canceled,
	#[sea_orm(string_value = "error")]
	Error,
	#[sea_orm(string_value = "pending")]
	Pending,
	#[sea_orm(string_value = "requires_more")]
	RequiresMore,
}
impl PaymentSessionStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(PaymentSessionStatusEnum::Authorized),
			1 => Ok(PaymentSessionStatusEnum::Canceled),
			2 => Ok(PaymentSessionStatusEnum::Error),
			3 => Ok(PaymentSessionStatusEnum::Pending),
			4 => Ok(PaymentSessionStatusEnum::RequiresMore),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: PaymentSessionStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			PaymentSessionStatusEnum::Authorized => 0,
			PaymentSessionStatusEnum::Canceled => 1,
			PaymentSessionStatusEnum::Error => 2,
			PaymentSessionStatusEnum::Pending => 3,
			PaymentSessionStatusEnum::RequiresMore => 4,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "price_list_status_enum")]
pub enum PriceListStatusEnum {
	#[sea_orm(string_value = "active")]
	Active,
	#[sea_orm(string_value = "draft")]
	Draft,
}
impl PriceListStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(PriceListStatusEnum::Active),
			1 => Ok(PriceListStatusEnum::Draft),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: PriceListStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			PriceListStatusEnum::Active => 0,
			PriceListStatusEnum::Draft => 1,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "price_list_type_enum")]
pub enum PriceListTypeEnum {
	#[sea_orm(string_value = "override")]
	Override,
	#[sea_orm(string_value = "sale")]
	Sale,
}
impl PriceListTypeEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(PriceListTypeEnum::Override),
			1 => Ok(PriceListTypeEnum::Sale),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: PriceListTypeEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			PriceListTypeEnum::Override => 0,
			PriceListTypeEnum::Sale => 1,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "product_status_enum")]
pub enum ProductStatusEnum {
	#[sea_orm(string_value = "draft")]
	Draft,
	#[sea_orm(string_value = "proposed")]
	Proposed,
	#[sea_orm(string_value = "published")]
	Published,
	#[sea_orm(string_value = "rejected")]
	Rejected,
}
impl ProductStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(ProductStatusEnum::Draft),
			1 => Ok(ProductStatusEnum::Proposed),
			2 => Ok(ProductStatusEnum::Published),
			3 => Ok(ProductStatusEnum::Rejected),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: ProductStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			ProductStatusEnum::Draft => 0,
			ProductStatusEnum::Proposed => 1,
			ProductStatusEnum::Published => 2,
			ProductStatusEnum::Rejected => 3,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "refund_reason_enum")]
pub enum RefundReasonEnum {
	#[sea_orm(string_value = "claim")]
	Claim,
	#[sea_orm(string_value = "discount")]
	Discount,
	#[sea_orm(string_value = "other")]
	Other,
	#[sea_orm(string_value = "return")]
	Return,
	#[sea_orm(string_value = "swap")]
	Swap,
}
impl RefundReasonEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(RefundReasonEnum::Claim),
			1 => Ok(RefundReasonEnum::Discount),
			2 => Ok(RefundReasonEnum::Other),
			3 => Ok(RefundReasonEnum::Return),
			4 => Ok(RefundReasonEnum::Swap),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: RefundReasonEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			RefundReasonEnum::Claim => 0,
			RefundReasonEnum::Discount => 1,
			RefundReasonEnum::Other => 2,
			RefundReasonEnum::Return => 3,
			RefundReasonEnum::Swap => 4,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "return_status_enum")]
pub enum ReturnStatusEnum {
	#[sea_orm(string_value = "canceled")]
	Canceled,
	#[sea_orm(string_value = "received")]
	Received,
	#[sea_orm(string_value = "requested")]
	Requested,
	#[sea_orm(string_value = "requires_action")]
	RequiresAction,
}
impl ReturnStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(ReturnStatusEnum::Canceled),
			1 => Ok(ReturnStatusEnum::Received),
			2 => Ok(ReturnStatusEnum::Requested),
			3 => Ok(ReturnStatusEnum::RequiresAction),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: ReturnStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			ReturnStatusEnum::Canceled => 0,
			ReturnStatusEnum::Received => 1,
			ReturnStatusEnum::Requested => 2,
			ReturnStatusEnum::RequiresAction => 3,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "shipping_option_price_type_enum")]
pub enum ShippingOptionPriceTypeEnum {
	#[sea_orm(string_value = "calculated")]
	Calculated,
	#[sea_orm(string_value = "flat_rate")]
	FlatRate,
}
impl ShippingOptionPriceTypeEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(ShippingOptionPriceTypeEnum::Calculated),
			1 => Ok(ShippingOptionPriceTypeEnum::FlatRate),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: ShippingOptionPriceTypeEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			ShippingOptionPriceTypeEnum::Calculated => 0,
			ShippingOptionPriceTypeEnum::FlatRate => 1,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(
	rs_type = "String",
	db_type = "Enum",
	enum_name = "shipping_option_requirement_type_enum"
)]
pub enum ShippingOptionRequirementTypeEnum {
	#[sea_orm(string_value = "max_subtotal")]
	MaxSubtotal,
	#[sea_orm(string_value = "min_subtotal")]
	MinSubtotal,
}
impl ShippingOptionRequirementTypeEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(ShippingOptionRequirementTypeEnum::MaxSubtotal),
			1 => Ok(ShippingOptionRequirementTypeEnum::MinSubtotal),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: ShippingOptionRequirementTypeEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			ShippingOptionRequirementTypeEnum::MaxSubtotal => 0,
			ShippingOptionRequirementTypeEnum::MinSubtotal => 1,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "shipping_profile_type_enum")]
pub enum ShippingProfileTypeEnum {
	#[sea_orm(string_value = "custom")]
	Custom,
	#[sea_orm(string_value = "default")]
	Default,
	#[sea_orm(string_value = "gift_card")]
	GiftCard,
}
impl ShippingProfileTypeEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(ShippingProfileTypeEnum::Custom),
			1 => Ok(ShippingProfileTypeEnum::Default),
			2 => Ok(ShippingProfileTypeEnum::GiftCard),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: ShippingProfileTypeEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			ShippingProfileTypeEnum::Custom => 0,
			ShippingProfileTypeEnum::Default => 1,
			ShippingProfileTypeEnum::GiftCard => 2,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "swap_fulfillment_status_enum")]
pub enum SwapFulfillmentStatusEnum {
	#[sea_orm(string_value = "canceled")]
	Canceled,
	#[sea_orm(string_value = "fulfilled")]
	Fulfilled,
	#[sea_orm(string_value = "not_fulfilled")]
	NotFulfilled,
	#[sea_orm(string_value = "partially_shipped")]
	PartiallyShipped,
	#[sea_orm(string_value = "requires_action")]
	RequiresAction,
	#[sea_orm(string_value = "shipped")]
	Shipped,
}
impl SwapFulfillmentStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(SwapFulfillmentStatusEnum::Canceled),
			1 => Ok(SwapFulfillmentStatusEnum::Fulfilled),
			2 => Ok(SwapFulfillmentStatusEnum::NotFulfilled),
			3 => Ok(SwapFulfillmentStatusEnum::PartiallyShipped),
			4 => Ok(SwapFulfillmentStatusEnum::RequiresAction),
			5 => Ok(SwapFulfillmentStatusEnum::Shipped),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: SwapFulfillmentStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			SwapFulfillmentStatusEnum::Canceled => 0,
			SwapFulfillmentStatusEnum::Fulfilled => 1,
			SwapFulfillmentStatusEnum::NotFulfilled => 2,
			SwapFulfillmentStatusEnum::PartiallyShipped => 3,
			SwapFulfillmentStatusEnum::RequiresAction => 4,
			SwapFulfillmentStatusEnum::Shipped => 5,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "swap_payment_status_enum")]
pub enum SwapPaymentStatusEnum {
	#[sea_orm(string_value = "awaiting")]
	Awaiting,
	#[sea_orm(string_value = "canceled")]
	Canceled,
	#[sea_orm(string_value = "captured")]
	Captured,
	#[sea_orm(string_value = "confirmed")]
	Confirmed,
	#[sea_orm(string_value = "difference_refunded")]
	DifferenceRefunded,
	#[sea_orm(string_value = "not_paid")]
	NotPaid,
	#[sea_orm(string_value = "partially_refunded")]
	PartiallyRefunded,
	#[sea_orm(string_value = "refunded")]
	Refunded,
	#[sea_orm(string_value = "requires_action")]
	RequiresAction,
}
impl SwapPaymentStatusEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(SwapPaymentStatusEnum::Awaiting),
			1 => Ok(SwapPaymentStatusEnum::Canceled),
			2 => Ok(SwapPaymentStatusEnum::Captured),
			3 => Ok(SwapPaymentStatusEnum::Confirmed),
			4 => Ok(SwapPaymentStatusEnum::DifferenceRefunded),
			5 => Ok(SwapPaymentStatusEnum::NotPaid),
			6 => Ok(SwapPaymentStatusEnum::PartiallyRefunded),
			7 => Ok(SwapPaymentStatusEnum::Refunded),
			8 => Ok(SwapPaymentStatusEnum::RequiresAction),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: SwapPaymentStatusEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			SwapPaymentStatusEnum::Awaiting => 0,
			SwapPaymentStatusEnum::Canceled => 1,
			SwapPaymentStatusEnum::Captured => 2,
			SwapPaymentStatusEnum::Confirmed => 3,
			SwapPaymentStatusEnum::DifferenceRefunded => 4,
			SwapPaymentStatusEnum::NotPaid => 5,
			SwapPaymentStatusEnum::PartiallyRefunded => 6,
			SwapPaymentStatusEnum::Refunded => 7,
			SwapPaymentStatusEnum::RequiresAction => 8,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "user_role_enum")]
pub enum UserRoleEnum {
	#[sea_orm(string_value = "admin")]
	Admin,
	#[sea_orm(string_value = "developer")]
	Developer,
	#[sea_orm(string_value = "member")]
	Member,
}
impl UserRoleEnum {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(UserRoleEnum::Admin),
			1 => Ok(UserRoleEnum::Developer),
			2 => Ok(UserRoleEnum::Member),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: UserRoleEnum")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			UserRoleEnum::Admin => 0,
			UserRoleEnum::Developer => 1,
			UserRoleEnum::Member => 2,
		}
	}
}
