//! `SeaORM` Entity, @generated by sea-orm-codegen 0.1.0

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "evaluator_type")]
pub enum EvaluatorType {
	#[sea_orm(string_value = "GRAALJS")]
	Graaljs,
	#[sea_orm(string_value = "VALUE_PARAM")]
	ValueParam,
}
impl EvaluatorType {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(EvaluatorType::Graaljs),
			1 => Ok(EvaluatorType::ValueParam),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: EvaluatorType")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			EvaluatorType::Graaljs => 0,
			EvaluatorType::ValueParam => 1,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "fork_type")]
pub enum ForkType {
	#[sea_orm(string_value = "DIFFERENT_TASK")]
	DifferentTask,
	#[sea_orm(string_value = "SAME_TASK")]
	SameTask,
	#[sea_orm(string_value = "SAME_TASK_SUB_WORKFLOW")]
	SameTaskSubWorkflow,
}
impl ForkType {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(ForkType::DifferentTask),
			1 => Ok(ForkType::SameTask),
			2 => Ok(ForkType::SameTaskSubWorkflow),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: ForkType")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			ForkType::DifferentTask => 0,
			ForkType::SameTask => 1,
			ForkType::SameTaskSubWorkflow => 2,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "idempotency_strategy")]
pub enum IdempotencyStrategy {
	#[sea_orm(string_value = "FAIL")]
	Fail,
	#[sea_orm(string_value = "RUNNING_EXISTING")]
	RunningExisting,
}
impl IdempotencyStrategy {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(IdempotencyStrategy::Fail),
			1 => Ok(IdempotencyStrategy::RunningExisting),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: IdempotencyStrategy")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			IdempotencyStrategy::Fail => 0,
			IdempotencyStrategy::RunningExisting => 1,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "operation_type")]
pub enum OperationType {
	#[sea_orm(string_value = "DELETE")]
	Delete,
	#[sea_orm(string_value = "INSERT")]
	Insert,
	#[sea_orm(string_value = "SELECT")]
	Select,
	#[sea_orm(string_value = "Update")]
	Update,
}
impl OperationType {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(OperationType::Delete),
			1 => Ok(OperationType::Insert),
			2 => Ok(OperationType::Select),
			3 => Ok(OperationType::Update),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: OperationType")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			OperationType::Delete => 0,
			OperationType::Insert => 1,
			OperationType::Select => 2,
			OperationType::Update => 3,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "retry_logic")]
pub enum RetryLogic {
	#[sea_orm(string_value = "EXPONENTIAL_BACKOFF")]
	ExponentialBackoff,
	#[sea_orm(string_value = "FIXED")]
	Fixed,
	#[sea_orm(string_value = "LINEAR_BACKOFF")]
	LinearBackoff,
}
impl RetryLogic {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(RetryLogic::ExponentialBackoff),
			1 => Ok(RetryLogic::Fixed),
			2 => Ok(RetryLogic::LinearBackoff),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: RetryLogic")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			RetryLogic::ExponentialBackoff => 0,
			RetryLogic::Fixed => 1,
			RetryLogic::LinearBackoff => 2,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "task_status")]
pub enum TaskStatus {
	#[sea_orm(string_value = "CANCELED")]
	Canceled,
	#[sea_orm(string_value = "COMPLETED")]
	Completed,
	#[sea_orm(string_value = "COMPLETED_WITH_ERRORS")]
	CompletedWithErrors,
	#[sea_orm(string_value = "FAILED")]
	Failed,
	#[sea_orm(string_value = "FAILED_WITH_TERMINAL_ERROR")]
	FailedWithTerminalError,
	#[sea_orm(string_value = "IN_PROGRESS")]
	InProgress,
	#[sea_orm(string_value = "SCHEDULED")]
	Scheduled,
	#[sea_orm(string_value = "SKIPPED")]
	Skipped,
	#[sea_orm(string_value = "TIMED_OUT")]
	TimedOut,
}
impl TaskStatus {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(TaskStatus::Canceled),
			1 => Ok(TaskStatus::Completed),
			2 => Ok(TaskStatus::CompletedWithErrors),
			3 => Ok(TaskStatus::Failed),
			4 => Ok(TaskStatus::FailedWithTerminalError),
			5 => Ok(TaskStatus::InProgress),
			6 => Ok(TaskStatus::Scheduled),
			7 => Ok(TaskStatus::Skipped),
			8 => Ok(TaskStatus::TimedOut),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: TaskStatus")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			TaskStatus::Canceled => 0,
			TaskStatus::Completed => 1,
			TaskStatus::CompletedWithErrors => 2,
			TaskStatus::Failed => 3,
			TaskStatus::FailedWithTerminalError => 4,
			TaskStatus::InProgress => 5,
			TaskStatus::Scheduled => 6,
			TaskStatus::Skipped => 7,
			TaskStatus::TimedOut => 8,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "task_termination_status")]
pub enum TaskTerminationStatus {
	#[sea_orm(string_value = "COMPLETED")]
	Completed,
	#[sea_orm(string_value = "FAILED")]
	Failed,
	#[sea_orm(string_value = "TERMINATED")]
	Terminated,
}
impl TaskTerminationStatus {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(TaskTerminationStatus::Completed),
			1 => Ok(TaskTerminationStatus::Failed),
			2 => Ok(TaskTerminationStatus::Terminated),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: TaskTerminationStatus")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			TaskTerminationStatus::Completed => 0,
			TaskTerminationStatus::Failed => 1,
			TaskTerminationStatus::Terminated => 2,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "task_type")]
pub enum TaskType {
	#[sea_orm(string_value = "BUISSNESS_RULE")]
	BuissnessRule,
	#[sea_orm(string_value = "DO_WHILE")]
	DoWhile,
	#[sea_orm(string_value = "DYNAMIC")]
	Dynamic,
	#[sea_orm(string_value = "EVENT")]
	Event,
	#[sea_orm(string_value = "EXCLUSIVE_JOIN")]
	ExclusiveJoin,
	#[sea_orm(string_value = "FORK_JOIN")]
	ForkJoin,
	#[sea_orm(string_value = "FORK_JOIN_DYNAMIC")]
	ForkJoinDynamic,
	#[sea_orm(string_value = "GET_SIGNED_JWT")]
	GetSignedJwt,
	#[sea_orm(string_value = "HTTP")]
	Http,
	#[sea_orm(string_value = "HUMAN")]
	Human,
	#[sea_orm(string_value = "INLINE")]
	Inline,
	#[sea_orm(string_value = "JOIN")]
	Join,
	#[sea_orm(string_value = "JSON_JQ_TRANSFORM")]
	JsonJqTransform,
	#[sea_orm(string_value = "KAFKA_PUBLISH")]
	KafkaPublish,
	#[sea_orm(string_value = "SET_VARIABLE")]
	SetVariable,
	#[sea_orm(string_value = "SIMPLE")]
	Simple,
	#[sea_orm(string_value = "SQL_TASK")]
	SqlTask,
	#[sea_orm(string_value = "START_WORKFLOW")]
	StartWorkflow,
	#[sea_orm(string_value = "SUB_WORKFLOW")]
	SubWorkflow,
	#[sea_orm(string_value = "SWITCH")]
	Switch,
	#[sea_orm(string_value = "TERMINATE_TASK")]
	TerminateTask,
	#[sea_orm(string_value = "TERMINATE_WORKFLOW")]
	TerminateWorkflow,
	#[sea_orm(string_value = "UPDATE_SECRET")]
	UpdateSecret,
	#[sea_orm(string_value = "UPDATE_TASK")]
	UpdateTask,
	#[sea_orm(string_value = "USER_DEFINED")]
	UserDefined,
	#[sea_orm(string_value = "WAIT")]
	Wait,
	#[sea_orm(string_value = "WAIT_FOR_WEBHOOK")]
	WaitForWebhook,
}
impl TaskType {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(TaskType::BuissnessRule),
			1 => Ok(TaskType::DoWhile),
			2 => Ok(TaskType::Dynamic),
			3 => Ok(TaskType::Event),
			4 => Ok(TaskType::ExclusiveJoin),
			5 => Ok(TaskType::ForkJoin),
			6 => Ok(TaskType::ForkJoinDynamic),
			7 => Ok(TaskType::GetSignedJwt),
			8 => Ok(TaskType::Http),
			9 => Ok(TaskType::Human),
			10 => Ok(TaskType::Inline),
			11 => Ok(TaskType::Join),
			12 => Ok(TaskType::JsonJqTransform),
			13 => Ok(TaskType::KafkaPublish),
			14 => Ok(TaskType::SetVariable),
			15 => Ok(TaskType::Simple),
			16 => Ok(TaskType::SqlTask),
			17 => Ok(TaskType::StartWorkflow),
			18 => Ok(TaskType::SubWorkflow),
			19 => Ok(TaskType::Switch),
			20 => Ok(TaskType::TerminateTask),
			21 => Ok(TaskType::TerminateWorkflow),
			22 => Ok(TaskType::UpdateSecret),
			23 => Ok(TaskType::UpdateTask),
			24 => Ok(TaskType::UserDefined),
			25 => Ok(TaskType::Wait),
			26 => Ok(TaskType::WaitForWebhook),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: TaskType")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			TaskType::BuissnessRule => 0,
			TaskType::DoWhile => 1,
			TaskType::Dynamic => 2,
			TaskType::Event => 3,
			TaskType::ExclusiveJoin => 4,
			TaskType::ForkJoin => 5,
			TaskType::ForkJoinDynamic => 6,
			TaskType::GetSignedJwt => 7,
			TaskType::Http => 8,
			TaskType::Human => 9,
			TaskType::Inline => 10,
			TaskType::Join => 11,
			TaskType::JsonJqTransform => 12,
			TaskType::KafkaPublish => 13,
			TaskType::SetVariable => 14,
			TaskType::Simple => 15,
			TaskType::SqlTask => 16,
			TaskType::StartWorkflow => 17,
			TaskType::SubWorkflow => 18,
			TaskType::Switch => 19,
			TaskType::TerminateTask => 20,
			TaskType::TerminateWorkflow => 21,
			TaskType::UpdateSecret => 22,
			TaskType::UpdateTask => 23,
			TaskType::UserDefined => 24,
			TaskType::Wait => 25,
			TaskType::WaitForWebhook => 26,
		}
	}
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "timeout_policy")]
pub enum TimeoutPolicy {
	#[sea_orm(string_value = "ALERT_ONLY")]
	AlertOnly,
	#[sea_orm(string_value = "RETRY")]
	Retry,
	#[sea_orm(string_value = "TIMED_OUT_WF")]
	TimedOutWf,
}
impl TimeoutPolicy {
	pub fn from_i32(value: i32) -> Result<Self, actix_web::HttpResponse> {
		match value {
			0 => Ok(TimeoutPolicy::AlertOnly),
			1 => Ok(TimeoutPolicy::Retry),
			2 => Ok(TimeoutPolicy::TimedOutWf),
			_ => Err(actix_web::HttpResponse::InternalServerError()
				.body("Failed to parse enum: TimeoutPolicy")),
		}
	}
	pub fn to_i32(&self) -> i32 {
		match self {
			TimeoutPolicy::AlertOnly => 0,
			TimeoutPolicy::Retry => 1,
			TimeoutPolicy::TimedOutWf => 2,
		}
	}
}
