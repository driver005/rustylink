//! `SeaORM` Entity, @generated by sea-orm-codegen 0.1.0

use crate::handles::entities::*;
use ::apy::{Builder, BuilderContext};
use ::dynamic::prelude::{GraphQLSchemaError, Proto, ProtoSchemaError, Schema};
use sea_orm::DatabaseConnection;
lazy_static::lazy_static! { static ref CONTEXT : BuilderContext = BuilderContext :: default () ; }
fn builder(database: &DatabaseConnection) -> Builder {
	let mut builder = Builder::new(&CONTEXT, database.clone());
	apy::register_entities!(
		builder,
		[
			buissness_rule,
			do_while,
			dynamic,
			dynamic_fork,
			event,
			fork,
			get_signed_jwt,
			get_workflow,
			http,
			human,
			inline,
			join,
			json_transform,
			poll_data,
			set_variable,
			simple,
			sql,
			start_workflow,
			sub_workflow,
			switch,
			task_config,
			task_definition,
			task_execution_log,
			task_model,
			terminate_task,
			terminate_workflow,
			update_secret,
			update_task,
			wait,
			wait_for_webhook,
		]
	);
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::EvaluatorType>();
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::ForkType>();
	builder
		.register_enumeration::<crate::handles::entities::sea_orm_active_enums::IdempotencyStrategy>(
		);
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::OperationType>();
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::RetryLogic>();
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::TaskStatus>();
	builder
		.register_enumeration::<crate::handles::entities::sea_orm_active_enums::TaskTerminationStatus>(
		);
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::TaskType>();
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::TimeoutPolicy>();
	builder
}
pub fn schema(
	database: &DatabaseConnection,
	depth: Option<usize>,
	complexity: Option<usize>,
) -> Result<Schema, GraphQLSchemaError> {
	let builder = builder(database);
	let schema = builder.schema_builder();
	let schema = if let Some(depth) = depth {
		schema.limit_depth(depth)
	} else {
		schema
	};
	let schema = if let Some(complexity) = complexity {
		schema.limit_complexity(complexity)
	} else {
		schema
	};
	schema.data(database.clone()).finish()
}
pub fn proto(database: &DatabaseConnection) -> Result<Proto, ProtoSchemaError> {
	let builder = builder(database);
	let proto = builder.proto_builder();
	proto.data(database.clone()).finish()
}
