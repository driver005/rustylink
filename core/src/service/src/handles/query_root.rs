//! `SeaORM` Entity, @generated by sea-orm-codegen 0.1.0

use crate::handles::entities::*;
use ::apy::{
	Builder, BuilderContext, FilterTypeTrait, GraphQlFilterType, ProtoFilterType, QueryRoot,
};
use ::dynamic::prelude::{
	DynamicBuilder, EnumTrait, GraphQLEnum, GraphQLTypeRef, Proto as DynamicProto, ProtoEnum,
	ProtoTypeRef, Schema as DynamicSchema, SchemaError, TypeRefTrait,
};
use sea_orm::DatabaseConnection;
lazy_static::lazy_static! { static ref CONTEXT : BuilderContext = BuilderContext :: default () ; }
fn builder<T, E, F>(database: &DatabaseConnection) -> DynamicBuilder<T, E>
where
	T: TypeRefTrait,
	E: EnumTrait,
	F: FilterTypeTrait,
{
	let mut builder = Builder::<T, E, F>::new(&CONTEXT, database.clone());
	apy::register_entities!(builder, [netflix_shows,], T, F);
	builder.builder()
}
pub struct Schema {
	depth: Option<u16>,
	complexity: Option<u16>,
}
impl Schema {
	pub fn new() -> Self {
		Self {
			depth: None,
			complexity: None,
		}
	}
}
impl QueryRoot<DynamicSchema> for Schema {
	fn config_schema(&mut self, depth: u16, complexity: u16) {
		self.depth = Some(depth);
		self.complexity = Some(complexity);
	}
	fn root(&self, database: &DatabaseConnection) -> Result<DynamicSchema, SchemaError> {
		let builder = builder::<GraphQLTypeRef, GraphQLEnum, GraphQlFilterType>(database);
		let schema = builder.builder();
		let schema = if let Some(depth) = self.depth {
			schema.limit_depth(depth)
		} else {
			schema
		};
		let schema = if let Some(complexity) = self.complexity {
			schema.limit_complexity(complexity)
		} else {
			schema
		};
		schema.data(database.clone()).finish()
	}
}
pub struct Proto {}
impl Proto {
	pub fn new() -> Self {
		Self {}
	}
}
impl QueryRoot<DynamicProto> for Proto {
	fn root(&self, database: &DatabaseConnection) -> Result<DynamicProto, SchemaError> {
		let builder = builder::<ProtoTypeRef, ProtoEnum, ProtoFilterType>(database);
		let proto = builder.builder();
		proto.data(database.clone()).finish()
	}
}
