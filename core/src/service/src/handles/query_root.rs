//! `SeaORM` Entity, @generated by sea-orm-codegen 0.1.0

use crate::handles::entities::*;
use ::apy::{Builder, BuilderContext, FilterTypeTrait, GraphQlFilterType, ProtoFilterType};
use ::dynamic::prelude::{
	DynamicBuilder, EnumTrait, GraphQLEnum, GraphQLTypeRef, Proto, ProtoEnum, ProtoTypeRef, Schema,
	SchemaError, TypeRefTrait,
};
use sea_orm::DatabaseConnection;
lazy_static::lazy_static! { static ref CONTEXT : BuilderContext = BuilderContext :: default () ; }
fn builder<T, E, F>(database: &DatabaseConnection) -> DynamicBuilder<T, E>
where
	T: TypeRefTrait,
	E: EnumTrait,
	F: FilterTypeTrait,
{
	let mut builder = Builder::<T, E, F>::new(&CONTEXT, database.clone());
	apy::register_entities!(
		builder,
		[
			buissness_rule,
			do_while,
			dynamic,
			dynamic_fork,
			event,
			fork,
			get_signed_jwt,
			get_workflow,
			http,
			human,
			inline,
			join,
			json_transform,
			poll_data,
			set_variable,
			simple,
			sql,
			start_workflow,
			sub_workflow,
			switch,
			task_config,
			task_definition,
			task_execution_log,
			task_model,
			terminate_task,
			terminate_workflow,
			update_secret,
			update_task,
			wait,
			wait_for_webhook,
		],
		T,
		F
	);
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::EvaluatorType>();
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::ForkType>();
	builder
		.register_enumeration::<crate::handles::entities::sea_orm_active_enums::IdempotencyStrategy>(
		);
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::OperationType>();
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::RetryLogic>();
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::TaskStatus>();
	builder
		.register_enumeration::<crate::handles::entities::sea_orm_active_enums::TaskTerminationStatus>(
		);
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::TaskType>();
	builder.register_enumeration::<crate::handles::entities::sea_orm_active_enums::TimeoutPolicy>();
	builder.builder()
}
pub fn schema(
	database: &DatabaseConnection,
	depth: Option<usize>,
	complexity: Option<usize>,
) -> Result<Schema, SchemaError> {
	let builder = builder::<GraphQLTypeRef, GraphQLEnum, GraphQlFilterType>(database);
	let schema = builder.builder();
	let schema = if let Some(depth) = depth {
		schema.limit_depth(depth)
	} else {
		schema
	};
	let schema = if let Some(complexity) = complexity {
		schema.limit_complexity(complexity)
	} else {
		schema
	};
	schema.data(database.clone()).finish()
}
pub fn proto(database: &DatabaseConnection) -> Result<Proto, SchemaError> {
	let builder = builder::<ProtoTypeRef, ProtoEnum, ProtoFilterType>(database);
	let proto = builder.builder();
	proto.data(database.clone()).finish()
}
