use std::borrow::Cow;
use std::collections::BTreeMap;
use std::convert::Infallible;
use std::sync::Arc;
use std::task::{Context, Poll};

use bytes::{Buf, BufMut, Bytes, BytesMut, buf};
use once_cell::sync::Lazy;
use ordered_float::OrderedFloat;
use prost::{
	DecodeError, EncodeError, Message,
	encoding::{DecodeContext, WireType, decode_varint},
};
use tonic::codec::{CompressionEncoding, EnabledCompressionEncodings};
use tonic::server::{Grpc, NamedService};

use tonic::codegen::{
	Body, BoxFuture, Service, StdError,
	http::{Request, Response},
};

use super::{PCKNAME, TYPE_REGISTRY, Type};
use crate::{ApiType, Data, ObjectAccessor, Value};

#[derive(Clone, PartialEq, prost::Message)]
pub struct VotingResponse {
	#[prost(message, optional, tag = "1")]
	pub confirmation: Option<i32>,
}

// This file is @generated by prost-build.
#[derive(Clone, PartialEq, prost::Message)]
pub struct VotingRequest {
	#[prost(string, tag = "1")]
	pub url: String,

	#[prost(string, repeated, tag = "2")]
	pub test: Vec<String>,
}

#[derive(Debug)]
pub struct BytesRequestInner {
	bytes: Bytes,
	tag: u32,
	wire_type: WireType,
	ctx: DecodeContext,
}

#[derive(Debug)]
pub struct BytesRequest {
	bytes: Bytes,
	tag: u32,
	wire_type: WireType,
	ctx: DecodeContext,
}

// Implement Message trait for BytesRequest
impl Message for BytesRequest {
	fn encode_raw(&self, _buf: &mut impl BufMut)
	where
		Self: Sized,
	{
		panic!("BytesRequest can only be used as an incoming request not as an response")
	}

	fn merge_field(
		&mut self,
		tag: u32,
		wire_type: WireType,
		buf: &mut impl Buf,
		ctx: DecodeContext,
	) -> Result<(), DecodeError>
	where
		Self: Sized,
	{
		self.bytes = buf.copy_to_bytes(buf.remaining());
		self.tag = tag;
		self.wire_type = wire_type;
		self.ctx = ctx;
		Ok(())
	}

	fn encoded_len(&self) -> usize {
		panic!("BytesRequest can only be used as an incoming request not as an response")
	}

	fn clear(&mut self) {
		self.bytes = Bytes::new();
	}
}

impl Default for BytesRequest {
	fn default() -> Self {
		Self {
			bytes: Bytes::new(),
			tag: 0,
			wire_type: WireType::Varint,
			ctx: DecodeContext::default(),
		}
	}
}

#[derive(Debug)]
pub struct BytesResponce {
	bytes: Bytes,
	size: usize,
}

// Implement Message trait for BytesRequest
impl Message for BytesResponce {
	fn encode_raw(&self, buf: &mut impl BufMut)
	where
		Self: Sized,
	{
		buf.put_slice(&self.bytes[..]);
	}

	fn merge_field(
		&mut self,
		_tag: u32,
		_wire_type: WireType,
		_buf: &mut impl Buf,
		_ctx: DecodeContext,
	) -> Result<(), DecodeError>
	where
		Self: Sized,
	{
		panic!("BytesResponce can only be used as an outgonig response not as an response")
	}

	fn encoded_len(&self) -> usize {
		self.size
	}

	fn clear(&mut self) {
		self.bytes = Bytes::new();
		self.size = 0;
	}
}

impl Default for BytesResponce {
	fn default() -> Self {
		Self {
			bytes: Bytes::new(),
			size: 0,
		}
	}
}

struct Svc<'a> {
	service_name: &'a str,
	name: &'a str,
	data: Arc<Data>,
}

impl<'a> tonic::server::UnaryService<BytesRequest> for Svc<'a> {
	type Response = BytesResponce;
	type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
	fn call(&mut self, request: tonic::Request<BytesRequest>) -> Self::Future {
		let service = match TYPE_REGISTRY.get(&self.service_name) {
			Some(ser) => ser,
			None => panic!("Type not found"),
		};

		let mut req = request.into_inner();
		let mut arguments = BTreeMap::new();

		let mut index = 1;
		while req.bytes.has_remaining() {
			service
				.decode(
					&self.name,
					index,
					&mut req.bytes,
					req.wire_type,
					req.ctx.clone(),
					&mut arguments,
				)
				.unwrap();

			if !req.bytes.is_empty() {
				req.bytes.advance(1usize);
			}
			index += 1;
		}

		let accessor = ObjectAccessor(Cow::Owned(arguments));

		let name = self.name.to_owned();
		let mut ctx = crate::ContextBase::new(ApiType::Proto);

		ctx.execute_data = Some(self.data.clone());

		Box::pin(async move {
			let (size, buf) = service.encode(&ctx, &accessor, name.as_str()).await.unwrap();

			Ok(tonic::Response::new(BytesResponce {
				bytes: buf.into(),
				size,
			}))
		})

		// println!("res: {:#?}", res.0);
		// println!("val: {:#?}", res.1);

		// let encoder = Encoder::default();
		// let mut output = Vec::new();
		// field.encode(0u32, &encoder, &mut output, res.1)?;
		// Ok(Bytes::from(output))

		// Box::pin(async move { Ok(tonic::Response::new(Bytes::from_static(b"Hello, World"))) })
	}
}

struct Handler {
	accept_compression_encodings: EnabledCompressionEncodings,
	send_compression_encodings: EnabledCompressionEncodings,
	max_decoding_message_size: Option<usize>,
	max_encoding_message_size: Option<usize>,
}
impl Handler {
	pub fn new() -> Self {
		Self {
			accept_compression_encodings: EnabledCompressionEncodings::default(),
			send_compression_encodings: EnabledCompressionEncodings::default(),
			max_decoding_message_size: None,
			max_encoding_message_size: None,
		}
	}

	/// Enable decompressing requests with the given encoding.
	#[must_use]
	pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
		self.accept_compression_encodings.enable(encoding);
		self
	}
	/// Compress responses with the given encoding, if the client supports it.
	#[must_use]
	pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
		self.send_compression_encodings.enable(encoding);
		self
	}
	/// Limits the maximum size of a decoded message.
	///
	/// Default: `4MB`
	#[must_use]
	pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
		self.max_decoding_message_size = Some(limit);
		self
	}
	/// Limits the maximum size of an encoded message.
	///
	/// Default: `usize::MAX`
	#[must_use]
	pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
		self.max_encoding_message_size = Some(limit);
		self
	}

	fn call<B>(
		&self,
		req: Request<B>,
		data: Arc<Data>,
	) -> BoxFuture<Response<tonic::body::Body>, Infallible>
	where
		B: Body + std::marker::Send + std::fmt::Debug + 'static,
		B::Error: Into<StdError> + std::marker::Send + 'static,
	{
		let path = req.uri().path().to_string();

		let accept_compression_encodings = self.accept_compression_encodings;
		let send_compression_encodings = self.send_compression_encodings;
		let max_decoding_message_size = self.max_decoding_message_size;
		let max_encoding_message_size = self.max_encoding_message_size;

		Box::pin(async move {
			if let Some(name) = path.split('/').last() {
				let codec = tonic::codec::ProstCodec::default();
				let mut grpc = tonic::server::Grpc::new(codec)
					.apply_compression_config(
						accept_compression_encodings,
						send_compression_encodings,
					)
					.apply_max_message_size_config(
						max_decoding_message_size,
						max_encoding_message_size,
					);

				let method = Svc {
					service_name: "Query",
					name,
					data,
				};
				let res = grpc.unary(method, req).await;
				println!("res: {:#?}", res.body());
				Ok(res)
			} else {
				// let status = tonic::Status::invalid_argument("wrong url");
				let res = Response::builder().body(tonic::body::Body::empty()).unwrap();
				Ok(res)
			}
		})
	}
}

#[derive(Clone)]
pub struct WrapperQuery {
	data: Arc<Data>,
}

impl WrapperQuery {
	pub fn new(data: Arc<Data>) -> Self {
		Self {
			data,
		}
	}
}

impl NamedService for WrapperQuery {
	//#![feature(const_vec_string_slice)]
	//const NAME: &'static str = format!("{}.Query", PCKNAME).as_str();
	const NAME: &'static str = "apy.Query";
}

impl<B> Service<Request<B>> for WrapperQuery
where
	B: Body + std::marker::Send + std::fmt::Debug + 'static,
	B::Error: Into<StdError> + std::marker::Send + 'static,
{
	type Response = Response<tonic::body::Body>;
	type Error = Infallible;
	type Future = BoxFuture<Self::Response, Self::Error>;

	fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
		Poll::Ready(Ok(()))
	}

	fn call(&mut self, req: Request<B>) -> Self::Future {
		Handler::new().call(req, self.data.clone())
	}
}

#[derive(Clone)]
pub struct WrapperMutation {
	data: Arc<Data>,
}

impl WrapperMutation {
	pub fn new(data: Arc<Data>) -> Self {
		Self {
			data,
		}
	}
}

impl NamedService for WrapperMutation {
	//#![feature(const_vec_string_slice)]
	//const NAME: &'static str = format!("{}.Mutation", PCKNAME).as_str();
	const NAME: &'static str = "apy.Mutation";
}

impl<B> Service<Request<B>> for WrapperMutation
where
	B: Body + std::marker::Send + std::fmt::Debug + 'static,
	B::Error: Into<StdError> + std::marker::Send + 'static,
{
	type Response = Response<tonic::body::Body>;
	type Error = Infallible;
	type Future = BoxFuture<Self::Response, Self::Error>;

	fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
		Poll::Ready(Ok(()))
	}

	fn call(&mut self, req: Request<B>) -> Self::Future {
		Handler::new().call(req, self.data.clone())
	}
}
