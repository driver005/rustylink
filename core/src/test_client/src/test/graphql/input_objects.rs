// DO NOT EDIT THIS FILE
// This file was generated by https://github.com/tacogips/async-graphql-reverse

use super::enums::EvaluatorTypeEnum;
use super::enums::ForkTypeEnum;
use super::enums::IdempotencyStrategyEnum;
use super::enums::OperationTypeEnum;
use super::enums::OrderByEnum;
use super::enums::RetryLogicEnum;
use super::enums::TaskStatusEnum;
use super::enums::TaskTerminationStatusEnum;
use super::enums::TaskTypeEnum;
use super::enums::TimeoutPolicyEnum;
use sdk::prelude::*;
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BooleanFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<bool>,
	#[serde(rename = "ne")]
	pub ne: Option<bool>,
	#[serde(rename = "gt")]
	pub gt: Option<bool>,
	#[serde(rename = "gte")]
	pub gte: Option<bool>,
	#[serde(rename = "lt")]
	pub lt: Option<bool>,
	#[serde(rename = "lte")]
	pub lte: Option<bool>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<bool>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<bool>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<bool>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<bool>,
}
impl BooleanFilterInput {
	pub fn set_eq(mut self, eq: bool) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: bool) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: bool) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: bool) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: bool) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: bool) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<bool>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<bool>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: bool) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: bool) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BuissnessRuleFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "ruleFileLocation")]
	pub rule_file_location: Option<StringFilterInput>,
	#[serde(rename = "executionStrategy")]
	pub execution_strategy: Option<StringFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<BuissnessRuleFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<BuissnessRuleFilterInput>>>,
}
impl BuissnessRuleFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_rule_file_location(mut self, rule_file_location: StringFilterInput) -> Self {
		self.rule_file_location = Some(rule_file_location);
		self
	}
	pub fn set_execution_strategy(mut self, execution_strategy: StringFilterInput) -> Self {
		self.execution_strategy = Some(execution_strategy);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<BuissnessRuleFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<BuissnessRuleFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(rule_file_location) = &self.rule_file_location {
			query.push(SelectionSet {
				operation: "ruleFileLocation",
				alias: None,
				fields: Some(rule_file_location.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(execution_strategy) = &self.execution_strategy {
			query.push(SelectionSet {
				operation: "executionStrategy",
				alias: None,
				fields: Some(execution_strategy.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BuissnessRuleInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "ruleFileLocation")]
	pub rule_file_location: String,
	#[serde(rename = "executionStrategy")]
	pub execution_strategy: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl BuissnessRuleInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_rule_file_location(mut self, rule_file_location: String) -> Self {
		self.rule_file_location = rule_file_location;
		self
	}
	pub fn set_execution_strategy(mut self, execution_strategy: String) -> Self {
		self.execution_strategy = execution_strategy;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "ruleFileLocation",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "executionStrategy",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BuissnessRuleOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "ruleFileLocation")]
	pub rule_file_location: Option<OrderByEnum>,
	#[serde(rename = "executionStrategy")]
	pub execution_strategy: Option<OrderByEnum>,
	#[serde(rename = "inputColumn")]
	pub input_column: Option<OrderByEnum>,
	#[serde(rename = "outputColumn")]
	pub output_column: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl BuissnessRuleOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_rule_file_location(mut self, rule_file_location: OrderByEnum) -> Self {
		self.rule_file_location = Some(rule_file_location);
		self
	}
	pub fn set_execution_strategy(mut self, execution_strategy: OrderByEnum) -> Self {
		self.execution_strategy = Some(execution_strategy);
		self
	}
	pub fn set_input_column(mut self, input_column: OrderByEnum) -> Self {
		self.input_column = Some(input_column);
		self
	}
	pub fn set_output_column(mut self, output_column: OrderByEnum) -> Self {
		self.output_column = Some(output_column);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rule_file_location.is_some() {
			query.push(SelectionSet {
				operation: "ruleFileLocation",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.execution_strategy.is_some() {
			query.push(SelectionSet {
				operation: "executionStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.input_column.is_some() {
			query.push(SelectionSet {
				operation: "inputColumn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.output_column.is_some() {
			query.push(SelectionSet {
				operation: "outputColumn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BuissnessRuleUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "ruleFileLocation")]
	pub rule_file_location: Option<String>,
	#[serde(rename = "executionStrategy")]
	pub execution_strategy: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl BuissnessRuleUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_rule_file_location(mut self, rule_file_location: String) -> Self {
		self.rule_file_location = Some(rule_file_location);
		self
	}
	pub fn set_execution_strategy(mut self, execution_strategy: String) -> Self {
		self.execution_strategy = Some(execution_strategy);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rule_file_location.is_some() {
			query.push(SelectionSet {
				operation: "ruleFileLocation",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.execution_strategy.is_some() {
			query.push(SelectionSet {
				operation: "executionStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct CursorInput {
	#[serde(rename = "cursor")]
	pub cursor: Option<String>,
	#[serde(rename = "limit")]
	pub limit: i64,
}
impl CursorInput {
	pub fn set_cursor(mut self, cursor: String) -> Self {
		self.cursor = Some(cursor);
		self
	}
	pub fn set_limit(mut self, limit: i64) -> Self {
		self.limit = limit;
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.cursor.is_some() {
			query.push(SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "limit",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DoWhileFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<EvaluatorTypeEnumFilterInput>,
	#[serde(rename = "loopCondition")]
	pub loop_condition: Option<StringFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<DoWhileFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<DoWhileFilterInput>>>,
}
impl DoWhileFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnumFilterInput) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_loop_condition(mut self, loop_condition: StringFilterInput) -> Self {
		self.loop_condition = Some(loop_condition);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<DoWhileFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<DoWhileFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(evaluator_type) = &self.evaluator_type {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: Some(evaluator_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(loop_condition) = &self.loop_condition {
			query.push(SelectionSet {
				operation: "loopCondition",
				alias: None,
				fields: Some(loop_condition.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DoWhileInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: EvaluatorTypeEnum,
	#[serde(rename = "loopCondition")]
	pub loop_condition: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl DoWhileInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnum) -> Self {
		self.evaluator_type = evaluator_type;
		self
	}
	pub fn set_loop_condition(mut self, loop_condition: String) -> Self {
		self.loop_condition = loop_condition;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "evaluatorType",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "loopCondition",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DoWhileOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<OrderByEnum>,
	#[serde(rename = "loopCondition")]
	pub loop_condition: Option<OrderByEnum>,
	#[serde(rename = "loopOver")]
	pub loop_over: Option<OrderByEnum>,
	#[serde(rename = "taskIds")]
	pub task_ids: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl DoWhileOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: OrderByEnum) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_loop_condition(mut self, loop_condition: OrderByEnum) -> Self {
		self.loop_condition = Some(loop_condition);
		self
	}
	pub fn set_loop_over(mut self, loop_over: OrderByEnum) -> Self {
		self.loop_over = Some(loop_over);
		self
	}
	pub fn set_task_ids(mut self, task_ids: OrderByEnum) -> Self {
		self.task_ids = Some(task_ids);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.evaluator_type.is_some() {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.loop_condition.is_some() {
			query.push(SelectionSet {
				operation: "loopCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.loop_over.is_some() {
			query.push(SelectionSet {
				operation: "loopOver",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_ids.is_some() {
			query.push(SelectionSet {
				operation: "taskIds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DoWhileUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<EvaluatorTypeEnum>,
	#[serde(rename = "loopCondition")]
	pub loop_condition: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl DoWhileUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnum) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_loop_condition(mut self, loop_condition: String) -> Self {
		self.loop_condition = Some(loop_condition);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.evaluator_type.is_some() {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.loop_condition.is_some() {
			query.push(SelectionSet {
				operation: "loopCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "dynamicTaskName")]
	pub dynamic_task_name: Option<StringFilterInput>,
	#[serde(rename = "subWorkflowName")]
	pub sub_workflow_name: Option<StringFilterInput>,
	#[serde(rename = "subWorkflowVersion")]
	pub sub_workflow_version: Option<IntegerFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<DynamicFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<DynamicFilterInput>>>,
}
impl DynamicFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_dynamic_task_name(mut self, dynamic_task_name: StringFilterInput) -> Self {
		self.dynamic_task_name = Some(dynamic_task_name);
		self
	}
	pub fn set_sub_workflow_name(mut self, sub_workflow_name: StringFilterInput) -> Self {
		self.sub_workflow_name = Some(sub_workflow_name);
		self
	}
	pub fn set_sub_workflow_version(mut self, sub_workflow_version: IntegerFilterInput) -> Self {
		self.sub_workflow_version = Some(sub_workflow_version);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<DynamicFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<DynamicFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(dynamic_task_name) = &self.dynamic_task_name {
			query.push(SelectionSet {
				operation: "dynamicTaskName",
				alias: None,
				fields: Some(dynamic_task_name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(sub_workflow_name) = &self.sub_workflow_name {
			query.push(SelectionSet {
				operation: "subWorkflowName",
				alias: None,
				fields: Some(sub_workflow_name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(sub_workflow_version) = &self.sub_workflow_version {
			query.push(SelectionSet {
				operation: "subWorkflowVersion",
				alias: None,
				fields: Some(sub_workflow_version.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicForkFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "forkType")]
	pub fork_type: Option<ForkTypeEnumFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "forkTaskName")]
	pub fork_task_name: Option<StringFilterInput>,
	#[serde(rename = "forkTaskWorkflow")]
	pub fork_task_workflow: Option<StringFilterInput>,
	#[serde(rename = "forkTaskWorkflowVersion")]
	pub fork_task_workflow_version: Option<StringFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<DynamicForkFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<DynamicForkFilterInput>>>,
}
impl DynamicForkFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_fork_type(mut self, fork_type: ForkTypeEnumFilterInput) -> Self {
		self.fork_type = Some(fork_type);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_fork_task_name(mut self, fork_task_name: StringFilterInput) -> Self {
		self.fork_task_name = Some(fork_task_name);
		self
	}
	pub fn set_fork_task_workflow(mut self, fork_task_workflow: StringFilterInput) -> Self {
		self.fork_task_workflow = Some(fork_task_workflow);
		self
	}
	pub fn set_fork_task_workflow_version(
		mut self,
		fork_task_workflow_version: StringFilterInput,
	) -> Self {
		self.fork_task_workflow_version = Some(fork_task_workflow_version);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<DynamicForkFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<DynamicForkFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(fork_type) = &self.fork_type {
			query.push(SelectionSet {
				operation: "forkType",
				alias: None,
				fields: Some(fork_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(fork_task_name) = &self.fork_task_name {
			query.push(SelectionSet {
				operation: "forkTaskName",
				alias: None,
				fields: Some(fork_task_name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(fork_task_workflow) = &self.fork_task_workflow {
			query.push(SelectionSet {
				operation: "forkTaskWorkflow",
				alias: None,
				fields: Some(fork_task_workflow.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(fork_task_workflow_version) = &self.fork_task_workflow_version {
			query.push(SelectionSet {
				operation: "forkTaskWorkflowVersion",
				alias: None,
				fields: Some(fork_task_workflow_version.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicForkInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "forkType")]
	pub fork_type: ForkTypeEnum,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "forkTaskName")]
	pub fork_task_name: Option<String>,
	#[serde(rename = "forkTaskWorkflow")]
	pub fork_task_workflow: Option<String>,
	#[serde(rename = "forkTaskWorkflowVersion")]
	pub fork_task_workflow_version: Option<String>,
}
impl DynamicForkInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_fork_type(mut self, fork_type: ForkTypeEnum) -> Self {
		self.fork_type = fork_type;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_fork_task_name(mut self, fork_task_name: String) -> Self {
		self.fork_task_name = Some(fork_task_name);
		self
	}
	pub fn set_fork_task_workflow(mut self, fork_task_workflow: String) -> Self {
		self.fork_task_workflow = Some(fork_task_workflow);
		self
	}
	pub fn set_fork_task_workflow_version(mut self, fork_task_workflow_version: String) -> Self {
		self.fork_task_workflow_version = Some(fork_task_workflow_version);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "forkType",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_task_name.is_some() {
			query.push(SelectionSet {
				operation: "forkTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_task_workflow.is_some() {
			query.push(SelectionSet {
				operation: "forkTaskWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_task_workflow_version.is_some() {
			query.push(SelectionSet {
				operation: "forkTaskWorkflowVersion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicForkOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "forkType")]
	pub fork_type: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
	#[serde(rename = "taskIds")]
	pub task_ids: Option<OrderByEnum>,
	#[serde(rename = "dynamicForkTasks")]
	pub dynamic_fork_tasks: Option<OrderByEnum>,
	#[serde(rename = "dynamicForkTasksInput")]
	pub dynamic_fork_tasks_input: Option<OrderByEnum>,
	#[serde(rename = "forkTaskName")]
	pub fork_task_name: Option<OrderByEnum>,
	#[serde(rename = "forkTaskInputs")]
	pub fork_task_inputs: Option<OrderByEnum>,
	#[serde(rename = "forkTaskWorkflow")]
	pub fork_task_workflow: Option<OrderByEnum>,
	#[serde(rename = "forkTaskWorkflowVersion")]
	pub fork_task_workflow_version: Option<OrderByEnum>,
}
impl DynamicForkOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_fork_type(mut self, fork_type: OrderByEnum) -> Self {
		self.fork_type = Some(fork_type);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_task_ids(mut self, task_ids: OrderByEnum) -> Self {
		self.task_ids = Some(task_ids);
		self
	}
	pub fn set_dynamic_fork_tasks(mut self, dynamic_fork_tasks: OrderByEnum) -> Self {
		self.dynamic_fork_tasks = Some(dynamic_fork_tasks);
		self
	}
	pub fn set_dynamic_fork_tasks_input(mut self, dynamic_fork_tasks_input: OrderByEnum) -> Self {
		self.dynamic_fork_tasks_input = Some(dynamic_fork_tasks_input);
		self
	}
	pub fn set_fork_task_name(mut self, fork_task_name: OrderByEnum) -> Self {
		self.fork_task_name = Some(fork_task_name);
		self
	}
	pub fn set_fork_task_inputs(mut self, fork_task_inputs: OrderByEnum) -> Self {
		self.fork_task_inputs = Some(fork_task_inputs);
		self
	}
	pub fn set_fork_task_workflow(mut self, fork_task_workflow: OrderByEnum) -> Self {
		self.fork_task_workflow = Some(fork_task_workflow);
		self
	}
	pub fn set_fork_task_workflow_version(
		mut self,
		fork_task_workflow_version: OrderByEnum,
	) -> Self {
		self.fork_task_workflow_version = Some(fork_task_workflow_version);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_type.is_some() {
			query.push(SelectionSet {
				operation: "forkType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_ids.is_some() {
			query.push(SelectionSet {
				operation: "taskIds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_fork_tasks.is_some() {
			query.push(SelectionSet {
				operation: "dynamicForkTasks",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_fork_tasks_input.is_some() {
			query.push(SelectionSet {
				operation: "dynamicForkTasksInput",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_task_name.is_some() {
			query.push(SelectionSet {
				operation: "forkTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_task_inputs.is_some() {
			query.push(SelectionSet {
				operation: "forkTaskInputs",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_task_workflow.is_some() {
			query.push(SelectionSet {
				operation: "forkTaskWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_task_workflow_version.is_some() {
			query.push(SelectionSet {
				operation: "forkTaskWorkflowVersion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicForkUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "forkType")]
	pub fork_type: Option<ForkTypeEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "forkTaskName")]
	pub fork_task_name: Option<String>,
	#[serde(rename = "forkTaskWorkflow")]
	pub fork_task_workflow: Option<String>,
	#[serde(rename = "forkTaskWorkflowVersion")]
	pub fork_task_workflow_version: Option<String>,
}
impl DynamicForkUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_fork_type(mut self, fork_type: ForkTypeEnum) -> Self {
		self.fork_type = Some(fork_type);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_fork_task_name(mut self, fork_task_name: String) -> Self {
		self.fork_task_name = Some(fork_task_name);
		self
	}
	pub fn set_fork_task_workflow(mut self, fork_task_workflow: String) -> Self {
		self.fork_task_workflow = Some(fork_task_workflow);
		self
	}
	pub fn set_fork_task_workflow_version(mut self, fork_task_workflow_version: String) -> Self {
		self.fork_task_workflow_version = Some(fork_task_workflow_version);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_type.is_some() {
			query.push(SelectionSet {
				operation: "forkType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_task_name.is_some() {
			query.push(SelectionSet {
				operation: "forkTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_task_workflow.is_some() {
			query.push(SelectionSet {
				operation: "forkTaskWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_task_workflow_version.is_some() {
			query.push(SelectionSet {
				operation: "forkTaskWorkflowVersion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "dynamicTaskName")]
	pub dynamic_task_name: String,
	#[serde(rename = "subWorkflowName")]
	pub sub_workflow_name: Option<String>,
	#[serde(rename = "subWorkflowVersion")]
	pub sub_workflow_version: Option<i64>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl DynamicInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_dynamic_task_name(mut self, dynamic_task_name: String) -> Self {
		self.dynamic_task_name = dynamic_task_name;
		self
	}
	pub fn set_sub_workflow_name(mut self, sub_workflow_name: String) -> Self {
		self.sub_workflow_name = Some(sub_workflow_name);
		self
	}
	pub fn set_sub_workflow_version(mut self, sub_workflow_version: i64) -> Self {
		self.sub_workflow_version = Some(sub_workflow_version);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "dynamicTaskName",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.sub_workflow_name.is_some() {
			query.push(SelectionSet {
				operation: "subWorkflowName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.sub_workflow_version.is_some() {
			query.push(SelectionSet {
				operation: "subWorkflowVersion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "dynamicTaskName")]
	pub dynamic_task_name: Option<OrderByEnum>,
	#[serde(rename = "subWorkflowName")]
	pub sub_workflow_name: Option<OrderByEnum>,
	#[serde(rename = "subWorkflowVersion")]
	pub sub_workflow_version: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl DynamicOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_dynamic_task_name(mut self, dynamic_task_name: OrderByEnum) -> Self {
		self.dynamic_task_name = Some(dynamic_task_name);
		self
	}
	pub fn set_sub_workflow_name(mut self, sub_workflow_name: OrderByEnum) -> Self {
		self.sub_workflow_name = Some(sub_workflow_name);
		self
	}
	pub fn set_sub_workflow_version(mut self, sub_workflow_version: OrderByEnum) -> Self {
		self.sub_workflow_version = Some(sub_workflow_version);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_task_name.is_some() {
			query.push(SelectionSet {
				operation: "dynamicTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.sub_workflow_name.is_some() {
			query.push(SelectionSet {
				operation: "subWorkflowName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.sub_workflow_version.is_some() {
			query.push(SelectionSet {
				operation: "subWorkflowVersion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "dynamicTaskName")]
	pub dynamic_task_name: Option<String>,
	#[serde(rename = "subWorkflowName")]
	pub sub_workflow_name: Option<String>,
	#[serde(rename = "subWorkflowVersion")]
	pub sub_workflow_version: Option<i64>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl DynamicUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_dynamic_task_name(mut self, dynamic_task_name: String) -> Self {
		self.dynamic_task_name = Some(dynamic_task_name);
		self
	}
	pub fn set_sub_workflow_name(mut self, sub_workflow_name: String) -> Self {
		self.sub_workflow_name = Some(sub_workflow_name);
		self
	}
	pub fn set_sub_workflow_version(mut self, sub_workflow_version: i64) -> Self {
		self.sub_workflow_version = Some(sub_workflow_version);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_task_name.is_some() {
			query.push(SelectionSet {
				operation: "dynamicTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.sub_workflow_name.is_some() {
			query.push(SelectionSet {
				operation: "subWorkflowName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.sub_workflow_version.is_some() {
			query.push(SelectionSet {
				operation: "subWorkflowVersion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct EvaluatorTypeEnumFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<EvaluatorTypeEnum>,
	#[serde(rename = "ne")]
	pub ne: Option<EvaluatorTypeEnum>,
	#[serde(rename = "gt")]
	pub gt: Option<EvaluatorTypeEnum>,
	#[serde(rename = "gte")]
	pub gte: Option<EvaluatorTypeEnum>,
	#[serde(rename = "lt")]
	pub lt: Option<EvaluatorTypeEnum>,
	#[serde(rename = "lte")]
	pub lte: Option<EvaluatorTypeEnum>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<EvaluatorTypeEnum>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<EvaluatorTypeEnum>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<EvaluatorTypeEnum>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<EvaluatorTypeEnum>,
}
impl EvaluatorTypeEnumFilterInput {
	pub fn set_eq(mut self, eq: EvaluatorTypeEnum) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: EvaluatorTypeEnum) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: EvaluatorTypeEnum) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: EvaluatorTypeEnum) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: EvaluatorTypeEnum) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: EvaluatorTypeEnum) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<EvaluatorTypeEnum>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<EvaluatorTypeEnum>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: EvaluatorTypeEnum) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: EvaluatorTypeEnum) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct EventFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "sink")]
	pub sink: Option<StringFilterInput>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<BooleanFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<EventFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<EventFilterInput>>>,
}
impl EventFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_sink(mut self, sink: StringFilterInput) -> Self {
		self.sink = Some(sink);
		self
	}
	pub fn set_async_complete(mut self, async_complete: BooleanFilterInput) -> Self {
		self.async_complete = Some(async_complete);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<EventFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<EventFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(sink) = &self.sink {
			query.push(SelectionSet {
				operation: "sink",
				alias: None,
				fields: Some(sink.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(async_complete) = &self.async_complete {
			query.push(SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: Some(async_complete.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct EventInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "sink")]
	pub sink: String,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl EventInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_sink(mut self, sink: String) -> Self {
		self.sink = sink;
		self
	}
	pub fn set_async_complete(mut self, async_complete: bool) -> Self {
		self.async_complete = Some(async_complete);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "sink",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.async_complete.is_some() {
			query.push(SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct EventOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "sink")]
	pub sink: Option<OrderByEnum>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl EventOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_sink(mut self, sink: OrderByEnum) -> Self {
		self.sink = Some(sink);
		self
	}
	pub fn set_async_complete(mut self, async_complete: OrderByEnum) -> Self {
		self.async_complete = Some(async_complete);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.sink.is_some() {
			query.push(SelectionSet {
				operation: "sink",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.async_complete.is_some() {
			query.push(SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct EventUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "sink")]
	pub sink: Option<String>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl EventUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_sink(mut self, sink: String) -> Self {
		self.sink = Some(sink);
		self
	}
	pub fn set_async_complete(mut self, async_complete: bool) -> Self {
		self.async_complete = Some(async_complete);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.sink.is_some() {
			query.push(SelectionSet {
				operation: "sink",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.async_complete.is_some() {
			query.push(SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ForkFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<ForkFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<ForkFilterInput>>>,
}
impl ForkFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<ForkFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<ForkFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ForkInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl ForkInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ForkOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "forkTasks")]
	pub fork_tasks: Option<OrderByEnum>,
	#[serde(rename = "taskIds")]
	pub task_ids: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl ForkOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_fork_tasks(mut self, fork_tasks: OrderByEnum) -> Self {
		self.fork_tasks = Some(fork_tasks);
		self
	}
	pub fn set_task_ids(mut self, task_ids: OrderByEnum) -> Self {
		self.task_ids = Some(task_ids);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_tasks.is_some() {
			query.push(SelectionSet {
				operation: "forkTasks",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_ids.is_some() {
			query.push(SelectionSet {
				operation: "taskIds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ForkTypeEnumFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<ForkTypeEnum>,
	#[serde(rename = "ne")]
	pub ne: Option<ForkTypeEnum>,
	#[serde(rename = "gt")]
	pub gt: Option<ForkTypeEnum>,
	#[serde(rename = "gte")]
	pub gte: Option<ForkTypeEnum>,
	#[serde(rename = "lt")]
	pub lt: Option<ForkTypeEnum>,
	#[serde(rename = "lte")]
	pub lte: Option<ForkTypeEnum>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<ForkTypeEnum>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<ForkTypeEnum>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<ForkTypeEnum>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<ForkTypeEnum>,
}
impl ForkTypeEnumFilterInput {
	pub fn set_eq(mut self, eq: ForkTypeEnum) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: ForkTypeEnum) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: ForkTypeEnum) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: ForkTypeEnum) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: ForkTypeEnum) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: ForkTypeEnum) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<ForkTypeEnum>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<ForkTypeEnum>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: ForkTypeEnum) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: ForkTypeEnum) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ForkUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl ForkUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetSignedJwtFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "subject")]
	pub subject: Option<StringFilterInput>,
	#[serde(rename = "issuer")]
	pub issuer: Option<StringFilterInput>,
	#[serde(rename = "privateKey")]
	pub private_key: Option<StringFilterInput>,
	#[serde(rename = "privateKeyId")]
	pub private_key_id: Option<StringFilterInput>,
	#[serde(rename = "audience")]
	pub audience: Option<StringFilterInput>,
	#[serde(rename = "ttlInSeconds")]
	pub ttl_in_seconds: Option<IntegerFilterInput>,
	#[serde(rename = "scopes")]
	pub scopes: Option<StringFilterInput>,
	#[serde(rename = "algorithm")]
	pub algorithm: Option<StringFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<GetSignedJwtFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<GetSignedJwtFilterInput>>>,
}
impl GetSignedJwtFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_subject(mut self, subject: StringFilterInput) -> Self {
		self.subject = Some(subject);
		self
	}
	pub fn set_issuer(mut self, issuer: StringFilterInput) -> Self {
		self.issuer = Some(issuer);
		self
	}
	pub fn set_private_key(mut self, private_key: StringFilterInput) -> Self {
		self.private_key = Some(private_key);
		self
	}
	pub fn set_private_key_id(mut self, private_key_id: StringFilterInput) -> Self {
		self.private_key_id = Some(private_key_id);
		self
	}
	pub fn set_audience(mut self, audience: StringFilterInput) -> Self {
		self.audience = Some(audience);
		self
	}
	pub fn set_ttl_in_seconds(mut self, ttl_in_seconds: IntegerFilterInput) -> Self {
		self.ttl_in_seconds = Some(ttl_in_seconds);
		self
	}
	pub fn set_scopes(mut self, scopes: StringFilterInput) -> Self {
		self.scopes = Some(scopes);
		self
	}
	pub fn set_algorithm(mut self, algorithm: StringFilterInput) -> Self {
		self.algorithm = Some(algorithm);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<GetSignedJwtFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<GetSignedJwtFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(subject) = &self.subject {
			query.push(SelectionSet {
				operation: "subject",
				alias: None,
				fields: Some(subject.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(issuer) = &self.issuer {
			query.push(SelectionSet {
				operation: "issuer",
				alias: None,
				fields: Some(issuer.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(private_key) = &self.private_key {
			query.push(SelectionSet {
				operation: "privateKey",
				alias: None,
				fields: Some(private_key.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(private_key_id) = &self.private_key_id {
			query.push(SelectionSet {
				operation: "privateKeyId",
				alias: None,
				fields: Some(private_key_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(audience) = &self.audience {
			query.push(SelectionSet {
				operation: "audience",
				alias: None,
				fields: Some(audience.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(ttl_in_seconds) = &self.ttl_in_seconds {
			query.push(SelectionSet {
				operation: "ttlInSeconds",
				alias: None,
				fields: Some(ttl_in_seconds.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(scopes) = &self.scopes {
			query.push(SelectionSet {
				operation: "scopes",
				alias: None,
				fields: Some(scopes.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(algorithm) = &self.algorithm {
			query.push(SelectionSet {
				operation: "algorithm",
				alias: None,
				fields: Some(algorithm.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetSignedJwtInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "subject")]
	pub subject: String,
	#[serde(rename = "issuer")]
	pub issuer: String,
	#[serde(rename = "privateKey")]
	pub private_key: String,
	#[serde(rename = "privateKeyId")]
	pub private_key_id: String,
	#[serde(rename = "audience")]
	pub audience: String,
	#[serde(rename = "ttlInSeconds")]
	pub ttl_in_seconds: i64,
	#[serde(rename = "scopes")]
	pub scopes: String,
	#[serde(rename = "algorithm")]
	pub algorithm: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl GetSignedJwtInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_subject(mut self, subject: String) -> Self {
		self.subject = subject;
		self
	}
	pub fn set_issuer(mut self, issuer: String) -> Self {
		self.issuer = issuer;
		self
	}
	pub fn set_private_key(mut self, private_key: String) -> Self {
		self.private_key = private_key;
		self
	}
	pub fn set_private_key_id(mut self, private_key_id: String) -> Self {
		self.private_key_id = private_key_id;
		self
	}
	pub fn set_audience(mut self, audience: String) -> Self {
		self.audience = audience;
		self
	}
	pub fn set_ttl_in_seconds(mut self, ttl_in_seconds: i64) -> Self {
		self.ttl_in_seconds = ttl_in_seconds;
		self
	}
	pub fn set_scopes(mut self, scopes: String) -> Self {
		self.scopes = scopes;
		self
	}
	pub fn set_algorithm(mut self, algorithm: String) -> Self {
		self.algorithm = algorithm;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "subject",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "issuer",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "privateKey",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "privateKeyId",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "audience",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "ttlInSeconds",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "scopes",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "algorithm",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetSignedJwtOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "subject")]
	pub subject: Option<OrderByEnum>,
	#[serde(rename = "issuer")]
	pub issuer: Option<OrderByEnum>,
	#[serde(rename = "privateKey")]
	pub private_key: Option<OrderByEnum>,
	#[serde(rename = "privateKeyId")]
	pub private_key_id: Option<OrderByEnum>,
	#[serde(rename = "audience")]
	pub audience: Option<OrderByEnum>,
	#[serde(rename = "ttlInSeconds")]
	pub ttl_in_seconds: Option<OrderByEnum>,
	#[serde(rename = "scopes")]
	pub scopes: Option<OrderByEnum>,
	#[serde(rename = "algorithm")]
	pub algorithm: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl GetSignedJwtOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_subject(mut self, subject: OrderByEnum) -> Self {
		self.subject = Some(subject);
		self
	}
	pub fn set_issuer(mut self, issuer: OrderByEnum) -> Self {
		self.issuer = Some(issuer);
		self
	}
	pub fn set_private_key(mut self, private_key: OrderByEnum) -> Self {
		self.private_key = Some(private_key);
		self
	}
	pub fn set_private_key_id(mut self, private_key_id: OrderByEnum) -> Self {
		self.private_key_id = Some(private_key_id);
		self
	}
	pub fn set_audience(mut self, audience: OrderByEnum) -> Self {
		self.audience = Some(audience);
		self
	}
	pub fn set_ttl_in_seconds(mut self, ttl_in_seconds: OrderByEnum) -> Self {
		self.ttl_in_seconds = Some(ttl_in_seconds);
		self
	}
	pub fn set_scopes(mut self, scopes: OrderByEnum) -> Self {
		self.scopes = Some(scopes);
		self
	}
	pub fn set_algorithm(mut self, algorithm: OrderByEnum) -> Self {
		self.algorithm = Some(algorithm);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.subject.is_some() {
			query.push(SelectionSet {
				operation: "subject",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.issuer.is_some() {
			query.push(SelectionSet {
				operation: "issuer",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.private_key.is_some() {
			query.push(SelectionSet {
				operation: "privateKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.private_key_id.is_some() {
			query.push(SelectionSet {
				operation: "privateKeyId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.audience.is_some() {
			query.push(SelectionSet {
				operation: "audience",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ttl_in_seconds.is_some() {
			query.push(SelectionSet {
				operation: "ttlInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.scopes.is_some() {
			query.push(SelectionSet {
				operation: "scopes",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.algorithm.is_some() {
			query.push(SelectionSet {
				operation: "algorithm",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetSignedJwtUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "subject")]
	pub subject: Option<String>,
	#[serde(rename = "issuer")]
	pub issuer: Option<String>,
	#[serde(rename = "privateKey")]
	pub private_key: Option<String>,
	#[serde(rename = "privateKeyId")]
	pub private_key_id: Option<String>,
	#[serde(rename = "audience")]
	pub audience: Option<String>,
	#[serde(rename = "ttlInSeconds")]
	pub ttl_in_seconds: Option<i64>,
	#[serde(rename = "scopes")]
	pub scopes: Option<String>,
	#[serde(rename = "algorithm")]
	pub algorithm: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl GetSignedJwtUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_subject(mut self, subject: String) -> Self {
		self.subject = Some(subject);
		self
	}
	pub fn set_issuer(mut self, issuer: String) -> Self {
		self.issuer = Some(issuer);
		self
	}
	pub fn set_private_key(mut self, private_key: String) -> Self {
		self.private_key = Some(private_key);
		self
	}
	pub fn set_private_key_id(mut self, private_key_id: String) -> Self {
		self.private_key_id = Some(private_key_id);
		self
	}
	pub fn set_audience(mut self, audience: String) -> Self {
		self.audience = Some(audience);
		self
	}
	pub fn set_ttl_in_seconds(mut self, ttl_in_seconds: i64) -> Self {
		self.ttl_in_seconds = Some(ttl_in_seconds);
		self
	}
	pub fn set_scopes(mut self, scopes: String) -> Self {
		self.scopes = Some(scopes);
		self
	}
	pub fn set_algorithm(mut self, algorithm: String) -> Self {
		self.algorithm = Some(algorithm);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.subject.is_some() {
			query.push(SelectionSet {
				operation: "subject",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.issuer.is_some() {
			query.push(SelectionSet {
				operation: "issuer",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.private_key.is_some() {
			query.push(SelectionSet {
				operation: "privateKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.private_key_id.is_some() {
			query.push(SelectionSet {
				operation: "privateKeyId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.audience.is_some() {
			query.push(SelectionSet {
				operation: "audience",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ttl_in_seconds.is_some() {
			query.push(SelectionSet {
				operation: "ttlInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.scopes.is_some() {
			query.push(SelectionSet {
				operation: "scopes",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.algorithm.is_some() {
			query.push(SelectionSet {
				operation: "algorithm",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetWorkflowFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "includeTasks")]
	pub include_tasks: Option<BooleanFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<GetWorkflowFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<GetWorkflowFilterInput>>>,
}
impl GetWorkflowFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_include_tasks(mut self, include_tasks: BooleanFilterInput) -> Self {
		self.include_tasks = Some(include_tasks);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<GetWorkflowFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<GetWorkflowFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(include_tasks) = &self.include_tasks {
			query.push(SelectionSet {
				operation: "includeTasks",
				alias: None,
				fields: Some(include_tasks.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetWorkflowInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "includeTasks")]
	pub include_tasks: bool,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl GetWorkflowInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_include_tasks(mut self, include_tasks: bool) -> Self {
		self.include_tasks = include_tasks;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "includeTasks",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetWorkflowOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "includeTasks")]
	pub include_tasks: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl GetWorkflowOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_include_tasks(mut self, include_tasks: OrderByEnum) -> Self {
		self.include_tasks = Some(include_tasks);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.include_tasks.is_some() {
			query.push(SelectionSet {
				operation: "includeTasks",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetWorkflowUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "includeTasks")]
	pub include_tasks: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl GetWorkflowUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_include_tasks(mut self, include_tasks: bool) -> Self {
		self.include_tasks = Some(include_tasks);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.include_tasks.is_some() {
			query.push(SelectionSet {
				operation: "includeTasks",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HttpFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "uri")]
	pub uri: Option<StringFilterInput>,
	#[serde(rename = "method")]
	pub method: Option<StringFilterInput>,
	#[serde(rename = "accept")]
	pub accept: Option<StringFilterInput>,
	#[serde(rename = "contentType")]
	pub content_type: Option<StringFilterInput>,
	#[serde(rename = "terminationCondition")]
	pub termination_condition: Option<StringFilterInput>,
	#[serde(rename = "pollingInterval")]
	pub polling_interval: Option<IntegerFilterInput>,
	#[serde(rename = "pollingStrategy")]
	pub polling_strategy: Option<StringFilterInput>,
	#[serde(rename = "encode")]
	pub encode: Option<BooleanFilterInput>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<BooleanFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<HttpFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<HttpFilterInput>>>,
}
impl HttpFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_uri(mut self, uri: StringFilterInput) -> Self {
		self.uri = Some(uri);
		self
	}
	pub fn set_method(mut self, method: StringFilterInput) -> Self {
		self.method = Some(method);
		self
	}
	pub fn set_accept(mut self, accept: StringFilterInput) -> Self {
		self.accept = Some(accept);
		self
	}
	pub fn set_content_type(mut self, content_type: StringFilterInput) -> Self {
		self.content_type = Some(content_type);
		self
	}
	pub fn set_termination_condition(mut self, termination_condition: StringFilterInput) -> Self {
		self.termination_condition = Some(termination_condition);
		self
	}
	pub fn set_polling_interval(mut self, polling_interval: IntegerFilterInput) -> Self {
		self.polling_interval = Some(polling_interval);
		self
	}
	pub fn set_polling_strategy(mut self, polling_strategy: StringFilterInput) -> Self {
		self.polling_strategy = Some(polling_strategy);
		self
	}
	pub fn set_encode(mut self, encode: BooleanFilterInput) -> Self {
		self.encode = Some(encode);
		self
	}
	pub fn set_async_complete(mut self, async_complete: BooleanFilterInput) -> Self {
		self.async_complete = Some(async_complete);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<HttpFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<HttpFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(uri) = &self.uri {
			query.push(SelectionSet {
				operation: "uri",
				alias: None,
				fields: Some(uri.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(method) = &self.method {
			query.push(SelectionSet {
				operation: "method",
				alias: None,
				fields: Some(method.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(accept) = &self.accept {
			query.push(SelectionSet {
				operation: "accept",
				alias: None,
				fields: Some(accept.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(content_type) = &self.content_type {
			query.push(SelectionSet {
				operation: "contentType",
				alias: None,
				fields: Some(content_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(termination_condition) = &self.termination_condition {
			query.push(SelectionSet {
				operation: "terminationCondition",
				alias: None,
				fields: Some(termination_condition.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(polling_interval) = &self.polling_interval {
			query.push(SelectionSet {
				operation: "pollingInterval",
				alias: None,
				fields: Some(polling_interval.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(polling_strategy) = &self.polling_strategy {
			query.push(SelectionSet {
				operation: "pollingStrategy",
				alias: None,
				fields: Some(polling_strategy.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(encode) = &self.encode {
			query.push(SelectionSet {
				operation: "encode",
				alias: None,
				fields: Some(encode.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(async_complete) = &self.async_complete {
			query.push(SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: Some(async_complete.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HttpInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "uri")]
	pub uri: String,
	#[serde(rename = "method")]
	pub method: String,
	#[serde(rename = "accept")]
	pub accept: Option<String>,
	#[serde(rename = "contentType")]
	pub content_type: Option<String>,
	#[serde(rename = "terminationCondition")]
	pub termination_condition: Option<String>,
	#[serde(rename = "pollingInterval")]
	pub polling_interval: Option<i64>,
	#[serde(rename = "pollingStrategy")]
	pub polling_strategy: Option<String>,
	#[serde(rename = "encode")]
	pub encode: Option<bool>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl HttpInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_uri(mut self, uri: String) -> Self {
		self.uri = uri;
		self
	}
	pub fn set_method(mut self, method: String) -> Self {
		self.method = method;
		self
	}
	pub fn set_accept(mut self, accept: String) -> Self {
		self.accept = Some(accept);
		self
	}
	pub fn set_content_type(mut self, content_type: String) -> Self {
		self.content_type = Some(content_type);
		self
	}
	pub fn set_termination_condition(mut self, termination_condition: String) -> Self {
		self.termination_condition = Some(termination_condition);
		self
	}
	pub fn set_polling_interval(mut self, polling_interval: i64) -> Self {
		self.polling_interval = Some(polling_interval);
		self
	}
	pub fn set_polling_strategy(mut self, polling_strategy: String) -> Self {
		self.polling_strategy = Some(polling_strategy);
		self
	}
	pub fn set_encode(mut self, encode: bool) -> Self {
		self.encode = Some(encode);
		self
	}
	pub fn set_async_complete(mut self, async_complete: bool) -> Self {
		self.async_complete = Some(async_complete);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "uri",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "method",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.accept.is_some() {
			query.push(SelectionSet {
				operation: "accept",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.content_type.is_some() {
			query.push(SelectionSet {
				operation: "contentType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.termination_condition.is_some() {
			query.push(SelectionSet {
				operation: "terminationCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.polling_interval.is_some() {
			query.push(SelectionSet {
				operation: "pollingInterval",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.polling_strategy.is_some() {
			query.push(SelectionSet {
				operation: "pollingStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.encode.is_some() {
			query.push(SelectionSet {
				operation: "encode",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.async_complete.is_some() {
			query.push(SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HttpOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "uri")]
	pub uri: Option<OrderByEnum>,
	#[serde(rename = "method")]
	pub method: Option<OrderByEnum>,
	#[serde(rename = "accept")]
	pub accept: Option<OrderByEnum>,
	#[serde(rename = "contentType")]
	pub content_type: Option<OrderByEnum>,
	#[serde(rename = "terminationCondition")]
	pub termination_condition: Option<OrderByEnum>,
	#[serde(rename = "pollingInterval")]
	pub polling_interval: Option<OrderByEnum>,
	#[serde(rename = "pollingStrategy")]
	pub polling_strategy: Option<OrderByEnum>,
	#[serde(rename = "headers")]
	pub headers: Option<OrderByEnum>,
	#[serde(rename = "body")]
	pub body: Option<OrderByEnum>,
	#[serde(rename = "encode")]
	pub encode: Option<OrderByEnum>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl HttpOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_uri(mut self, uri: OrderByEnum) -> Self {
		self.uri = Some(uri);
		self
	}
	pub fn set_method(mut self, method: OrderByEnum) -> Self {
		self.method = Some(method);
		self
	}
	pub fn set_accept(mut self, accept: OrderByEnum) -> Self {
		self.accept = Some(accept);
		self
	}
	pub fn set_content_type(mut self, content_type: OrderByEnum) -> Self {
		self.content_type = Some(content_type);
		self
	}
	pub fn set_termination_condition(mut self, termination_condition: OrderByEnum) -> Self {
		self.termination_condition = Some(termination_condition);
		self
	}
	pub fn set_polling_interval(mut self, polling_interval: OrderByEnum) -> Self {
		self.polling_interval = Some(polling_interval);
		self
	}
	pub fn set_polling_strategy(mut self, polling_strategy: OrderByEnum) -> Self {
		self.polling_strategy = Some(polling_strategy);
		self
	}
	pub fn set_headers(mut self, headers: OrderByEnum) -> Self {
		self.headers = Some(headers);
		self
	}
	pub fn set_body(mut self, body: OrderByEnum) -> Self {
		self.body = Some(body);
		self
	}
	pub fn set_encode(mut self, encode: OrderByEnum) -> Self {
		self.encode = Some(encode);
		self
	}
	pub fn set_async_complete(mut self, async_complete: OrderByEnum) -> Self {
		self.async_complete = Some(async_complete);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.uri.is_some() {
			query.push(SelectionSet {
				operation: "uri",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.method.is_some() {
			query.push(SelectionSet {
				operation: "method",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.accept.is_some() {
			query.push(SelectionSet {
				operation: "accept",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.content_type.is_some() {
			query.push(SelectionSet {
				operation: "contentType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.termination_condition.is_some() {
			query.push(SelectionSet {
				operation: "terminationCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.polling_interval.is_some() {
			query.push(SelectionSet {
				operation: "pollingInterval",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.polling_strategy.is_some() {
			query.push(SelectionSet {
				operation: "pollingStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.headers.is_some() {
			query.push(SelectionSet {
				operation: "headers",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.body.is_some() {
			query.push(SelectionSet {
				operation: "body",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.encode.is_some() {
			query.push(SelectionSet {
				operation: "encode",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.async_complete.is_some() {
			query.push(SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HttpUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "uri")]
	pub uri: Option<String>,
	#[serde(rename = "method")]
	pub method: Option<String>,
	#[serde(rename = "accept")]
	pub accept: Option<String>,
	#[serde(rename = "contentType")]
	pub content_type: Option<String>,
	#[serde(rename = "terminationCondition")]
	pub termination_condition: Option<String>,
	#[serde(rename = "pollingInterval")]
	pub polling_interval: Option<i64>,
	#[serde(rename = "pollingStrategy")]
	pub polling_strategy: Option<String>,
	#[serde(rename = "encode")]
	pub encode: Option<bool>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl HttpUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_uri(mut self, uri: String) -> Self {
		self.uri = Some(uri);
		self
	}
	pub fn set_method(mut self, method: String) -> Self {
		self.method = Some(method);
		self
	}
	pub fn set_accept(mut self, accept: String) -> Self {
		self.accept = Some(accept);
		self
	}
	pub fn set_content_type(mut self, content_type: String) -> Self {
		self.content_type = Some(content_type);
		self
	}
	pub fn set_termination_condition(mut self, termination_condition: String) -> Self {
		self.termination_condition = Some(termination_condition);
		self
	}
	pub fn set_polling_interval(mut self, polling_interval: i64) -> Self {
		self.polling_interval = Some(polling_interval);
		self
	}
	pub fn set_polling_strategy(mut self, polling_strategy: String) -> Self {
		self.polling_strategy = Some(polling_strategy);
		self
	}
	pub fn set_encode(mut self, encode: bool) -> Self {
		self.encode = Some(encode);
		self
	}
	pub fn set_async_complete(mut self, async_complete: bool) -> Self {
		self.async_complete = Some(async_complete);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.uri.is_some() {
			query.push(SelectionSet {
				operation: "uri",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.method.is_some() {
			query.push(SelectionSet {
				operation: "method",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.accept.is_some() {
			query.push(SelectionSet {
				operation: "accept",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.content_type.is_some() {
			query.push(SelectionSet {
				operation: "contentType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.termination_condition.is_some() {
			query.push(SelectionSet {
				operation: "terminationCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.polling_interval.is_some() {
			query.push(SelectionSet {
				operation: "pollingInterval",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.polling_strategy.is_some() {
			query.push(SelectionSet {
				operation: "pollingStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.encode.is_some() {
			query.push(SelectionSet {
				operation: "encode",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.async_complete.is_some() {
			query.push(SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HumanFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "taskType")]
	pub task_type: Option<TaskTypeEnumFilterInput>,
	#[serde(rename = "status")]
	pub status: Option<TaskStatusEnumFilterInput>,
	#[serde(rename = "startTime")]
	pub start_time: Option<TextFilterInput>,
	#[serde(rename = "assignmentCompletionStrategy")]
	pub assignment_completion_strategy: Option<StringFilterInput>,
	#[serde(rename = "displayName")]
	pub display_name: Option<StringFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<HumanFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<HumanFilterInput>>>,
}
impl HumanFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_type(mut self, task_type: TaskTypeEnumFilterInput) -> Self {
		self.task_type = Some(task_type);
		self
	}
	pub fn set_status(mut self, status: TaskStatusEnumFilterInput) -> Self {
		self.status = Some(status);
		self
	}
	pub fn set_start_time(mut self, start_time: TextFilterInput) -> Self {
		self.start_time = Some(start_time);
		self
	}
	pub fn set_assignment_completion_strategy(
		mut self,
		assignment_completion_strategy: StringFilterInput,
	) -> Self {
		self.assignment_completion_strategy = Some(assignment_completion_strategy);
		self
	}
	pub fn set_display_name(mut self, display_name: StringFilterInput) -> Self {
		self.display_name = Some(display_name);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<HumanFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<HumanFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_type) = &self.task_type {
			query.push(SelectionSet {
				operation: "taskType",
				alias: None,
				fields: Some(task_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(status) = &self.status {
			query.push(SelectionSet {
				operation: "status",
				alias: None,
				fields: Some(status.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(start_time) = &self.start_time {
			query.push(SelectionSet {
				operation: "startTime",
				alias: None,
				fields: Some(start_time.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(assignment_completion_strategy) = &self.assignment_completion_strategy {
			query.push(SelectionSet {
				operation: "assignmentCompletionStrategy",
				alias: None,
				fields: Some(assignment_completion_strategy.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(display_name) = &self.display_name {
			query.push(SelectionSet {
				operation: "displayName",
				alias: None,
				fields: Some(display_name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HumanInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskType")]
	pub task_type: TaskTypeEnum,
	#[serde(rename = "status")]
	pub status: TaskStatusEnum,
	#[serde(rename = "startTime")]
	pub start_time: String,
	#[serde(rename = "assignmentCompletionStrategy")]
	pub assignment_completion_strategy: String,
	#[serde(rename = "displayName")]
	pub display_name: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl HumanInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_task_type(mut self, task_type: TaskTypeEnum) -> Self {
		self.task_type = task_type;
		self
	}
	pub fn set_status(mut self, status: TaskStatusEnum) -> Self {
		self.status = status;
		self
	}
	pub fn set_start_time(mut self, start_time: String) -> Self {
		self.start_time = start_time;
		self
	}
	pub fn set_assignment_completion_strategy(
		mut self,
		assignment_completion_strategy: String,
	) -> Self {
		self.assignment_completion_strategy = assignment_completion_strategy;
		self
	}
	pub fn set_display_name(mut self, display_name: String) -> Self {
		self.display_name = display_name;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "taskType",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "status",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "startTime",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "assignmentCompletionStrategy",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "displayName",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HumanOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "taskType")]
	pub task_type: Option<OrderByEnum>,
	#[serde(rename = "status")]
	pub status: Option<OrderByEnum>,
	#[serde(rename = "startTime")]
	pub start_time: Option<OrderByEnum>,
	#[serde(rename = "assignmentCompletionStrategy")]
	pub assignment_completion_strategy: Option<OrderByEnum>,
	#[serde(rename = "displayName")]
	pub display_name: Option<OrderByEnum>,
	#[serde(rename = "userFormTemplate")]
	pub user_form_template: Option<OrderByEnum>,
	#[serde(rename = "assignments")]
	pub assignments: Option<OrderByEnum>,
	#[serde(rename = "taskTriggers")]
	pub task_triggers: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl HumanOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_type(mut self, task_type: OrderByEnum) -> Self {
		self.task_type = Some(task_type);
		self
	}
	pub fn set_status(mut self, status: OrderByEnum) -> Self {
		self.status = Some(status);
		self
	}
	pub fn set_start_time(mut self, start_time: OrderByEnum) -> Self {
		self.start_time = Some(start_time);
		self
	}
	pub fn set_assignment_completion_strategy(
		mut self,
		assignment_completion_strategy: OrderByEnum,
	) -> Self {
		self.assignment_completion_strategy = Some(assignment_completion_strategy);
		self
	}
	pub fn set_display_name(mut self, display_name: OrderByEnum) -> Self {
		self.display_name = Some(display_name);
		self
	}
	pub fn set_user_form_template(mut self, user_form_template: OrderByEnum) -> Self {
		self.user_form_template = Some(user_form_template);
		self
	}
	pub fn set_assignments(mut self, assignments: OrderByEnum) -> Self {
		self.assignments = Some(assignments);
		self
	}
	pub fn set_task_triggers(mut self, task_triggers: OrderByEnum) -> Self {
		self.task_triggers = Some(task_triggers);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_type.is_some() {
			query.push(SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.status.is_some() {
			query.push(SelectionSet {
				operation: "status",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.start_time.is_some() {
			query.push(SelectionSet {
				operation: "startTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.assignment_completion_strategy.is_some() {
			query.push(SelectionSet {
				operation: "assignmentCompletionStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.display_name.is_some() {
			query.push(SelectionSet {
				operation: "displayName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.user_form_template.is_some() {
			query.push(SelectionSet {
				operation: "userFormTemplate",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.assignments.is_some() {
			query.push(SelectionSet {
				operation: "assignments",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_triggers.is_some() {
			query.push(SelectionSet {
				operation: "taskTriggers",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HumanUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "taskType")]
	pub task_type: Option<TaskTypeEnum>,
	#[serde(rename = "status")]
	pub status: Option<TaskStatusEnum>,
	#[serde(rename = "startTime")]
	pub start_time: Option<String>,
	#[serde(rename = "assignmentCompletionStrategy")]
	pub assignment_completion_strategy: Option<String>,
	#[serde(rename = "displayName")]
	pub display_name: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl HumanUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_type(mut self, task_type: TaskTypeEnum) -> Self {
		self.task_type = Some(task_type);
		self
	}
	pub fn set_status(mut self, status: TaskStatusEnum) -> Self {
		self.status = Some(status);
		self
	}
	pub fn set_start_time(mut self, start_time: String) -> Self {
		self.start_time = Some(start_time);
		self
	}
	pub fn set_assignment_completion_strategy(
		mut self,
		assignment_completion_strategy: String,
	) -> Self {
		self.assignment_completion_strategy = Some(assignment_completion_strategy);
		self
	}
	pub fn set_display_name(mut self, display_name: String) -> Self {
		self.display_name = Some(display_name);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_type.is_some() {
			query.push(SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.status.is_some() {
			query.push(SelectionSet {
				operation: "status",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.start_time.is_some() {
			query.push(SelectionSet {
				operation: "startTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.assignment_completion_strategy.is_some() {
			query.push(SelectionSet {
				operation: "assignmentCompletionStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.display_name.is_some() {
			query.push(SelectionSet {
				operation: "displayName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct IdempotencyStrategyEnumFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "ne")]
	pub ne: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "gt")]
	pub gt: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "gte")]
	pub gte: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "lt")]
	pub lt: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "lte")]
	pub lte: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<IdempotencyStrategyEnum>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<IdempotencyStrategyEnum>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<IdempotencyStrategyEnum>,
}
impl IdempotencyStrategyEnumFilterInput {
	pub fn set_eq(mut self, eq: IdempotencyStrategyEnum) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: IdempotencyStrategyEnum) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: IdempotencyStrategyEnum) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: IdempotencyStrategyEnum) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: IdempotencyStrategyEnum) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: IdempotencyStrategyEnum) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<IdempotencyStrategyEnum>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<IdempotencyStrategyEnum>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: IdempotencyStrategyEnum) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: IdempotencyStrategyEnum) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct InlineFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<EvaluatorTypeEnumFilterInput>,
	#[serde(rename = "expression")]
	pub expression: Option<StringFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<InlineFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<InlineFilterInput>>>,
}
impl InlineFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnumFilterInput) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_expression(mut self, expression: StringFilterInput) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<InlineFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<InlineFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(evaluator_type) = &self.evaluator_type {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: Some(evaluator_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(expression) = &self.expression {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: Some(expression.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct InlineInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: EvaluatorTypeEnum,
	#[serde(rename = "expression")]
	pub expression: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl InlineInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnum) -> Self {
		self.evaluator_type = evaluator_type;
		self
	}
	pub fn set_expression(mut self, expression: String) -> Self {
		self.expression = expression;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "evaluatorType",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "expression",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct InlineOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<OrderByEnum>,
	#[serde(rename = "expression")]
	pub expression: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl InlineOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: OrderByEnum) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_expression(mut self, expression: OrderByEnum) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.evaluator_type.is_some() {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.expression.is_some() {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct InlineUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<EvaluatorTypeEnum>,
	#[serde(rename = "expression")]
	pub expression: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl InlineUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnum) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_expression(mut self, expression: String) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.evaluator_type.is_some() {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.expression.is_some() {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct IntegerFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<i64>,
	#[serde(rename = "ne")]
	pub ne: Option<i64>,
	#[serde(rename = "gt")]
	pub gt: Option<i64>,
	#[serde(rename = "gte")]
	pub gte: Option<i64>,
	#[serde(rename = "lt")]
	pub lt: Option<i64>,
	#[serde(rename = "lte")]
	pub lte: Option<i64>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<i64>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<i64>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<i64>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<i64>,
	#[serde(rename = "between")]
	pub between: Option<Vec<i64>>,
	#[serde(rename = "not_between")]
	pub not_between: Option<Vec<i64>>,
}
impl IntegerFilterInput {
	pub fn set_eq(mut self, eq: i64) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: i64) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: i64) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: i64) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: i64) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: i64) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<i64>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<i64>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: i64) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: i64) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn set_between(mut self, between: Vec<i64>) -> Self {
		self.between = Some(between);
		self
	}
	pub fn set_not_between(mut self, not_between: Vec<i64>) -> Self {
		self.not_between = Some(not_between);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.between.is_some() {
			query.push(SelectionSet {
				operation: "between",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.not_between.is_some() {
			query.push(SelectionSet {
				operation: "not_between",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JoinFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "expression")]
	pub expression: Option<StringFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<JoinFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<JoinFilterInput>>>,
}
impl JoinFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_expression(mut self, expression: StringFilterInput) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<JoinFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<JoinFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(expression) = &self.expression {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: Some(expression.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JoinInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "expression")]
	pub expression: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl JoinInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_expression(mut self, expression: String) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.expression.is_some() {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JoinOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "joinOn")]
	pub join_on: Option<OrderByEnum>,
	#[serde(rename = "expression")]
	pub expression: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl JoinOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_join_on(mut self, join_on: OrderByEnum) -> Self {
		self.join_on = Some(join_on);
		self
	}
	pub fn set_expression(mut self, expression: OrderByEnum) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.join_on.is_some() {
			query.push(SelectionSet {
				operation: "joinOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.expression.is_some() {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JoinUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "expression")]
	pub expression: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl JoinUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_expression(mut self, expression: String) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.expression.is_some() {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JsonTransformFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "queryExpression")]
	pub query_expression: Option<StringFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<JsonTransformFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<JsonTransformFilterInput>>>,
}
impl JsonTransformFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_query_expression(mut self, query_expression: StringFilterInput) -> Self {
		self.query_expression = Some(query_expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<JsonTransformFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<JsonTransformFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(query_expression) = &self.query_expression {
			query.push(SelectionSet {
				operation: "queryExpression",
				alias: None,
				fields: Some(query_expression.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JsonTransformInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "queryExpression")]
	pub query_expression: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl JsonTransformInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_query_expression(mut self, query_expression: String) -> Self {
		self.query_expression = query_expression;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "queryExpression",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JsonTransformOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "queryExpression")]
	pub query_expression: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl JsonTransformOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_query_expression(mut self, query_expression: OrderByEnum) -> Self {
		self.query_expression = Some(query_expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.query_expression.is_some() {
			query.push(SelectionSet {
				operation: "queryExpression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JsonTransformUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "queryExpression")]
	pub query_expression: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl JsonTransformUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_query_expression(mut self, query_expression: String) -> Self {
		self.query_expression = Some(query_expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.query_expression.is_some() {
			query.push(SelectionSet {
				operation: "queryExpression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct OffsetInput {
	#[serde(rename = "limit")]
	pub limit: i64,
	#[serde(rename = "offset")]
	pub offset: i64,
}
impl OffsetInput {
	pub fn set_limit(mut self, limit: i64) -> Self {
		self.limit = limit;
		self
	}
	pub fn set_offset(mut self, offset: i64) -> Self {
		self.offset = offset;
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "limit",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "offset",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct OperationTypeEnumFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<OperationTypeEnum>,
	#[serde(rename = "ne")]
	pub ne: Option<OperationTypeEnum>,
	#[serde(rename = "gt")]
	pub gt: Option<OperationTypeEnum>,
	#[serde(rename = "gte")]
	pub gte: Option<OperationTypeEnum>,
	#[serde(rename = "lt")]
	pub lt: Option<OperationTypeEnum>,
	#[serde(rename = "lte")]
	pub lte: Option<OperationTypeEnum>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<OperationTypeEnum>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<OperationTypeEnum>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<OperationTypeEnum>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<OperationTypeEnum>,
}
impl OperationTypeEnumFilterInput {
	pub fn set_eq(mut self, eq: OperationTypeEnum) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: OperationTypeEnum) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: OperationTypeEnum) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: OperationTypeEnum) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: OperationTypeEnum) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: OperationTypeEnum) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<OperationTypeEnum>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<OperationTypeEnum>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: OperationTypeEnum) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: OperationTypeEnum) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PageInput {
	#[serde(rename = "limit")]
	pub limit: i64,
	#[serde(rename = "page")]
	pub page: i64,
}
impl PageInput {
	pub fn set_limit(mut self, limit: i64) -> Self {
		self.limit = limit;
		self
	}
	pub fn set_page(mut self, page: i64) -> Self {
		self.page = page;
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "limit",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "page",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PaginationInput {
	#[serde(rename = "cursor")]
	pub cursor: Option<CursorInput>,
	#[serde(rename = "page")]
	pub page: Option<PageInput>,
	#[serde(rename = "offset")]
	pub offset: Option<OffsetInput>,
}
impl PaginationInput {
	pub fn set_cursor(mut self, cursor: CursorInput) -> Self {
		self.cursor = Some(cursor);
		self
	}
	pub fn set_page(mut self, page: PageInput) -> Self {
		self.page = Some(page);
		self
	}
	pub fn set_offset(mut self, offset: OffsetInput) -> Self {
		self.offset = Some(offset);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(cursor) = &self.cursor {
			query.push(SelectionSet {
				operation: "cursor",
				alias: None,
				fields: Some(cursor.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(page) = &self.page {
			query.push(SelectionSet {
				operation: "page",
				alias: None,
				fields: Some(page.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(offset) = &self.offset {
			query.push(SelectionSet {
				operation: "offset",
				alias: None,
				fields: Some(offset.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PollDataFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "createdOn")]
	pub created_on: Option<TextFilterInput>,
	#[serde(rename = "modifiedOn")]
	pub modified_on: Option<TextFilterInput>,
	#[serde(rename = "queueName")]
	pub queue_name: Option<StringFilterInput>,
	#[serde(rename = "domain")]
	pub domain: Option<StringFilterInput>,
	#[serde(rename = "jsonData")]
	pub json_data: Option<StringFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<PollDataFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<PollDataFilterInput>>>,
}
impl PollDataFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_created_on(mut self, created_on: TextFilterInput) -> Self {
		self.created_on = Some(created_on);
		self
	}
	pub fn set_modified_on(mut self, modified_on: TextFilterInput) -> Self {
		self.modified_on = Some(modified_on);
		self
	}
	pub fn set_queue_name(mut self, queue_name: StringFilterInput) -> Self {
		self.queue_name = Some(queue_name);
		self
	}
	pub fn set_domain(mut self, domain: StringFilterInput) -> Self {
		self.domain = Some(domain);
		self
	}
	pub fn set_json_data(mut self, json_data: StringFilterInput) -> Self {
		self.json_data = Some(json_data);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<PollDataFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<PollDataFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(created_on) = &self.created_on {
			query.push(SelectionSet {
				operation: "createdOn",
				alias: None,
				fields: Some(created_on.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(modified_on) = &self.modified_on {
			query.push(SelectionSet {
				operation: "modifiedOn",
				alias: None,
				fields: Some(modified_on.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(queue_name) = &self.queue_name {
			query.push(SelectionSet {
				operation: "queueName",
				alias: None,
				fields: Some(queue_name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(domain) = &self.domain {
			query.push(SelectionSet {
				operation: "domain",
				alias: None,
				fields: Some(domain.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(json_data) = &self.json_data {
			query.push(SelectionSet {
				operation: "jsonData",
				alias: None,
				fields: Some(json_data.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PollDataInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "createdOn")]
	pub created_on: String,
	#[serde(rename = "modifiedOn")]
	pub modified_on: String,
	#[serde(rename = "queueName")]
	pub queue_name: String,
	#[serde(rename = "domain")]
	pub domain: String,
	#[serde(rename = "jsonData")]
	pub json_data: String,
}
impl PollDataInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_created_on(mut self, created_on: String) -> Self {
		self.created_on = created_on;
		self
	}
	pub fn set_modified_on(mut self, modified_on: String) -> Self {
		self.modified_on = modified_on;
		self
	}
	pub fn set_queue_name(mut self, queue_name: String) -> Self {
		self.queue_name = queue_name;
		self
	}
	pub fn set_domain(mut self, domain: String) -> Self {
		self.domain = domain;
		self
	}
	pub fn set_json_data(mut self, json_data: String) -> Self {
		self.json_data = json_data;
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "createdOn",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "modifiedOn",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "queueName",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "domain",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "jsonData",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PollDataOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "createdOn")]
	pub created_on: Option<OrderByEnum>,
	#[serde(rename = "modifiedOn")]
	pub modified_on: Option<OrderByEnum>,
	#[serde(rename = "queueName")]
	pub queue_name: Option<OrderByEnum>,
	#[serde(rename = "domain")]
	pub domain: Option<OrderByEnum>,
	#[serde(rename = "jsonData")]
	pub json_data: Option<OrderByEnum>,
}
impl PollDataOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_created_on(mut self, created_on: OrderByEnum) -> Self {
		self.created_on = Some(created_on);
		self
	}
	pub fn set_modified_on(mut self, modified_on: OrderByEnum) -> Self {
		self.modified_on = Some(modified_on);
		self
	}
	pub fn set_queue_name(mut self, queue_name: OrderByEnum) -> Self {
		self.queue_name = Some(queue_name);
		self
	}
	pub fn set_domain(mut self, domain: OrderByEnum) -> Self {
		self.domain = Some(domain);
		self
	}
	pub fn set_json_data(mut self, json_data: OrderByEnum) -> Self {
		self.json_data = Some(json_data);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.created_on.is_some() {
			query.push(SelectionSet {
				operation: "createdOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.modified_on.is_some() {
			query.push(SelectionSet {
				operation: "modifiedOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.queue_name.is_some() {
			query.push(SelectionSet {
				operation: "queueName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.domain.is_some() {
			query.push(SelectionSet {
				operation: "domain",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.json_data.is_some() {
			query.push(SelectionSet {
				operation: "jsonData",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PollDataUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "createdOn")]
	pub created_on: Option<String>,
	#[serde(rename = "modifiedOn")]
	pub modified_on: Option<String>,
	#[serde(rename = "queueName")]
	pub queue_name: Option<String>,
	#[serde(rename = "domain")]
	pub domain: Option<String>,
	#[serde(rename = "jsonData")]
	pub json_data: Option<String>,
}
impl PollDataUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_created_on(mut self, created_on: String) -> Self {
		self.created_on = Some(created_on);
		self
	}
	pub fn set_modified_on(mut self, modified_on: String) -> Self {
		self.modified_on = Some(modified_on);
		self
	}
	pub fn set_queue_name(mut self, queue_name: String) -> Self {
		self.queue_name = Some(queue_name);
		self
	}
	pub fn set_domain(mut self, domain: String) -> Self {
		self.domain = Some(domain);
		self
	}
	pub fn set_json_data(mut self, json_data: String) -> Self {
		self.json_data = Some(json_data);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.created_on.is_some() {
			query.push(SelectionSet {
				operation: "createdOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.modified_on.is_some() {
			query.push(SelectionSet {
				operation: "modifiedOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.queue_name.is_some() {
			query.push(SelectionSet {
				operation: "queueName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.domain.is_some() {
			query.push(SelectionSet {
				operation: "domain",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.json_data.is_some() {
			query.push(SelectionSet {
				operation: "jsonData",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct RetryLogicEnumFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<RetryLogicEnum>,
	#[serde(rename = "ne")]
	pub ne: Option<RetryLogicEnum>,
	#[serde(rename = "gt")]
	pub gt: Option<RetryLogicEnum>,
	#[serde(rename = "gte")]
	pub gte: Option<RetryLogicEnum>,
	#[serde(rename = "lt")]
	pub lt: Option<RetryLogicEnum>,
	#[serde(rename = "lte")]
	pub lte: Option<RetryLogicEnum>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<RetryLogicEnum>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<RetryLogicEnum>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<RetryLogicEnum>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<RetryLogicEnum>,
}
impl RetryLogicEnumFilterInput {
	pub fn set_eq(mut self, eq: RetryLogicEnum) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: RetryLogicEnum) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: RetryLogicEnum) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: RetryLogicEnum) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: RetryLogicEnum) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: RetryLogicEnum) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<RetryLogicEnum>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<RetryLogicEnum>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: RetryLogicEnum) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: RetryLogicEnum) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SetVariableFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<SetVariableFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<SetVariableFilterInput>>>,
}
impl SetVariableFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<SetVariableFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<SetVariableFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SetVariableInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SetVariableInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SetVariableOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl SetVariableOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SetVariableUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SetVariableUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SimpleFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<SimpleFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<SimpleFilterInput>>>,
}
impl SimpleFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<SimpleFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<SimpleFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SimpleInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SimpleInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SimpleOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl SimpleOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SimpleUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SimpleUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SqlFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "integrationName")]
	pub integration_name: Option<StringFilterInput>,
	#[serde(rename = "statement")]
	pub statement: Option<StringFilterInput>,
	#[serde(rename = "operationType")]
	pub operation_type: Option<OperationTypeEnumFilterInput>,
	#[serde(rename = "expectedOutputCount")]
	pub expected_output_count: Option<IntegerFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<SqlFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<SqlFilterInput>>>,
}
impl SqlFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_integration_name(mut self, integration_name: StringFilterInput) -> Self {
		self.integration_name = Some(integration_name);
		self
	}
	pub fn set_statement(mut self, statement: StringFilterInput) -> Self {
		self.statement = Some(statement);
		self
	}
	pub fn set_operation_type(mut self, operation_type: OperationTypeEnumFilterInput) -> Self {
		self.operation_type = Some(operation_type);
		self
	}
	pub fn set_expected_output_count(mut self, expected_output_count: IntegerFilterInput) -> Self {
		self.expected_output_count = Some(expected_output_count);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<SqlFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<SqlFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(integration_name) = &self.integration_name {
			query.push(SelectionSet {
				operation: "integrationName",
				alias: None,
				fields: Some(integration_name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(statement) = &self.statement {
			query.push(SelectionSet {
				operation: "statement",
				alias: None,
				fields: Some(statement.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(operation_type) = &self.operation_type {
			query.push(SelectionSet {
				operation: "operationType",
				alias: None,
				fields: Some(operation_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(expected_output_count) = &self.expected_output_count {
			query.push(SelectionSet {
				operation: "expectedOutputCount",
				alias: None,
				fields: Some(expected_output_count.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SqlInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "integrationName")]
	pub integration_name: String,
	#[serde(rename = "statement")]
	pub statement: String,
	#[serde(rename = "operationType")]
	pub operation_type: OperationTypeEnum,
	#[serde(rename = "expectedOutputCount")]
	pub expected_output_count: Option<i64>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SqlInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_integration_name(mut self, integration_name: String) -> Self {
		self.integration_name = integration_name;
		self
	}
	pub fn set_statement(mut self, statement: String) -> Self {
		self.statement = statement;
		self
	}
	pub fn set_operation_type(mut self, operation_type: OperationTypeEnum) -> Self {
		self.operation_type = operation_type;
		self
	}
	pub fn set_expected_output_count(mut self, expected_output_count: i64) -> Self {
		self.expected_output_count = Some(expected_output_count);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "integrationName",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "statement",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "operationType",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.expected_output_count.is_some() {
			query.push(SelectionSet {
				operation: "expectedOutputCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SqlOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "integrationName")]
	pub integration_name: Option<OrderByEnum>,
	#[serde(rename = "statement")]
	pub statement: Option<OrderByEnum>,
	#[serde(rename = "operationType")]
	pub operation_type: Option<OrderByEnum>,
	#[serde(rename = "parameters")]
	pub parameters: Option<OrderByEnum>,
	#[serde(rename = "expectedOutputCount")]
	pub expected_output_count: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl SqlOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_integration_name(mut self, integration_name: OrderByEnum) -> Self {
		self.integration_name = Some(integration_name);
		self
	}
	pub fn set_statement(mut self, statement: OrderByEnum) -> Self {
		self.statement = Some(statement);
		self
	}
	pub fn set_operation_type(mut self, operation_type: OrderByEnum) -> Self {
		self.operation_type = Some(operation_type);
		self
	}
	pub fn set_parameters(mut self, parameters: OrderByEnum) -> Self {
		self.parameters = Some(parameters);
		self
	}
	pub fn set_expected_output_count(mut self, expected_output_count: OrderByEnum) -> Self {
		self.expected_output_count = Some(expected_output_count);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.integration_name.is_some() {
			query.push(SelectionSet {
				operation: "integrationName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.statement.is_some() {
			query.push(SelectionSet {
				operation: "statement",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.operation_type.is_some() {
			query.push(SelectionSet {
				operation: "operationType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.parameters.is_some() {
			query.push(SelectionSet {
				operation: "parameters",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.expected_output_count.is_some() {
			query.push(SelectionSet {
				operation: "expectedOutputCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SqlUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "integrationName")]
	pub integration_name: Option<String>,
	#[serde(rename = "statement")]
	pub statement: Option<String>,
	#[serde(rename = "operationType")]
	pub operation_type: Option<OperationTypeEnum>,
	#[serde(rename = "expectedOutputCount")]
	pub expected_output_count: Option<i64>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SqlUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_integration_name(mut self, integration_name: String) -> Self {
		self.integration_name = Some(integration_name);
		self
	}
	pub fn set_statement(mut self, statement: String) -> Self {
		self.statement = Some(statement);
		self
	}
	pub fn set_operation_type(mut self, operation_type: OperationTypeEnum) -> Self {
		self.operation_type = Some(operation_type);
		self
	}
	pub fn set_expected_output_count(mut self, expected_output_count: i64) -> Self {
		self.expected_output_count = Some(expected_output_count);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.integration_name.is_some() {
			query.push(SelectionSet {
				operation: "integrationName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.statement.is_some() {
			query.push(SelectionSet {
				operation: "statement",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.operation_type.is_some() {
			query.push(SelectionSet {
				operation: "operationType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.expected_output_count.is_some() {
			query.push(SelectionSet {
				operation: "expectedOutputCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct StartWorkflowFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "name")]
	pub name: Option<StringFilterInput>,
	#[serde(rename = "version")]
	pub version: Option<IntegerFilterInput>,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<StringFilterInput>,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<StringFilterInput>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<IdempotencyStrategyEnumFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<StartWorkflowFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<StartWorkflowFilterInput>>>,
}
impl StartWorkflowFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_name(mut self, name: StringFilterInput) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_version(mut self, version: IntegerFilterInput) -> Self {
		self.version = Some(version);
		self
	}
	pub fn set_correlation_id(mut self, correlation_id: StringFilterInput) -> Self {
		self.correlation_id = Some(correlation_id);
		self
	}
	pub fn set_idempotency_key(mut self, idempotency_key: StringFilterInput) -> Self {
		self.idempotency_key = Some(idempotency_key);
		self
	}
	pub fn set_idempotency_strategy(
		mut self,
		idempotency_strategy: IdempotencyStrategyEnumFilterInput,
	) -> Self {
		self.idempotency_strategy = Some(idempotency_strategy);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<StartWorkflowFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<StartWorkflowFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(name) = &self.name {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: Some(name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(version) = &self.version {
			query.push(SelectionSet {
				operation: "version",
				alias: None,
				fields: Some(version.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(correlation_id) = &self.correlation_id {
			query.push(SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: Some(correlation_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(idempotency_key) = &self.idempotency_key {
			query.push(SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: Some(idempotency_key.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(idempotency_strategy) = &self.idempotency_strategy {
			query.push(SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: Some(idempotency_strategy.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct StartWorkflowInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "version")]
	pub version: Option<i64>,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<String>,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<String>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl StartWorkflowInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_name(mut self, name: String) -> Self {
		self.name = name;
		self
	}
	pub fn set_version(mut self, version: i64) -> Self {
		self.version = Some(version);
		self
	}
	pub fn set_correlation_id(mut self, correlation_id: String) -> Self {
		self.correlation_id = Some(correlation_id);
		self
	}
	pub fn set_idempotency_key(mut self, idempotency_key: String) -> Self {
		self.idempotency_key = Some(idempotency_key);
		self
	}
	pub fn set_idempotency_strategy(
		mut self,
		idempotency_strategy: IdempotencyStrategyEnum,
	) -> Self {
		self.idempotency_strategy = Some(idempotency_strategy);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "name",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.version.is_some() {
			query.push(SelectionSet {
				operation: "version",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.correlation_id.is_some() {
			query.push(SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.idempotency_key.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.idempotency_strategy.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct StartWorkflowOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "name")]
	pub name: Option<OrderByEnum>,
	#[serde(rename = "version")]
	pub version: Option<OrderByEnum>,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<OrderByEnum>,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<OrderByEnum>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl StartWorkflowOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_name(mut self, name: OrderByEnum) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_version(mut self, version: OrderByEnum) -> Self {
		self.version = Some(version);
		self
	}
	pub fn set_correlation_id(mut self, correlation_id: OrderByEnum) -> Self {
		self.correlation_id = Some(correlation_id);
		self
	}
	pub fn set_idempotency_key(mut self, idempotency_key: OrderByEnum) -> Self {
		self.idempotency_key = Some(idempotency_key);
		self
	}
	pub fn set_idempotency_strategy(mut self, idempotency_strategy: OrderByEnum) -> Self {
		self.idempotency_strategy = Some(idempotency_strategy);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.name.is_some() {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.version.is_some() {
			query.push(SelectionSet {
				operation: "version",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.correlation_id.is_some() {
			query.push(SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.idempotency_key.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.idempotency_strategy.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct StartWorkflowUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "name")]
	pub name: Option<String>,
	#[serde(rename = "version")]
	pub version: Option<i64>,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<String>,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<String>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl StartWorkflowUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_name(mut self, name: String) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_version(mut self, version: i64) -> Self {
		self.version = Some(version);
		self
	}
	pub fn set_correlation_id(mut self, correlation_id: String) -> Self {
		self.correlation_id = Some(correlation_id);
		self
	}
	pub fn set_idempotency_key(mut self, idempotency_key: String) -> Self {
		self.idempotency_key = Some(idempotency_key);
		self
	}
	pub fn set_idempotency_strategy(
		mut self,
		idempotency_strategy: IdempotencyStrategyEnum,
	) -> Self {
		self.idempotency_strategy = Some(idempotency_strategy);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.name.is_some() {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.version.is_some() {
			query.push(SelectionSet {
				operation: "version",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.correlation_id.is_some() {
			query.push(SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.idempotency_key.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.idempotency_strategy.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct StringFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<String>,
	#[serde(rename = "ne")]
	pub ne: Option<String>,
	#[serde(rename = "gt")]
	pub gt: Option<String>,
	#[serde(rename = "gte")]
	pub gte: Option<String>,
	#[serde(rename = "lt")]
	pub lt: Option<String>,
	#[serde(rename = "lte")]
	pub lte: Option<String>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<String>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<String>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<String>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<String>,
	#[serde(rename = "contains")]
	pub contains: Option<String>,
	#[serde(rename = "starts_with")]
	pub starts_with: Option<String>,
	#[serde(rename = "ends_with")]
	pub ends_with: Option<String>,
	#[serde(rename = "like")]
	pub like: Option<String>,
	#[serde(rename = "not_like")]
	pub not_like: Option<String>,
	#[serde(rename = "between")]
	pub between: Option<Vec<String>>,
	#[serde(rename = "not_between")]
	pub not_between: Option<Vec<String>>,
}
impl StringFilterInput {
	pub fn set_eq(mut self, eq: String) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: String) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: String) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: String) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: String) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: String) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<String>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<String>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: String) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: String) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn set_contains(mut self, contains: String) -> Self {
		self.contains = Some(contains);
		self
	}
	pub fn set_starts_with(mut self, starts_with: String) -> Self {
		self.starts_with = Some(starts_with);
		self
	}
	pub fn set_ends_with(mut self, ends_with: String) -> Self {
		self.ends_with = Some(ends_with);
		self
	}
	pub fn set_like(mut self, like: String) -> Self {
		self.like = Some(like);
		self
	}
	pub fn set_not_like(mut self, not_like: String) -> Self {
		self.not_like = Some(not_like);
		self
	}
	pub fn set_between(mut self, between: Vec<String>) -> Self {
		self.between = Some(between);
		self
	}
	pub fn set_not_between(mut self, not_between: Vec<String>) -> Self {
		self.not_between = Some(not_between);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.contains.is_some() {
			query.push(SelectionSet {
				operation: "contains",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.starts_with.is_some() {
			query.push(SelectionSet {
				operation: "starts_with",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ends_with.is_some() {
			query.push(SelectionSet {
				operation: "ends_with",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.like.is_some() {
			query.push(SelectionSet {
				operation: "like",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.not_like.is_some() {
			query.push(SelectionSet {
				operation: "not_like",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.between.is_some() {
			query.push(SelectionSet {
				operation: "between",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.not_between.is_some() {
			query.push(SelectionSet {
				operation: "not_between",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SubWorkflowFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "name")]
	pub name: Option<StringFilterInput>,
	#[serde(rename = "version")]
	pub version: Option<IntegerFilterInput>,
	#[serde(rename = "priority")]
	pub priority: Option<IntegerFilterInput>,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<StringFilterInput>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<IdempotencyStrategyEnumFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<SubWorkflowFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<SubWorkflowFilterInput>>>,
}
impl SubWorkflowFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_name(mut self, name: StringFilterInput) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_version(mut self, version: IntegerFilterInput) -> Self {
		self.version = Some(version);
		self
	}
	pub fn set_priority(mut self, priority: IntegerFilterInput) -> Self {
		self.priority = Some(priority);
		self
	}
	pub fn set_idempotency_key(mut self, idempotency_key: StringFilterInput) -> Self {
		self.idempotency_key = Some(idempotency_key);
		self
	}
	pub fn set_idempotency_strategy(
		mut self,
		idempotency_strategy: IdempotencyStrategyEnumFilterInput,
	) -> Self {
		self.idempotency_strategy = Some(idempotency_strategy);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<SubWorkflowFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<SubWorkflowFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(name) = &self.name {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: Some(name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(version) = &self.version {
			query.push(SelectionSet {
				operation: "version",
				alias: None,
				fields: Some(version.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(priority) = &self.priority {
			query.push(SelectionSet {
				operation: "priority",
				alias: None,
				fields: Some(priority.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(idempotency_key) = &self.idempotency_key {
			query.push(SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: Some(idempotency_key.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(idempotency_strategy) = &self.idempotency_strategy {
			query.push(SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: Some(idempotency_strategy.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SubWorkflowInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "version")]
	pub version: i64,
	#[serde(rename = "priority")]
	pub priority: i64,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<String>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SubWorkflowInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_name(mut self, name: String) -> Self {
		self.name = name;
		self
	}
	pub fn set_version(mut self, version: i64) -> Self {
		self.version = version;
		self
	}
	pub fn set_priority(mut self, priority: i64) -> Self {
		self.priority = priority;
		self
	}
	pub fn set_idempotency_key(mut self, idempotency_key: String) -> Self {
		self.idempotency_key = Some(idempotency_key);
		self
	}
	pub fn set_idempotency_strategy(
		mut self,
		idempotency_strategy: IdempotencyStrategyEnum,
	) -> Self {
		self.idempotency_strategy = Some(idempotency_strategy);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "name",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "version",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "priority",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.idempotency_key.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.idempotency_strategy.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SubWorkflowOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "name")]
	pub name: Option<OrderByEnum>,
	#[serde(rename = "version")]
	pub version: Option<OrderByEnum>,
	#[serde(rename = "taskToDomain")]
	pub task_to_domain: Option<OrderByEnum>,
	#[serde(rename = "priority")]
	pub priority: Option<OrderByEnum>,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<OrderByEnum>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl SubWorkflowOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_name(mut self, name: OrderByEnum) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_version(mut self, version: OrderByEnum) -> Self {
		self.version = Some(version);
		self
	}
	pub fn set_task_to_domain(mut self, task_to_domain: OrderByEnum) -> Self {
		self.task_to_domain = Some(task_to_domain);
		self
	}
	pub fn set_priority(mut self, priority: OrderByEnum) -> Self {
		self.priority = Some(priority);
		self
	}
	pub fn set_idempotency_key(mut self, idempotency_key: OrderByEnum) -> Self {
		self.idempotency_key = Some(idempotency_key);
		self
	}
	pub fn set_idempotency_strategy(mut self, idempotency_strategy: OrderByEnum) -> Self {
		self.idempotency_strategy = Some(idempotency_strategy);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.name.is_some() {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.version.is_some() {
			query.push(SelectionSet {
				operation: "version",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_to_domain.is_some() {
			query.push(SelectionSet {
				operation: "taskToDomain",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.priority.is_some() {
			query.push(SelectionSet {
				operation: "priority",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.idempotency_key.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.idempotency_strategy.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SubWorkflowUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "name")]
	pub name: Option<String>,
	#[serde(rename = "version")]
	pub version: Option<i64>,
	#[serde(rename = "priority")]
	pub priority: Option<i64>,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<String>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SubWorkflowUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_name(mut self, name: String) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_version(mut self, version: i64) -> Self {
		self.version = Some(version);
		self
	}
	pub fn set_priority(mut self, priority: i64) -> Self {
		self.priority = Some(priority);
		self
	}
	pub fn set_idempotency_key(mut self, idempotency_key: String) -> Self {
		self.idempotency_key = Some(idempotency_key);
		self
	}
	pub fn set_idempotency_strategy(
		mut self,
		idempotency_strategy: IdempotencyStrategyEnum,
	) -> Self {
		self.idempotency_strategy = Some(idempotency_strategy);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.name.is_some() {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.version.is_some() {
			query.push(SelectionSet {
				operation: "version",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.priority.is_some() {
			query.push(SelectionSet {
				operation: "priority",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.idempotency_key.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.idempotency_strategy.is_some() {
			query.push(SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SwitchFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<EvaluatorTypeEnumFilterInput>,
	#[serde(rename = "expression")]
	pub expression: Option<StringFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<SwitchFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<SwitchFilterInput>>>,
}
impl SwitchFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnumFilterInput) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_expression(mut self, expression: StringFilterInput) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<SwitchFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<SwitchFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(evaluator_type) = &self.evaluator_type {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: Some(evaluator_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(expression) = &self.expression {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: Some(expression.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SwitchInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: EvaluatorTypeEnum,
	#[serde(rename = "expression")]
	pub expression: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SwitchInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnum) -> Self {
		self.evaluator_type = evaluator_type;
		self
	}
	pub fn set_expression(mut self, expression: String) -> Self {
		self.expression = expression;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "evaluatorType",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "expression",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SwitchOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<OrderByEnum>,
	#[serde(rename = "expression")]
	pub expression: Option<OrderByEnum>,
	#[serde(rename = "decisionCases")]
	pub decision_cases: Option<OrderByEnum>,
	#[serde(rename = "defaultCase")]
	pub default_case: Option<OrderByEnum>,
	#[serde(rename = "taskIds")]
	pub task_ids: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl SwitchOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: OrderByEnum) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_expression(mut self, expression: OrderByEnum) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_decision_cases(mut self, decision_cases: OrderByEnum) -> Self {
		self.decision_cases = Some(decision_cases);
		self
	}
	pub fn set_default_case(mut self, default_case: OrderByEnum) -> Self {
		self.default_case = Some(default_case);
		self
	}
	pub fn set_task_ids(mut self, task_ids: OrderByEnum) -> Self {
		self.task_ids = Some(task_ids);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.evaluator_type.is_some() {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.expression.is_some() {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.decision_cases.is_some() {
			query.push(SelectionSet {
				operation: "decisionCases",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.default_case.is_some() {
			query.push(SelectionSet {
				operation: "defaultCase",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_ids.is_some() {
			query.push(SelectionSet {
				operation: "taskIds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SwitchUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<EvaluatorTypeEnum>,
	#[serde(rename = "expression")]
	pub expression: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SwitchUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnum) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_expression(mut self, expression: String) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.evaluator_type.is_some() {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.expression.is_some() {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskConfigFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "name")]
	pub name: Option<StringFilterInput>,
	#[serde(rename = "taskReferenceName")]
	pub task_reference_name: Option<StringFilterInput>,
	#[serde(rename = "taskType")]
	pub task_type: Option<TaskTypeEnumFilterInput>,
	#[serde(rename = "description")]
	pub description: Option<StringFilterInput>,
	#[serde(rename = "optional")]
	pub optional: Option<BooleanFilterInput>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<BooleanFilterInput>,
	#[serde(rename = "startDelay")]
	pub start_delay: Option<IntegerFilterInput>,
	#[serde(rename = "permissive")]
	pub permissive: Option<BooleanFilterInput>,
	#[serde(rename = "loopCondition")]
	pub loop_condition: Option<StringFilterInput>,
	#[serde(rename = "dynamicTaskNameParam")]
	pub dynamic_task_name_param: Option<StringFilterInput>,
	#[serde(rename = "dynamicForkTasksParam")]
	pub dynamic_fork_tasks_param: Option<StringFilterInput>,
	#[serde(rename = "dynamicForkTasksInputParamName")]
	pub dynamic_fork_tasks_input_param_name: Option<StringFilterInput>,
	#[serde(rename = "joinStatus")]
	pub join_status: Option<StringFilterInput>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<EvaluatorTypeEnumFilterInput>,
	#[serde(rename = "expression")]
	pub expression: Option<StringFilterInput>,
	#[serde(rename = "sink")]
	pub sink: Option<StringFilterInput>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: Option<BooleanFilterInput>,
	#[serde(rename = "scriptExpression")]
	pub script_expression: Option<StringFilterInput>,
	#[serde(rename = "taskDefinition")]
	pub task_definition: Option<StringFilterInput>,
	#[serde(rename = "rateLimited")]
	pub rate_limited: Option<BooleanFilterInput>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<IntegerFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<TaskConfigFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<TaskConfigFilterInput>>>,
}
impl TaskConfigFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_name(mut self, name: StringFilterInput) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_task_reference_name(mut self, task_reference_name: StringFilterInput) -> Self {
		self.task_reference_name = Some(task_reference_name);
		self
	}
	pub fn set_task_type(mut self, task_type: TaskTypeEnumFilterInput) -> Self {
		self.task_type = Some(task_type);
		self
	}
	pub fn set_description(mut self, description: StringFilterInput) -> Self {
		self.description = Some(description);
		self
	}
	pub fn set_optional(mut self, optional: BooleanFilterInput) -> Self {
		self.optional = Some(optional);
		self
	}
	pub fn set_async_complete(mut self, async_complete: BooleanFilterInput) -> Self {
		self.async_complete = Some(async_complete);
		self
	}
	pub fn set_start_delay(mut self, start_delay: IntegerFilterInput) -> Self {
		self.start_delay = Some(start_delay);
		self
	}
	pub fn set_permissive(mut self, permissive: BooleanFilterInput) -> Self {
		self.permissive = Some(permissive);
		self
	}
	pub fn set_loop_condition(mut self, loop_condition: StringFilterInput) -> Self {
		self.loop_condition = Some(loop_condition);
		self
	}
	pub fn set_dynamic_task_name_param(
		mut self,
		dynamic_task_name_param: StringFilterInput,
	) -> Self {
		self.dynamic_task_name_param = Some(dynamic_task_name_param);
		self
	}
	pub fn set_dynamic_fork_tasks_param(
		mut self,
		dynamic_fork_tasks_param: StringFilterInput,
	) -> Self {
		self.dynamic_fork_tasks_param = Some(dynamic_fork_tasks_param);
		self
	}
	pub fn set_dynamic_fork_tasks_input_param_name(
		mut self,
		dynamic_fork_tasks_input_param_name: StringFilterInput,
	) -> Self {
		self.dynamic_fork_tasks_input_param_name = Some(dynamic_fork_tasks_input_param_name);
		self
	}
	pub fn set_join_status(mut self, join_status: StringFilterInput) -> Self {
		self.join_status = Some(join_status);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnumFilterInput) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_expression(mut self, expression: StringFilterInput) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_sink(mut self, sink: StringFilterInput) -> Self {
		self.sink = Some(sink);
		self
	}
	pub fn set_trigger_failure_workflow(
		mut self,
		trigger_failure_workflow: BooleanFilterInput,
	) -> Self {
		self.trigger_failure_workflow = Some(trigger_failure_workflow);
		self
	}
	pub fn set_script_expression(mut self, script_expression: StringFilterInput) -> Self {
		self.script_expression = Some(script_expression);
		self
	}
	pub fn set_task_definition(mut self, task_definition: StringFilterInput) -> Self {
		self.task_definition = Some(task_definition);
		self
	}
	pub fn set_rate_limited(mut self, rate_limited: BooleanFilterInput) -> Self {
		self.rate_limited = Some(rate_limited);
		self
	}
	pub fn set_retry_count(mut self, retry_count: IntegerFilterInput) -> Self {
		self.retry_count = Some(retry_count);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<TaskConfigFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<TaskConfigFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(name) = &self.name {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: Some(name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_reference_name) = &self.task_reference_name {
			query.push(SelectionSet {
				operation: "taskReferenceName",
				alias: None,
				fields: Some(task_reference_name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_type) = &self.task_type {
			query.push(SelectionSet {
				operation: "taskType",
				alias: None,
				fields: Some(task_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(description) = &self.description {
			query.push(SelectionSet {
				operation: "description",
				alias: None,
				fields: Some(description.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(optional) = &self.optional {
			query.push(SelectionSet {
				operation: "optional",
				alias: None,
				fields: Some(optional.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(async_complete) = &self.async_complete {
			query.push(SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: Some(async_complete.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(start_delay) = &self.start_delay {
			query.push(SelectionSet {
				operation: "startDelay",
				alias: None,
				fields: Some(start_delay.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(permissive) = &self.permissive {
			query.push(SelectionSet {
				operation: "permissive",
				alias: None,
				fields: Some(permissive.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(loop_condition) = &self.loop_condition {
			query.push(SelectionSet {
				operation: "loopCondition",
				alias: None,
				fields: Some(loop_condition.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(dynamic_task_name_param) = &self.dynamic_task_name_param {
			query.push(SelectionSet {
				operation: "dynamicTaskNameParam",
				alias: None,
				fields: Some(dynamic_task_name_param.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(dynamic_fork_tasks_param) = &self.dynamic_fork_tasks_param {
			query.push(SelectionSet {
				operation: "dynamicForkTasksParam",
				alias: None,
				fields: Some(dynamic_fork_tasks_param.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(dynamic_fork_tasks_input_param_name) = &self.dynamic_fork_tasks_input_param_name
		{
			query.push(SelectionSet {
				operation: "dynamicForkTasksInputParamName",
				alias: None,
				fields: Some(dynamic_fork_tasks_input_param_name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(join_status) = &self.join_status {
			query.push(SelectionSet {
				operation: "joinStatus",
				alias: None,
				fields: Some(join_status.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(evaluator_type) = &self.evaluator_type {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: Some(evaluator_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(expression) = &self.expression {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: Some(expression.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(sink) = &self.sink {
			query.push(SelectionSet {
				operation: "sink",
				alias: None,
				fields: Some(sink.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(trigger_failure_workflow) = &self.trigger_failure_workflow {
			query.push(SelectionSet {
				operation: "triggerFailureWorkflow",
				alias: None,
				fields: Some(trigger_failure_workflow.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(script_expression) = &self.script_expression {
			query.push(SelectionSet {
				operation: "scriptExpression",
				alias: None,
				fields: Some(script_expression.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_definition) = &self.task_definition {
			query.push(SelectionSet {
				operation: "taskDefinition",
				alias: None,
				fields: Some(task_definition.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(rate_limited) = &self.rate_limited {
			query.push(SelectionSet {
				operation: "rateLimited",
				alias: None,
				fields: Some(rate_limited.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(retry_count) = &self.retry_count {
			query.push(SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: Some(retry_count.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskConfigInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "taskReferenceName")]
	pub task_reference_name: String,
	#[serde(rename = "taskType")]
	pub task_type: TaskTypeEnum,
	#[serde(rename = "description")]
	pub description: Option<String>,
	#[serde(rename = "optional")]
	pub optional: bool,
	#[serde(rename = "asyncComplete")]
	pub async_complete: bool,
	#[serde(rename = "startDelay")]
	pub start_delay: i64,
	#[serde(rename = "permissive")]
	pub permissive: bool,
	#[serde(rename = "loopCondition")]
	pub loop_condition: Option<String>,
	#[serde(rename = "dynamicTaskNameParam")]
	pub dynamic_task_name_param: Option<String>,
	#[serde(rename = "dynamicForkTasksParam")]
	pub dynamic_fork_tasks_param: Option<String>,
	#[serde(rename = "dynamicForkTasksInputParamName")]
	pub dynamic_fork_tasks_input_param_name: Option<String>,
	#[serde(rename = "joinStatus")]
	pub join_status: Option<String>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<EvaluatorTypeEnum>,
	#[serde(rename = "expression")]
	pub expression: Option<String>,
	#[serde(rename = "sink")]
	pub sink: Option<String>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: Option<bool>,
	#[serde(rename = "scriptExpression")]
	pub script_expression: Option<String>,
	#[serde(rename = "taskDefinition")]
	pub task_definition: Option<String>,
	#[serde(rename = "rateLimited")]
	pub rate_limited: Option<bool>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<i64>,
}
impl TaskConfigInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_name(mut self, name: String) -> Self {
		self.name = name;
		self
	}
	pub fn set_task_reference_name(mut self, task_reference_name: String) -> Self {
		self.task_reference_name = task_reference_name;
		self
	}
	pub fn set_task_type(mut self, task_type: TaskTypeEnum) -> Self {
		self.task_type = task_type;
		self
	}
	pub fn set_description(mut self, description: String) -> Self {
		self.description = Some(description);
		self
	}
	pub fn set_optional(mut self, optional: bool) -> Self {
		self.optional = optional;
		self
	}
	pub fn set_async_complete(mut self, async_complete: bool) -> Self {
		self.async_complete = async_complete;
		self
	}
	pub fn set_start_delay(mut self, start_delay: i64) -> Self {
		self.start_delay = start_delay;
		self
	}
	pub fn set_permissive(mut self, permissive: bool) -> Self {
		self.permissive = permissive;
		self
	}
	pub fn set_loop_condition(mut self, loop_condition: String) -> Self {
		self.loop_condition = Some(loop_condition);
		self
	}
	pub fn set_dynamic_task_name_param(mut self, dynamic_task_name_param: String) -> Self {
		self.dynamic_task_name_param = Some(dynamic_task_name_param);
		self
	}
	pub fn set_dynamic_fork_tasks_param(mut self, dynamic_fork_tasks_param: String) -> Self {
		self.dynamic_fork_tasks_param = Some(dynamic_fork_tasks_param);
		self
	}
	pub fn set_dynamic_fork_tasks_input_param_name(
		mut self,
		dynamic_fork_tasks_input_param_name: String,
	) -> Self {
		self.dynamic_fork_tasks_input_param_name = Some(dynamic_fork_tasks_input_param_name);
		self
	}
	pub fn set_join_status(mut self, join_status: String) -> Self {
		self.join_status = Some(join_status);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnum) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_expression(mut self, expression: String) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_sink(mut self, sink: String) -> Self {
		self.sink = Some(sink);
		self
	}
	pub fn set_trigger_failure_workflow(mut self, trigger_failure_workflow: bool) -> Self {
		self.trigger_failure_workflow = Some(trigger_failure_workflow);
		self
	}
	pub fn set_script_expression(mut self, script_expression: String) -> Self {
		self.script_expression = Some(script_expression);
		self
	}
	pub fn set_task_definition(mut self, task_definition: String) -> Self {
		self.task_definition = Some(task_definition);
		self
	}
	pub fn set_rate_limited(mut self, rate_limited: bool) -> Self {
		self.rate_limited = Some(rate_limited);
		self
	}
	pub fn set_retry_count(mut self, retry_count: i64) -> Self {
		self.retry_count = Some(retry_count);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "name",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "taskReferenceName",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "taskType",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.description.is_some() {
			query.push(SelectionSet {
				operation: "description",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "optional",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "asyncComplete",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "startDelay",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "permissive",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.loop_condition.is_some() {
			query.push(SelectionSet {
				operation: "loopCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_task_name_param.is_some() {
			query.push(SelectionSet {
				operation: "dynamicTaskNameParam",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_fork_tasks_param.is_some() {
			query.push(SelectionSet {
				operation: "dynamicForkTasksParam",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_fork_tasks_input_param_name.is_some() {
			query.push(SelectionSet {
				operation: "dynamicForkTasksInputParamName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.join_status.is_some() {
			query.push(SelectionSet {
				operation: "joinStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.evaluator_type.is_some() {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.expression.is_some() {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.sink.is_some() {
			query.push(SelectionSet {
				operation: "sink",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.trigger_failure_workflow.is_some() {
			query.push(SelectionSet {
				operation: "triggerFailureWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.script_expression.is_some() {
			query.push(SelectionSet {
				operation: "scriptExpression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_definition.is_some() {
			query.push(SelectionSet {
				operation: "taskDefinition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limited.is_some() {
			query.push(SelectionSet {
				operation: "rateLimited",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retry_count.is_some() {
			query.push(SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskConfigOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "name")]
	pub name: Option<OrderByEnum>,
	#[serde(rename = "taskReferenceName")]
	pub task_reference_name: Option<OrderByEnum>,
	#[serde(rename = "taskType")]
	pub task_type: Option<OrderByEnum>,
	#[serde(rename = "description")]
	pub description: Option<OrderByEnum>,
	#[serde(rename = "optional")]
	pub optional: Option<OrderByEnum>,
	#[serde(rename = "inputParameters")]
	pub input_parameters: Option<OrderByEnum>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<OrderByEnum>,
	#[serde(rename = "startDelay")]
	pub start_delay: Option<OrderByEnum>,
	#[serde(rename = "permissive")]
	pub permissive: Option<OrderByEnum>,
	#[serde(rename = "loopCondition")]
	pub loop_condition: Option<OrderByEnum>,
	#[serde(rename = "loopOver")]
	pub loop_over: Option<OrderByEnum>,
	#[serde(rename = "dynamicTaskNameParam")]
	pub dynamic_task_name_param: Option<OrderByEnum>,
	#[serde(rename = "dynamicForkTasksParam")]
	pub dynamic_fork_tasks_param: Option<OrderByEnum>,
	#[serde(rename = "dynamicForkTasksInputParamName")]
	pub dynamic_fork_tasks_input_param_name: Option<OrderByEnum>,
	#[serde(rename = "forkTasks")]
	pub fork_tasks: Option<OrderByEnum>,
	#[serde(rename = "joinOn")]
	pub join_on: Option<OrderByEnum>,
	#[serde(rename = "joinStatus")]
	pub join_status: Option<OrderByEnum>,
	#[serde(rename = "subWorkflowParam")]
	pub sub_workflow_param: Option<OrderByEnum>,
	#[serde(rename = "decisionCases")]
	pub decision_cases: Option<OrderByEnum>,
	#[serde(rename = "defaultCase")]
	pub default_case: Option<OrderByEnum>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<OrderByEnum>,
	#[serde(rename = "expression")]
	pub expression: Option<OrderByEnum>,
	#[serde(rename = "sink")]
	pub sink: Option<OrderByEnum>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: Option<OrderByEnum>,
	#[serde(rename = "scriptExpression")]
	pub script_expression: Option<OrderByEnum>,
	#[serde(rename = "taskDefinition")]
	pub task_definition: Option<OrderByEnum>,
	#[serde(rename = "rateLimited")]
	pub rate_limited: Option<OrderByEnum>,
	#[serde(rename = "defaultExclusiveJoinTask")]
	pub default_exclusive_join_task: Option<OrderByEnum>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<OrderByEnum>,
	#[serde(rename = "onStateChange")]
	pub on_state_change: Option<OrderByEnum>,
	#[serde(rename = "cacheConfig")]
	pub cache_config: Option<OrderByEnum>,
}
impl TaskConfigOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_name(mut self, name: OrderByEnum) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_task_reference_name(mut self, task_reference_name: OrderByEnum) -> Self {
		self.task_reference_name = Some(task_reference_name);
		self
	}
	pub fn set_task_type(mut self, task_type: OrderByEnum) -> Self {
		self.task_type = Some(task_type);
		self
	}
	pub fn set_description(mut self, description: OrderByEnum) -> Self {
		self.description = Some(description);
		self
	}
	pub fn set_optional(mut self, optional: OrderByEnum) -> Self {
		self.optional = Some(optional);
		self
	}
	pub fn set_input_parameters(mut self, input_parameters: OrderByEnum) -> Self {
		self.input_parameters = Some(input_parameters);
		self
	}
	pub fn set_async_complete(mut self, async_complete: OrderByEnum) -> Self {
		self.async_complete = Some(async_complete);
		self
	}
	pub fn set_start_delay(mut self, start_delay: OrderByEnum) -> Self {
		self.start_delay = Some(start_delay);
		self
	}
	pub fn set_permissive(mut self, permissive: OrderByEnum) -> Self {
		self.permissive = Some(permissive);
		self
	}
	pub fn set_loop_condition(mut self, loop_condition: OrderByEnum) -> Self {
		self.loop_condition = Some(loop_condition);
		self
	}
	pub fn set_loop_over(mut self, loop_over: OrderByEnum) -> Self {
		self.loop_over = Some(loop_over);
		self
	}
	pub fn set_dynamic_task_name_param(mut self, dynamic_task_name_param: OrderByEnum) -> Self {
		self.dynamic_task_name_param = Some(dynamic_task_name_param);
		self
	}
	pub fn set_dynamic_fork_tasks_param(mut self, dynamic_fork_tasks_param: OrderByEnum) -> Self {
		self.dynamic_fork_tasks_param = Some(dynamic_fork_tasks_param);
		self
	}
	pub fn set_dynamic_fork_tasks_input_param_name(
		mut self,
		dynamic_fork_tasks_input_param_name: OrderByEnum,
	) -> Self {
		self.dynamic_fork_tasks_input_param_name = Some(dynamic_fork_tasks_input_param_name);
		self
	}
	pub fn set_fork_tasks(mut self, fork_tasks: OrderByEnum) -> Self {
		self.fork_tasks = Some(fork_tasks);
		self
	}
	pub fn set_join_on(mut self, join_on: OrderByEnum) -> Self {
		self.join_on = Some(join_on);
		self
	}
	pub fn set_join_status(mut self, join_status: OrderByEnum) -> Self {
		self.join_status = Some(join_status);
		self
	}
	pub fn set_sub_workflow_param(mut self, sub_workflow_param: OrderByEnum) -> Self {
		self.sub_workflow_param = Some(sub_workflow_param);
		self
	}
	pub fn set_decision_cases(mut self, decision_cases: OrderByEnum) -> Self {
		self.decision_cases = Some(decision_cases);
		self
	}
	pub fn set_default_case(mut self, default_case: OrderByEnum) -> Self {
		self.default_case = Some(default_case);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: OrderByEnum) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_expression(mut self, expression: OrderByEnum) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_sink(mut self, sink: OrderByEnum) -> Self {
		self.sink = Some(sink);
		self
	}
	pub fn set_trigger_failure_workflow(mut self, trigger_failure_workflow: OrderByEnum) -> Self {
		self.trigger_failure_workflow = Some(trigger_failure_workflow);
		self
	}
	pub fn set_script_expression(mut self, script_expression: OrderByEnum) -> Self {
		self.script_expression = Some(script_expression);
		self
	}
	pub fn set_task_definition(mut self, task_definition: OrderByEnum) -> Self {
		self.task_definition = Some(task_definition);
		self
	}
	pub fn set_rate_limited(mut self, rate_limited: OrderByEnum) -> Self {
		self.rate_limited = Some(rate_limited);
		self
	}
	pub fn set_default_exclusive_join_task(
		mut self,
		default_exclusive_join_task: OrderByEnum,
	) -> Self {
		self.default_exclusive_join_task = Some(default_exclusive_join_task);
		self
	}
	pub fn set_retry_count(mut self, retry_count: OrderByEnum) -> Self {
		self.retry_count = Some(retry_count);
		self
	}
	pub fn set_on_state_change(mut self, on_state_change: OrderByEnum) -> Self {
		self.on_state_change = Some(on_state_change);
		self
	}
	pub fn set_cache_config(mut self, cache_config: OrderByEnum) -> Self {
		self.cache_config = Some(cache_config);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.name.is_some() {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_reference_name.is_some() {
			query.push(SelectionSet {
				operation: "taskReferenceName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_type.is_some() {
			query.push(SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.description.is_some() {
			query.push(SelectionSet {
				operation: "description",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.optional.is_some() {
			query.push(SelectionSet {
				operation: "optional",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.input_parameters.is_some() {
			query.push(SelectionSet {
				operation: "inputParameters",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.async_complete.is_some() {
			query.push(SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.start_delay.is_some() {
			query.push(SelectionSet {
				operation: "startDelay",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.permissive.is_some() {
			query.push(SelectionSet {
				operation: "permissive",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.loop_condition.is_some() {
			query.push(SelectionSet {
				operation: "loopCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.loop_over.is_some() {
			query.push(SelectionSet {
				operation: "loopOver",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_task_name_param.is_some() {
			query.push(SelectionSet {
				operation: "dynamicTaskNameParam",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_fork_tasks_param.is_some() {
			query.push(SelectionSet {
				operation: "dynamicForkTasksParam",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_fork_tasks_input_param_name.is_some() {
			query.push(SelectionSet {
				operation: "dynamicForkTasksInputParamName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.fork_tasks.is_some() {
			query.push(SelectionSet {
				operation: "forkTasks",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.join_on.is_some() {
			query.push(SelectionSet {
				operation: "joinOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.join_status.is_some() {
			query.push(SelectionSet {
				operation: "joinStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.sub_workflow_param.is_some() {
			query.push(SelectionSet {
				operation: "subWorkflowParam",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.decision_cases.is_some() {
			query.push(SelectionSet {
				operation: "decisionCases",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.default_case.is_some() {
			query.push(SelectionSet {
				operation: "defaultCase",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.evaluator_type.is_some() {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.expression.is_some() {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.sink.is_some() {
			query.push(SelectionSet {
				operation: "sink",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.trigger_failure_workflow.is_some() {
			query.push(SelectionSet {
				operation: "triggerFailureWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.script_expression.is_some() {
			query.push(SelectionSet {
				operation: "scriptExpression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_definition.is_some() {
			query.push(SelectionSet {
				operation: "taskDefinition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limited.is_some() {
			query.push(SelectionSet {
				operation: "rateLimited",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.default_exclusive_join_task.is_some() {
			query.push(SelectionSet {
				operation: "defaultExclusiveJoinTask",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retry_count.is_some() {
			query.push(SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.on_state_change.is_some() {
			query.push(SelectionSet {
				operation: "onStateChange",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.cache_config.is_some() {
			query.push(SelectionSet {
				operation: "cacheConfig",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskConfigUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "name")]
	pub name: Option<String>,
	#[serde(rename = "taskReferenceName")]
	pub task_reference_name: Option<String>,
	#[serde(rename = "taskType")]
	pub task_type: Option<TaskTypeEnum>,
	#[serde(rename = "description")]
	pub description: Option<String>,
	#[serde(rename = "optional")]
	pub optional: Option<bool>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<bool>,
	#[serde(rename = "startDelay")]
	pub start_delay: Option<i64>,
	#[serde(rename = "permissive")]
	pub permissive: Option<bool>,
	#[serde(rename = "loopCondition")]
	pub loop_condition: Option<String>,
	#[serde(rename = "dynamicTaskNameParam")]
	pub dynamic_task_name_param: Option<String>,
	#[serde(rename = "dynamicForkTasksParam")]
	pub dynamic_fork_tasks_param: Option<String>,
	#[serde(rename = "dynamicForkTasksInputParamName")]
	pub dynamic_fork_tasks_input_param_name: Option<String>,
	#[serde(rename = "joinStatus")]
	pub join_status: Option<String>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<EvaluatorTypeEnum>,
	#[serde(rename = "expression")]
	pub expression: Option<String>,
	#[serde(rename = "sink")]
	pub sink: Option<String>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: Option<bool>,
	#[serde(rename = "scriptExpression")]
	pub script_expression: Option<String>,
	#[serde(rename = "taskDefinition")]
	pub task_definition: Option<String>,
	#[serde(rename = "rateLimited")]
	pub rate_limited: Option<bool>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<i64>,
}
impl TaskConfigUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_name(mut self, name: String) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_task_reference_name(mut self, task_reference_name: String) -> Self {
		self.task_reference_name = Some(task_reference_name);
		self
	}
	pub fn set_task_type(mut self, task_type: TaskTypeEnum) -> Self {
		self.task_type = Some(task_type);
		self
	}
	pub fn set_description(mut self, description: String) -> Self {
		self.description = Some(description);
		self
	}
	pub fn set_optional(mut self, optional: bool) -> Self {
		self.optional = Some(optional);
		self
	}
	pub fn set_async_complete(mut self, async_complete: bool) -> Self {
		self.async_complete = Some(async_complete);
		self
	}
	pub fn set_start_delay(mut self, start_delay: i64) -> Self {
		self.start_delay = Some(start_delay);
		self
	}
	pub fn set_permissive(mut self, permissive: bool) -> Self {
		self.permissive = Some(permissive);
		self
	}
	pub fn set_loop_condition(mut self, loop_condition: String) -> Self {
		self.loop_condition = Some(loop_condition);
		self
	}
	pub fn set_dynamic_task_name_param(mut self, dynamic_task_name_param: String) -> Self {
		self.dynamic_task_name_param = Some(dynamic_task_name_param);
		self
	}
	pub fn set_dynamic_fork_tasks_param(mut self, dynamic_fork_tasks_param: String) -> Self {
		self.dynamic_fork_tasks_param = Some(dynamic_fork_tasks_param);
		self
	}
	pub fn set_dynamic_fork_tasks_input_param_name(
		mut self,
		dynamic_fork_tasks_input_param_name: String,
	) -> Self {
		self.dynamic_fork_tasks_input_param_name = Some(dynamic_fork_tasks_input_param_name);
		self
	}
	pub fn set_join_status(mut self, join_status: String) -> Self {
		self.join_status = Some(join_status);
		self
	}
	pub fn set_evaluator_type(mut self, evaluator_type: EvaluatorTypeEnum) -> Self {
		self.evaluator_type = Some(evaluator_type);
		self
	}
	pub fn set_expression(mut self, expression: String) -> Self {
		self.expression = Some(expression);
		self
	}
	pub fn set_sink(mut self, sink: String) -> Self {
		self.sink = Some(sink);
		self
	}
	pub fn set_trigger_failure_workflow(mut self, trigger_failure_workflow: bool) -> Self {
		self.trigger_failure_workflow = Some(trigger_failure_workflow);
		self
	}
	pub fn set_script_expression(mut self, script_expression: String) -> Self {
		self.script_expression = Some(script_expression);
		self
	}
	pub fn set_task_definition(mut self, task_definition: String) -> Self {
		self.task_definition = Some(task_definition);
		self
	}
	pub fn set_rate_limited(mut self, rate_limited: bool) -> Self {
		self.rate_limited = Some(rate_limited);
		self
	}
	pub fn set_retry_count(mut self, retry_count: i64) -> Self {
		self.retry_count = Some(retry_count);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.name.is_some() {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_reference_name.is_some() {
			query.push(SelectionSet {
				operation: "taskReferenceName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_type.is_some() {
			query.push(SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.description.is_some() {
			query.push(SelectionSet {
				operation: "description",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.optional.is_some() {
			query.push(SelectionSet {
				operation: "optional",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.async_complete.is_some() {
			query.push(SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.start_delay.is_some() {
			query.push(SelectionSet {
				operation: "startDelay",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.permissive.is_some() {
			query.push(SelectionSet {
				operation: "permissive",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.loop_condition.is_some() {
			query.push(SelectionSet {
				operation: "loopCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_task_name_param.is_some() {
			query.push(SelectionSet {
				operation: "dynamicTaskNameParam",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_fork_tasks_param.is_some() {
			query.push(SelectionSet {
				operation: "dynamicForkTasksParam",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.dynamic_fork_tasks_input_param_name.is_some() {
			query.push(SelectionSet {
				operation: "dynamicForkTasksInputParamName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.join_status.is_some() {
			query.push(SelectionSet {
				operation: "joinStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.evaluator_type.is_some() {
			query.push(SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.expression.is_some() {
			query.push(SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.sink.is_some() {
			query.push(SelectionSet {
				operation: "sink",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.trigger_failure_workflow.is_some() {
			query.push(SelectionSet {
				operation: "triggerFailureWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.script_expression.is_some() {
			query.push(SelectionSet {
				operation: "scriptExpression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_definition.is_some() {
			query.push(SelectionSet {
				operation: "taskDefinition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limited.is_some() {
			query.push(SelectionSet {
				operation: "rateLimited",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retry_count.is_some() {
			query.push(SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskDefinitionFilterInput {
	#[serde(rename = "name")]
	pub name: Option<StringFilterInput>,
	#[serde(rename = "description")]
	pub description: Option<StringFilterInput>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<IntegerFilterInput>,
	#[serde(rename = "timeoutSeconds")]
	pub timeout_seconds: Option<IntegerFilterInput>,
	#[serde(rename = "timeoutPolicy")]
	pub timeout_policy: Option<TimeoutPolicyEnumFilterInput>,
	#[serde(rename = "retryLogic")]
	pub retry_logic: Option<RetryLogicEnumFilterInput>,
	#[serde(rename = "retryDelaySeconds")]
	pub retry_delay_seconds: Option<IntegerFilterInput>,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: Option<IntegerFilterInput>,
	#[serde(rename = "concurrentExecLimit")]
	pub concurrent_exec_limit: Option<IntegerFilterInput>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<IntegerFilterInput>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<IntegerFilterInput>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<StringFilterInput>,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<StringFilterInput>,
	#[serde(rename = "ownerEmail")]
	pub owner_email: Option<StringFilterInput>,
	#[serde(rename = "pollTimeoutSeconds")]
	pub poll_timeout_seconds: Option<IntegerFilterInput>,
	#[serde(rename = "backoffScaleFactor")]
	pub backoff_scale_factor: Option<IntegerFilterInput>,
	#[serde(rename = "baseType")]
	pub base_type: Option<StringFilterInput>,
	#[serde(rename = "enforceSchema")]
	pub enforce_schema: Option<BooleanFilterInput>,
	#[serde(rename = "createdOn")]
	pub created_on: Option<TextFilterInput>,
	#[serde(rename = "createdBy")]
	pub created_by: Option<StringFilterInput>,
	#[serde(rename = "modifiedOn")]
	pub modified_on: Option<TextFilterInput>,
	#[serde(rename = "modifiedBy")]
	pub modified_by: Option<StringFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<TaskDefinitionFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<TaskDefinitionFilterInput>>>,
}
impl TaskDefinitionFilterInput {
	pub fn set_name(mut self, name: StringFilterInput) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_description(mut self, description: StringFilterInput) -> Self {
		self.description = Some(description);
		self
	}
	pub fn set_retry_count(mut self, retry_count: IntegerFilterInput) -> Self {
		self.retry_count = Some(retry_count);
		self
	}
	pub fn set_timeout_seconds(mut self, timeout_seconds: IntegerFilterInput) -> Self {
		self.timeout_seconds = Some(timeout_seconds);
		self
	}
	pub fn set_timeout_policy(mut self, timeout_policy: TimeoutPolicyEnumFilterInput) -> Self {
		self.timeout_policy = Some(timeout_policy);
		self
	}
	pub fn set_retry_logic(mut self, retry_logic: RetryLogicEnumFilterInput) -> Self {
		self.retry_logic = Some(retry_logic);
		self
	}
	pub fn set_retry_delay_seconds(mut self, retry_delay_seconds: IntegerFilterInput) -> Self {
		self.retry_delay_seconds = Some(retry_delay_seconds);
		self
	}
	pub fn set_response_timeout_seconds(
		mut self,
		response_timeout_seconds: IntegerFilterInput,
	) -> Self {
		self.response_timeout_seconds = Some(response_timeout_seconds);
		self
	}
	pub fn set_concurrent_exec_limit(mut self, concurrent_exec_limit: IntegerFilterInput) -> Self {
		self.concurrent_exec_limit = Some(concurrent_exec_limit);
		self
	}
	pub fn set_rate_limit_per_frequency(
		mut self,
		rate_limit_per_frequency: IntegerFilterInput,
	) -> Self {
		self.rate_limit_per_frequency = Some(rate_limit_per_frequency);
		self
	}
	pub fn set_rate_limit_frequency_in_seconds(
		mut self,
		rate_limit_frequency_in_seconds: IntegerFilterInput,
	) -> Self {
		self.rate_limit_frequency_in_seconds = Some(rate_limit_frequency_in_seconds);
		self
	}
	pub fn set_isolation_group_id(mut self, isolation_group_id: StringFilterInput) -> Self {
		self.isolation_group_id = Some(isolation_group_id);
		self
	}
	pub fn set_execution_name_space(mut self, execution_name_space: StringFilterInput) -> Self {
		self.execution_name_space = Some(execution_name_space);
		self
	}
	pub fn set_owner_email(mut self, owner_email: StringFilterInput) -> Self {
		self.owner_email = Some(owner_email);
		self
	}
	pub fn set_poll_timeout_seconds(mut self, poll_timeout_seconds: IntegerFilterInput) -> Self {
		self.poll_timeout_seconds = Some(poll_timeout_seconds);
		self
	}
	pub fn set_backoff_scale_factor(mut self, backoff_scale_factor: IntegerFilterInput) -> Self {
		self.backoff_scale_factor = Some(backoff_scale_factor);
		self
	}
	pub fn set_base_type(mut self, base_type: StringFilterInput) -> Self {
		self.base_type = Some(base_type);
		self
	}
	pub fn set_enforce_schema(mut self, enforce_schema: BooleanFilterInput) -> Self {
		self.enforce_schema = Some(enforce_schema);
		self
	}
	pub fn set_created_on(mut self, created_on: TextFilterInput) -> Self {
		self.created_on = Some(created_on);
		self
	}
	pub fn set_created_by(mut self, created_by: StringFilterInput) -> Self {
		self.created_by = Some(created_by);
		self
	}
	pub fn set_modified_on(mut self, modified_on: TextFilterInput) -> Self {
		self.modified_on = Some(modified_on);
		self
	}
	pub fn set_modified_by(mut self, modified_by: StringFilterInput) -> Self {
		self.modified_by = Some(modified_by);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<TaskDefinitionFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<TaskDefinitionFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(name) = &self.name {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: Some(name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(description) = &self.description {
			query.push(SelectionSet {
				operation: "description",
				alias: None,
				fields: Some(description.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(retry_count) = &self.retry_count {
			query.push(SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: Some(retry_count.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(timeout_seconds) = &self.timeout_seconds {
			query.push(SelectionSet {
				operation: "timeoutSeconds",
				alias: None,
				fields: Some(timeout_seconds.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(timeout_policy) = &self.timeout_policy {
			query.push(SelectionSet {
				operation: "timeoutPolicy",
				alias: None,
				fields: Some(timeout_policy.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(retry_logic) = &self.retry_logic {
			query.push(SelectionSet {
				operation: "retryLogic",
				alias: None,
				fields: Some(retry_logic.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(retry_delay_seconds) = &self.retry_delay_seconds {
			query.push(SelectionSet {
				operation: "retryDelaySeconds",
				alias: None,
				fields: Some(retry_delay_seconds.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(response_timeout_seconds) = &self.response_timeout_seconds {
			query.push(SelectionSet {
				operation: "responseTimeoutSeconds",
				alias: None,
				fields: Some(response_timeout_seconds.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(concurrent_exec_limit) = &self.concurrent_exec_limit {
			query.push(SelectionSet {
				operation: "concurrentExecLimit",
				alias: None,
				fields: Some(concurrent_exec_limit.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(rate_limit_per_frequency) = &self.rate_limit_per_frequency {
			query.push(SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: Some(rate_limit_per_frequency.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(rate_limit_frequency_in_seconds) = &self.rate_limit_frequency_in_seconds {
			query.push(SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: Some(rate_limit_frequency_in_seconds.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(isolation_group_id) = &self.isolation_group_id {
			query.push(SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: Some(isolation_group_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(execution_name_space) = &self.execution_name_space {
			query.push(SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: Some(execution_name_space.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(owner_email) = &self.owner_email {
			query.push(SelectionSet {
				operation: "ownerEmail",
				alias: None,
				fields: Some(owner_email.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(poll_timeout_seconds) = &self.poll_timeout_seconds {
			query.push(SelectionSet {
				operation: "pollTimeoutSeconds",
				alias: None,
				fields: Some(poll_timeout_seconds.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(backoff_scale_factor) = &self.backoff_scale_factor {
			query.push(SelectionSet {
				operation: "backoffScaleFactor",
				alias: None,
				fields: Some(backoff_scale_factor.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(base_type) = &self.base_type {
			query.push(SelectionSet {
				operation: "baseType",
				alias: None,
				fields: Some(base_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(enforce_schema) = &self.enforce_schema {
			query.push(SelectionSet {
				operation: "enforceSchema",
				alias: None,
				fields: Some(enforce_schema.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(created_on) = &self.created_on {
			query.push(SelectionSet {
				operation: "createdOn",
				alias: None,
				fields: Some(created_on.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(created_by) = &self.created_by {
			query.push(SelectionSet {
				operation: "createdBy",
				alias: None,
				fields: Some(created_by.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(modified_on) = &self.modified_on {
			query.push(SelectionSet {
				operation: "modifiedOn",
				alias: None,
				fields: Some(modified_on.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(modified_by) = &self.modified_by {
			query.push(SelectionSet {
				operation: "modifiedBy",
				alias: None,
				fields: Some(modified_by.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskDefinitionInsertInput {
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "description")]
	pub description: Option<String>,
	#[serde(rename = "retryCount")]
	pub retry_count: i64,
	#[serde(rename = "timeoutSeconds")]
	pub timeout_seconds: Option<i64>,
	#[serde(rename = "timeoutPolicy")]
	pub timeout_policy: TimeoutPolicyEnum,
	#[serde(rename = "retryLogic")]
	pub retry_logic: RetryLogicEnum,
	#[serde(rename = "retryDelaySeconds")]
	pub retry_delay_seconds: i64,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: i64,
	#[serde(rename = "concurrentExecLimit")]
	pub concurrent_exec_limit: Option<i64>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<i64>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<i64>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<String>,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<String>,
	#[serde(rename = "ownerEmail")]
	pub owner_email: Option<String>,
	#[serde(rename = "pollTimeoutSeconds")]
	pub poll_timeout_seconds: Option<i64>,
	#[serde(rename = "backoffScaleFactor")]
	pub backoff_scale_factor: i64,
	#[serde(rename = "baseType")]
	pub base_type: Option<String>,
	#[serde(rename = "enforceSchema")]
	pub enforce_schema: bool,
	#[serde(rename = "createdOn")]
	pub created_on: String,
	#[serde(rename = "createdBy")]
	pub created_by: Option<String>,
	#[serde(rename = "modifiedOn")]
	pub modified_on: String,
	#[serde(rename = "modifiedBy")]
	pub modified_by: Option<String>,
}
impl TaskDefinitionInsertInput {
	pub fn set_name(mut self, name: String) -> Self {
		self.name = name;
		self
	}
	pub fn set_description(mut self, description: String) -> Self {
		self.description = Some(description);
		self
	}
	pub fn set_retry_count(mut self, retry_count: i64) -> Self {
		self.retry_count = retry_count;
		self
	}
	pub fn set_timeout_seconds(mut self, timeout_seconds: i64) -> Self {
		self.timeout_seconds = Some(timeout_seconds);
		self
	}
	pub fn set_timeout_policy(mut self, timeout_policy: TimeoutPolicyEnum) -> Self {
		self.timeout_policy = timeout_policy;
		self
	}
	pub fn set_retry_logic(mut self, retry_logic: RetryLogicEnum) -> Self {
		self.retry_logic = retry_logic;
		self
	}
	pub fn set_retry_delay_seconds(mut self, retry_delay_seconds: i64) -> Self {
		self.retry_delay_seconds = retry_delay_seconds;
		self
	}
	pub fn set_response_timeout_seconds(mut self, response_timeout_seconds: i64) -> Self {
		self.response_timeout_seconds = response_timeout_seconds;
		self
	}
	pub fn set_concurrent_exec_limit(mut self, concurrent_exec_limit: i64) -> Self {
		self.concurrent_exec_limit = Some(concurrent_exec_limit);
		self
	}
	pub fn set_rate_limit_per_frequency(mut self, rate_limit_per_frequency: i64) -> Self {
		self.rate_limit_per_frequency = Some(rate_limit_per_frequency);
		self
	}
	pub fn set_rate_limit_frequency_in_seconds(
		mut self,
		rate_limit_frequency_in_seconds: i64,
	) -> Self {
		self.rate_limit_frequency_in_seconds = Some(rate_limit_frequency_in_seconds);
		self
	}
	pub fn set_isolation_group_id(mut self, isolation_group_id: String) -> Self {
		self.isolation_group_id = Some(isolation_group_id);
		self
	}
	pub fn set_execution_name_space(mut self, execution_name_space: String) -> Self {
		self.execution_name_space = Some(execution_name_space);
		self
	}
	pub fn set_owner_email(mut self, owner_email: String) -> Self {
		self.owner_email = Some(owner_email);
		self
	}
	pub fn set_poll_timeout_seconds(mut self, poll_timeout_seconds: i64) -> Self {
		self.poll_timeout_seconds = Some(poll_timeout_seconds);
		self
	}
	pub fn set_backoff_scale_factor(mut self, backoff_scale_factor: i64) -> Self {
		self.backoff_scale_factor = backoff_scale_factor;
		self
	}
	pub fn set_base_type(mut self, base_type: String) -> Self {
		self.base_type = Some(base_type);
		self
	}
	pub fn set_enforce_schema(mut self, enforce_schema: bool) -> Self {
		self.enforce_schema = enforce_schema;
		self
	}
	pub fn set_created_on(mut self, created_on: String) -> Self {
		self.created_on = created_on;
		self
	}
	pub fn set_created_by(mut self, created_by: String) -> Self {
		self.created_by = Some(created_by);
		self
	}
	pub fn set_modified_on(mut self, modified_on: String) -> Self {
		self.modified_on = modified_on;
		self
	}
	pub fn set_modified_by(mut self, modified_by: String) -> Self {
		self.modified_by = Some(modified_by);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "name",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.description.is_some() {
			query.push(SelectionSet {
				operation: "description",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "retryCount",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.timeout_seconds.is_some() {
			query.push(SelectionSet {
				operation: "timeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "timeoutPolicy",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "retryLogic",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "retryDelaySeconds",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "responseTimeoutSeconds",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.concurrent_exec_limit.is_some() {
			query.push(SelectionSet {
				operation: "concurrentExecLimit",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_per_frequency.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_frequency_in_seconds.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.isolation_group_id.is_some() {
			query.push(SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.execution_name_space.is_some() {
			query.push(SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.owner_email.is_some() {
			query.push(SelectionSet {
				operation: "ownerEmail",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.poll_timeout_seconds.is_some() {
			query.push(SelectionSet {
				operation: "pollTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "backoffScaleFactor",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.base_type.is_some() {
			query.push(SelectionSet {
				operation: "baseType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "enforceSchema",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "createdOn",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.created_by.is_some() {
			query.push(SelectionSet {
				operation: "createdBy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "modifiedOn",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.modified_by.is_some() {
			query.push(SelectionSet {
				operation: "modifiedBy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskDefinitionOrderInput {
	#[serde(rename = "name")]
	pub name: Option<OrderByEnum>,
	#[serde(rename = "description")]
	pub description: Option<OrderByEnum>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<OrderByEnum>,
	#[serde(rename = "timeoutSeconds")]
	pub timeout_seconds: Option<OrderByEnum>,
	#[serde(rename = "inputKeys")]
	pub input_keys: Option<OrderByEnum>,
	#[serde(rename = "outputKeys")]
	pub output_keys: Option<OrderByEnum>,
	#[serde(rename = "timeoutPolicy")]
	pub timeout_policy: Option<OrderByEnum>,
	#[serde(rename = "retryLogic")]
	pub retry_logic: Option<OrderByEnum>,
	#[serde(rename = "retryDelaySeconds")]
	pub retry_delay_seconds: Option<OrderByEnum>,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: Option<OrderByEnum>,
	#[serde(rename = "concurrentExecLimit")]
	pub concurrent_exec_limit: Option<OrderByEnum>,
	#[serde(rename = "inputTemplate")]
	pub input_template: Option<OrderByEnum>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<OrderByEnum>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<OrderByEnum>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<OrderByEnum>,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<OrderByEnum>,
	#[serde(rename = "ownerEmail")]
	pub owner_email: Option<OrderByEnum>,
	#[serde(rename = "pollTimeoutSeconds")]
	pub poll_timeout_seconds: Option<OrderByEnum>,
	#[serde(rename = "backoffScaleFactor")]
	pub backoff_scale_factor: Option<OrderByEnum>,
	#[serde(rename = "baseType")]
	pub base_type: Option<OrderByEnum>,
	#[serde(rename = "inputSchema")]
	pub input_schema: Option<OrderByEnum>,
	#[serde(rename = "enforceSchema")]
	pub enforce_schema: Option<OrderByEnum>,
	#[serde(rename = "outputSchema")]
	pub output_schema: Option<OrderByEnum>,
	#[serde(rename = "createdOn")]
	pub created_on: Option<OrderByEnum>,
	#[serde(rename = "createdBy")]
	pub created_by: Option<OrderByEnum>,
	#[serde(rename = "modifiedOn")]
	pub modified_on: Option<OrderByEnum>,
	#[serde(rename = "modifiedBy")]
	pub modified_by: Option<OrderByEnum>,
}
impl TaskDefinitionOrderInput {
	pub fn set_name(mut self, name: OrderByEnum) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_description(mut self, description: OrderByEnum) -> Self {
		self.description = Some(description);
		self
	}
	pub fn set_retry_count(mut self, retry_count: OrderByEnum) -> Self {
		self.retry_count = Some(retry_count);
		self
	}
	pub fn set_timeout_seconds(mut self, timeout_seconds: OrderByEnum) -> Self {
		self.timeout_seconds = Some(timeout_seconds);
		self
	}
	pub fn set_input_keys(mut self, input_keys: OrderByEnum) -> Self {
		self.input_keys = Some(input_keys);
		self
	}
	pub fn set_output_keys(mut self, output_keys: OrderByEnum) -> Self {
		self.output_keys = Some(output_keys);
		self
	}
	pub fn set_timeout_policy(mut self, timeout_policy: OrderByEnum) -> Self {
		self.timeout_policy = Some(timeout_policy);
		self
	}
	pub fn set_retry_logic(mut self, retry_logic: OrderByEnum) -> Self {
		self.retry_logic = Some(retry_logic);
		self
	}
	pub fn set_retry_delay_seconds(mut self, retry_delay_seconds: OrderByEnum) -> Self {
		self.retry_delay_seconds = Some(retry_delay_seconds);
		self
	}
	pub fn set_response_timeout_seconds(mut self, response_timeout_seconds: OrderByEnum) -> Self {
		self.response_timeout_seconds = Some(response_timeout_seconds);
		self
	}
	pub fn set_concurrent_exec_limit(mut self, concurrent_exec_limit: OrderByEnum) -> Self {
		self.concurrent_exec_limit = Some(concurrent_exec_limit);
		self
	}
	pub fn set_input_template(mut self, input_template: OrderByEnum) -> Self {
		self.input_template = Some(input_template);
		self
	}
	pub fn set_rate_limit_per_frequency(mut self, rate_limit_per_frequency: OrderByEnum) -> Self {
		self.rate_limit_per_frequency = Some(rate_limit_per_frequency);
		self
	}
	pub fn set_rate_limit_frequency_in_seconds(
		mut self,
		rate_limit_frequency_in_seconds: OrderByEnum,
	) -> Self {
		self.rate_limit_frequency_in_seconds = Some(rate_limit_frequency_in_seconds);
		self
	}
	pub fn set_isolation_group_id(mut self, isolation_group_id: OrderByEnum) -> Self {
		self.isolation_group_id = Some(isolation_group_id);
		self
	}
	pub fn set_execution_name_space(mut self, execution_name_space: OrderByEnum) -> Self {
		self.execution_name_space = Some(execution_name_space);
		self
	}
	pub fn set_owner_email(mut self, owner_email: OrderByEnum) -> Self {
		self.owner_email = Some(owner_email);
		self
	}
	pub fn set_poll_timeout_seconds(mut self, poll_timeout_seconds: OrderByEnum) -> Self {
		self.poll_timeout_seconds = Some(poll_timeout_seconds);
		self
	}
	pub fn set_backoff_scale_factor(mut self, backoff_scale_factor: OrderByEnum) -> Self {
		self.backoff_scale_factor = Some(backoff_scale_factor);
		self
	}
	pub fn set_base_type(mut self, base_type: OrderByEnum) -> Self {
		self.base_type = Some(base_type);
		self
	}
	pub fn set_input_schema(mut self, input_schema: OrderByEnum) -> Self {
		self.input_schema = Some(input_schema);
		self
	}
	pub fn set_enforce_schema(mut self, enforce_schema: OrderByEnum) -> Self {
		self.enforce_schema = Some(enforce_schema);
		self
	}
	pub fn set_output_schema(mut self, output_schema: OrderByEnum) -> Self {
		self.output_schema = Some(output_schema);
		self
	}
	pub fn set_created_on(mut self, created_on: OrderByEnum) -> Self {
		self.created_on = Some(created_on);
		self
	}
	pub fn set_created_by(mut self, created_by: OrderByEnum) -> Self {
		self.created_by = Some(created_by);
		self
	}
	pub fn set_modified_on(mut self, modified_on: OrderByEnum) -> Self {
		self.modified_on = Some(modified_on);
		self
	}
	pub fn set_modified_by(mut self, modified_by: OrderByEnum) -> Self {
		self.modified_by = Some(modified_by);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.name.is_some() {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.description.is_some() {
			query.push(SelectionSet {
				operation: "description",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retry_count.is_some() {
			query.push(SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.timeout_seconds.is_some() {
			query.push(SelectionSet {
				operation: "timeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.input_keys.is_some() {
			query.push(SelectionSet {
				operation: "inputKeys",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.output_keys.is_some() {
			query.push(SelectionSet {
				operation: "outputKeys",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.timeout_policy.is_some() {
			query.push(SelectionSet {
				operation: "timeoutPolicy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retry_logic.is_some() {
			query.push(SelectionSet {
				operation: "retryLogic",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retry_delay_seconds.is_some() {
			query.push(SelectionSet {
				operation: "retryDelaySeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.response_timeout_seconds.is_some() {
			query.push(SelectionSet {
				operation: "responseTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.concurrent_exec_limit.is_some() {
			query.push(SelectionSet {
				operation: "concurrentExecLimit",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.input_template.is_some() {
			query.push(SelectionSet {
				operation: "inputTemplate",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_per_frequency.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_frequency_in_seconds.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.isolation_group_id.is_some() {
			query.push(SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.execution_name_space.is_some() {
			query.push(SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.owner_email.is_some() {
			query.push(SelectionSet {
				operation: "ownerEmail",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.poll_timeout_seconds.is_some() {
			query.push(SelectionSet {
				operation: "pollTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.backoff_scale_factor.is_some() {
			query.push(SelectionSet {
				operation: "backoffScaleFactor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.base_type.is_some() {
			query.push(SelectionSet {
				operation: "baseType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.input_schema.is_some() {
			query.push(SelectionSet {
				operation: "inputSchema",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.enforce_schema.is_some() {
			query.push(SelectionSet {
				operation: "enforceSchema",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.output_schema.is_some() {
			query.push(SelectionSet {
				operation: "outputSchema",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.created_on.is_some() {
			query.push(SelectionSet {
				operation: "createdOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.created_by.is_some() {
			query.push(SelectionSet {
				operation: "createdBy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.modified_on.is_some() {
			query.push(SelectionSet {
				operation: "modifiedOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.modified_by.is_some() {
			query.push(SelectionSet {
				operation: "modifiedBy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskDefinitionUpdateInput {
	#[serde(rename = "name")]
	pub name: Option<String>,
	#[serde(rename = "description")]
	pub description: Option<String>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<i64>,
	#[serde(rename = "timeoutSeconds")]
	pub timeout_seconds: Option<i64>,
	#[serde(rename = "timeoutPolicy")]
	pub timeout_policy: Option<TimeoutPolicyEnum>,
	#[serde(rename = "retryLogic")]
	pub retry_logic: Option<RetryLogicEnum>,
	#[serde(rename = "retryDelaySeconds")]
	pub retry_delay_seconds: Option<i64>,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: Option<i64>,
	#[serde(rename = "concurrentExecLimit")]
	pub concurrent_exec_limit: Option<i64>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<i64>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<i64>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<String>,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<String>,
	#[serde(rename = "ownerEmail")]
	pub owner_email: Option<String>,
	#[serde(rename = "pollTimeoutSeconds")]
	pub poll_timeout_seconds: Option<i64>,
	#[serde(rename = "backoffScaleFactor")]
	pub backoff_scale_factor: Option<i64>,
	#[serde(rename = "baseType")]
	pub base_type: Option<String>,
	#[serde(rename = "enforceSchema")]
	pub enforce_schema: Option<bool>,
	#[serde(rename = "createdOn")]
	pub created_on: Option<String>,
	#[serde(rename = "createdBy")]
	pub created_by: Option<String>,
	#[serde(rename = "modifiedOn")]
	pub modified_on: Option<String>,
	#[serde(rename = "modifiedBy")]
	pub modified_by: Option<String>,
}
impl TaskDefinitionUpdateInput {
	pub fn set_name(mut self, name: String) -> Self {
		self.name = Some(name);
		self
	}
	pub fn set_description(mut self, description: String) -> Self {
		self.description = Some(description);
		self
	}
	pub fn set_retry_count(mut self, retry_count: i64) -> Self {
		self.retry_count = Some(retry_count);
		self
	}
	pub fn set_timeout_seconds(mut self, timeout_seconds: i64) -> Self {
		self.timeout_seconds = Some(timeout_seconds);
		self
	}
	pub fn set_timeout_policy(mut self, timeout_policy: TimeoutPolicyEnum) -> Self {
		self.timeout_policy = Some(timeout_policy);
		self
	}
	pub fn set_retry_logic(mut self, retry_logic: RetryLogicEnum) -> Self {
		self.retry_logic = Some(retry_logic);
		self
	}
	pub fn set_retry_delay_seconds(mut self, retry_delay_seconds: i64) -> Self {
		self.retry_delay_seconds = Some(retry_delay_seconds);
		self
	}
	pub fn set_response_timeout_seconds(mut self, response_timeout_seconds: i64) -> Self {
		self.response_timeout_seconds = Some(response_timeout_seconds);
		self
	}
	pub fn set_concurrent_exec_limit(mut self, concurrent_exec_limit: i64) -> Self {
		self.concurrent_exec_limit = Some(concurrent_exec_limit);
		self
	}
	pub fn set_rate_limit_per_frequency(mut self, rate_limit_per_frequency: i64) -> Self {
		self.rate_limit_per_frequency = Some(rate_limit_per_frequency);
		self
	}
	pub fn set_rate_limit_frequency_in_seconds(
		mut self,
		rate_limit_frequency_in_seconds: i64,
	) -> Self {
		self.rate_limit_frequency_in_seconds = Some(rate_limit_frequency_in_seconds);
		self
	}
	pub fn set_isolation_group_id(mut self, isolation_group_id: String) -> Self {
		self.isolation_group_id = Some(isolation_group_id);
		self
	}
	pub fn set_execution_name_space(mut self, execution_name_space: String) -> Self {
		self.execution_name_space = Some(execution_name_space);
		self
	}
	pub fn set_owner_email(mut self, owner_email: String) -> Self {
		self.owner_email = Some(owner_email);
		self
	}
	pub fn set_poll_timeout_seconds(mut self, poll_timeout_seconds: i64) -> Self {
		self.poll_timeout_seconds = Some(poll_timeout_seconds);
		self
	}
	pub fn set_backoff_scale_factor(mut self, backoff_scale_factor: i64) -> Self {
		self.backoff_scale_factor = Some(backoff_scale_factor);
		self
	}
	pub fn set_base_type(mut self, base_type: String) -> Self {
		self.base_type = Some(base_type);
		self
	}
	pub fn set_enforce_schema(mut self, enforce_schema: bool) -> Self {
		self.enforce_schema = Some(enforce_schema);
		self
	}
	pub fn set_created_on(mut self, created_on: String) -> Self {
		self.created_on = Some(created_on);
		self
	}
	pub fn set_created_by(mut self, created_by: String) -> Self {
		self.created_by = Some(created_by);
		self
	}
	pub fn set_modified_on(mut self, modified_on: String) -> Self {
		self.modified_on = Some(modified_on);
		self
	}
	pub fn set_modified_by(mut self, modified_by: String) -> Self {
		self.modified_by = Some(modified_by);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.name.is_some() {
			query.push(SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.description.is_some() {
			query.push(SelectionSet {
				operation: "description",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retry_count.is_some() {
			query.push(SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.timeout_seconds.is_some() {
			query.push(SelectionSet {
				operation: "timeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.timeout_policy.is_some() {
			query.push(SelectionSet {
				operation: "timeoutPolicy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retry_logic.is_some() {
			query.push(SelectionSet {
				operation: "retryLogic",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retry_delay_seconds.is_some() {
			query.push(SelectionSet {
				operation: "retryDelaySeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.response_timeout_seconds.is_some() {
			query.push(SelectionSet {
				operation: "responseTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.concurrent_exec_limit.is_some() {
			query.push(SelectionSet {
				operation: "concurrentExecLimit",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_per_frequency.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_frequency_in_seconds.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.isolation_group_id.is_some() {
			query.push(SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.execution_name_space.is_some() {
			query.push(SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.owner_email.is_some() {
			query.push(SelectionSet {
				operation: "ownerEmail",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.poll_timeout_seconds.is_some() {
			query.push(SelectionSet {
				operation: "pollTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.backoff_scale_factor.is_some() {
			query.push(SelectionSet {
				operation: "backoffScaleFactor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.base_type.is_some() {
			query.push(SelectionSet {
				operation: "baseType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.enforce_schema.is_some() {
			query.push(SelectionSet {
				operation: "enforceSchema",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.created_on.is_some() {
			query.push(SelectionSet {
				operation: "createdOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.created_by.is_some() {
			query.push(SelectionSet {
				operation: "createdBy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.modified_on.is_some() {
			query.push(SelectionSet {
				operation: "modifiedOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.modified_by.is_some() {
			query.push(SelectionSet {
				operation: "modifiedBy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskExecutionLogFilterInput {
	#[serde(rename = "logId")]
	pub log_id: Option<TextFilterInput>,
	#[serde(rename = "taskId")]
	pub task_id: Option<TextFilterInput>,
	#[serde(rename = "log")]
	pub log: Option<StringFilterInput>,
	#[serde(rename = "createdTime")]
	pub created_time: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<TaskExecutionLogFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<TaskExecutionLogFilterInput>>>,
}
impl TaskExecutionLogFilterInput {
	pub fn set_log_id(mut self, log_id: TextFilterInput) -> Self {
		self.log_id = Some(log_id);
		self
	}
	pub fn set_task_id(mut self, task_id: TextFilterInput) -> Self {
		self.task_id = Some(task_id);
		self
	}
	pub fn set_log(mut self, log: StringFilterInput) -> Self {
		self.log = Some(log);
		self
	}
	pub fn set_created_time(mut self, created_time: TextFilterInput) -> Self {
		self.created_time = Some(created_time);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<TaskExecutionLogFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<TaskExecutionLogFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(log_id) = &self.log_id {
			query.push(SelectionSet {
				operation: "logId",
				alias: None,
				fields: Some(log_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_id) = &self.task_id {
			query.push(SelectionSet {
				operation: "taskId",
				alias: None,
				fields: Some(task_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(log) = &self.log {
			query.push(SelectionSet {
				operation: "log",
				alias: None,
				fields: Some(log.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(created_time) = &self.created_time {
			query.push(SelectionSet {
				operation: "createdTime",
				alias: None,
				fields: Some(created_time.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskExecutionLogInsertInput {
	#[serde(rename = "logId")]
	pub log_id: String,
	#[serde(rename = "taskId")]
	pub task_id: String,
	#[serde(rename = "log")]
	pub log: String,
	#[serde(rename = "createdTime")]
	pub created_time: String,
}
impl TaskExecutionLogInsertInput {
	pub fn set_log_id(mut self, log_id: String) -> Self {
		self.log_id = log_id;
		self
	}
	pub fn set_task_id(mut self, task_id: String) -> Self {
		self.task_id = task_id;
		self
	}
	pub fn set_log(mut self, log: String) -> Self {
		self.log = log;
		self
	}
	pub fn set_created_time(mut self, created_time: String) -> Self {
		self.created_time = created_time;
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "logId",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "taskId",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "log",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "createdTime",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskExecutionLogOrderInput {
	#[serde(rename = "logId")]
	pub log_id: Option<OrderByEnum>,
	#[serde(rename = "taskId")]
	pub task_id: Option<OrderByEnum>,
	#[serde(rename = "log")]
	pub log: Option<OrderByEnum>,
	#[serde(rename = "createdTime")]
	pub created_time: Option<OrderByEnum>,
}
impl TaskExecutionLogOrderInput {
	pub fn set_log_id(mut self, log_id: OrderByEnum) -> Self {
		self.log_id = Some(log_id);
		self
	}
	pub fn set_task_id(mut self, task_id: OrderByEnum) -> Self {
		self.task_id = Some(task_id);
		self
	}
	pub fn set_log(mut self, log: OrderByEnum) -> Self {
		self.log = Some(log);
		self
	}
	pub fn set_created_time(mut self, created_time: OrderByEnum) -> Self {
		self.created_time = Some(created_time);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.log_id.is_some() {
			query.push(SelectionSet {
				operation: "logId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_id.is_some() {
			query.push(SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.log.is_some() {
			query.push(SelectionSet {
				operation: "log",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.created_time.is_some() {
			query.push(SelectionSet {
				operation: "createdTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskExecutionLogUpdateInput {
	#[serde(rename = "logId")]
	pub log_id: Option<String>,
	#[serde(rename = "taskId")]
	pub task_id: Option<String>,
	#[serde(rename = "log")]
	pub log: Option<String>,
	#[serde(rename = "createdTime")]
	pub created_time: Option<String>,
}
impl TaskExecutionLogUpdateInput {
	pub fn set_log_id(mut self, log_id: String) -> Self {
		self.log_id = Some(log_id);
		self
	}
	pub fn set_task_id(mut self, task_id: String) -> Self {
		self.task_id = Some(task_id);
		self
	}
	pub fn set_log(mut self, log: String) -> Self {
		self.log = Some(log);
		self
	}
	pub fn set_created_time(mut self, created_time: String) -> Self {
		self.created_time = Some(created_time);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.log_id.is_some() {
			query.push(SelectionSet {
				operation: "logId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_id.is_some() {
			query.push(SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.log.is_some() {
			query.push(SelectionSet {
				operation: "log",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.created_time.is_some() {
			query.push(SelectionSet {
				operation: "createdTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskModelFilterInput {
	#[serde(rename = "taskId")]
	pub task_id: Option<TextFilterInput>,
	#[serde(rename = "taskType")]
	pub task_type: Option<TaskTypeEnumFilterInput>,
	#[serde(rename = "status")]
	pub status: Option<TaskStatusEnumFilterInput>,
	#[serde(rename = "referenceTaskName")]
	pub reference_task_name: Option<StringFilterInput>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<IntegerFilterInput>,
	#[serde(rename = "seq")]
	pub seq: Option<IntegerFilterInput>,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<StringFilterInput>,
	#[serde(rename = "pollCount")]
	pub poll_count: Option<IntegerFilterInput>,
	#[serde(rename = "taskDefName")]
	pub task_def_name: Option<StringFilterInput>,
	#[serde(rename = "taskConfigId")]
	pub task_config_id: Option<TextFilterInput>,
	#[serde(rename = "scheduledTime")]
	pub scheduled_time: Option<TextFilterInput>,
	#[serde(rename = "startTime")]
	pub start_time: Option<TextFilterInput>,
	#[serde(rename = "endTime")]
	pub end_time: Option<TextFilterInput>,
	#[serde(rename = "updateTime")]
	pub update_time: Option<TextFilterInput>,
	#[serde(rename = "startDelayInSeconds")]
	pub start_delay_in_seconds: Option<IntegerFilterInput>,
	#[serde(rename = "retriedTaskId")]
	pub retried_task_id: Option<StringFilterInput>,
	#[serde(rename = "retried")]
	pub retried: Option<BooleanFilterInput>,
	#[serde(rename = "executed")]
	pub executed: Option<BooleanFilterInput>,
	#[serde(rename = "callbackFromWorker")]
	pub callback_from_worker: Option<BooleanFilterInput>,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: Option<IntegerFilterInput>,
	#[serde(rename = "workflowInstanceId")]
	pub workflow_instance_id: Option<StringFilterInput>,
	#[serde(rename = "workflowType")]
	pub workflow_type: Option<StringFilterInput>,
	#[serde(rename = "reasonForIncompletion")]
	pub reason_for_incompletion: Option<StringFilterInput>,
	#[serde(rename = "callbackAfterSeconds")]
	pub callback_after_seconds: Option<IntegerFilterInput>,
	#[serde(rename = "workerId")]
	pub worker_id: Option<StringFilterInput>,
	#[serde(rename = "domain")]
	pub domain: Option<StringFilterInput>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<IntegerFilterInput>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<IntegerFilterInput>,
	#[serde(rename = "externalInputPayloadStoragePath")]
	pub external_input_payload_storage_path: Option<StringFilterInput>,
	#[serde(rename = "externalOutputPayloadStoragePath")]
	pub external_output_payload_storage_path: Option<StringFilterInput>,
	#[serde(rename = "workflowPriority")]
	pub workflow_priority: Option<IntegerFilterInput>,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<StringFilterInput>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<StringFilterInput>,
	#[serde(rename = "iteration")]
	pub iteration: Option<IntegerFilterInput>,
	#[serde(rename = "subworkflowChanged")]
	pub subworkflow_changed: Option<BooleanFilterInput>,
	#[serde(rename = "waitTimeout")]
	pub wait_timeout: Option<IntegerFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<TaskModelFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<TaskModelFilterInput>>>,
}
impl TaskModelFilterInput {
	pub fn set_task_id(mut self, task_id: TextFilterInput) -> Self {
		self.task_id = Some(task_id);
		self
	}
	pub fn set_task_type(mut self, task_type: TaskTypeEnumFilterInput) -> Self {
		self.task_type = Some(task_type);
		self
	}
	pub fn set_status(mut self, status: TaskStatusEnumFilterInput) -> Self {
		self.status = Some(status);
		self
	}
	pub fn set_reference_task_name(mut self, reference_task_name: StringFilterInput) -> Self {
		self.reference_task_name = Some(reference_task_name);
		self
	}
	pub fn set_retry_count(mut self, retry_count: IntegerFilterInput) -> Self {
		self.retry_count = Some(retry_count);
		self
	}
	pub fn set_seq(mut self, seq: IntegerFilterInput) -> Self {
		self.seq = Some(seq);
		self
	}
	pub fn set_correlation_id(mut self, correlation_id: StringFilterInput) -> Self {
		self.correlation_id = Some(correlation_id);
		self
	}
	pub fn set_poll_count(mut self, poll_count: IntegerFilterInput) -> Self {
		self.poll_count = Some(poll_count);
		self
	}
	pub fn set_task_def_name(mut self, task_def_name: StringFilterInput) -> Self {
		self.task_def_name = Some(task_def_name);
		self
	}
	pub fn set_task_config_id(mut self, task_config_id: TextFilterInput) -> Self {
		self.task_config_id = Some(task_config_id);
		self
	}
	pub fn set_scheduled_time(mut self, scheduled_time: TextFilterInput) -> Self {
		self.scheduled_time = Some(scheduled_time);
		self
	}
	pub fn set_start_time(mut self, start_time: TextFilterInput) -> Self {
		self.start_time = Some(start_time);
		self
	}
	pub fn set_end_time(mut self, end_time: TextFilterInput) -> Self {
		self.end_time = Some(end_time);
		self
	}
	pub fn set_update_time(mut self, update_time: TextFilterInput) -> Self {
		self.update_time = Some(update_time);
		self
	}
	pub fn set_start_delay_in_seconds(
		mut self,
		start_delay_in_seconds: IntegerFilterInput,
	) -> Self {
		self.start_delay_in_seconds = Some(start_delay_in_seconds);
		self
	}
	pub fn set_retried_task_id(mut self, retried_task_id: StringFilterInput) -> Self {
		self.retried_task_id = Some(retried_task_id);
		self
	}
	pub fn set_retried(mut self, retried: BooleanFilterInput) -> Self {
		self.retried = Some(retried);
		self
	}
	pub fn set_executed(mut self, executed: BooleanFilterInput) -> Self {
		self.executed = Some(executed);
		self
	}
	pub fn set_callback_from_worker(mut self, callback_from_worker: BooleanFilterInput) -> Self {
		self.callback_from_worker = Some(callback_from_worker);
		self
	}
	pub fn set_response_timeout_seconds(
		mut self,
		response_timeout_seconds: IntegerFilterInput,
	) -> Self {
		self.response_timeout_seconds = Some(response_timeout_seconds);
		self
	}
	pub fn set_workflow_instance_id(mut self, workflow_instance_id: StringFilterInput) -> Self {
		self.workflow_instance_id = Some(workflow_instance_id);
		self
	}
	pub fn set_workflow_type(mut self, workflow_type: StringFilterInput) -> Self {
		self.workflow_type = Some(workflow_type);
		self
	}
	pub fn set_reason_for_incompletion(
		mut self,
		reason_for_incompletion: StringFilterInput,
	) -> Self {
		self.reason_for_incompletion = Some(reason_for_incompletion);
		self
	}
	pub fn set_callback_after_seconds(
		mut self,
		callback_after_seconds: IntegerFilterInput,
	) -> Self {
		self.callback_after_seconds = Some(callback_after_seconds);
		self
	}
	pub fn set_worker_id(mut self, worker_id: StringFilterInput) -> Self {
		self.worker_id = Some(worker_id);
		self
	}
	pub fn set_domain(mut self, domain: StringFilterInput) -> Self {
		self.domain = Some(domain);
		self
	}
	pub fn set_rate_limit_per_frequency(
		mut self,
		rate_limit_per_frequency: IntegerFilterInput,
	) -> Self {
		self.rate_limit_per_frequency = Some(rate_limit_per_frequency);
		self
	}
	pub fn set_rate_limit_frequency_in_seconds(
		mut self,
		rate_limit_frequency_in_seconds: IntegerFilterInput,
	) -> Self {
		self.rate_limit_frequency_in_seconds = Some(rate_limit_frequency_in_seconds);
		self
	}
	pub fn set_external_input_payload_storage_path(
		mut self,
		external_input_payload_storage_path: StringFilterInput,
	) -> Self {
		self.external_input_payload_storage_path = Some(external_input_payload_storage_path);
		self
	}
	pub fn set_external_output_payload_storage_path(
		mut self,
		external_output_payload_storage_path: StringFilterInput,
	) -> Self {
		self.external_output_payload_storage_path = Some(external_output_payload_storage_path);
		self
	}
	pub fn set_workflow_priority(mut self, workflow_priority: IntegerFilterInput) -> Self {
		self.workflow_priority = Some(workflow_priority);
		self
	}
	pub fn set_execution_name_space(mut self, execution_name_space: StringFilterInput) -> Self {
		self.execution_name_space = Some(execution_name_space);
		self
	}
	pub fn set_isolation_group_id(mut self, isolation_group_id: StringFilterInput) -> Self {
		self.isolation_group_id = Some(isolation_group_id);
		self
	}
	pub fn set_iteration(mut self, iteration: IntegerFilterInput) -> Self {
		self.iteration = Some(iteration);
		self
	}
	pub fn set_subworkflow_changed(mut self, subworkflow_changed: BooleanFilterInput) -> Self {
		self.subworkflow_changed = Some(subworkflow_changed);
		self
	}
	pub fn set_wait_timeout(mut self, wait_timeout: IntegerFilterInput) -> Self {
		self.wait_timeout = Some(wait_timeout);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<TaskModelFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<TaskModelFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(task_id) = &self.task_id {
			query.push(SelectionSet {
				operation: "taskId",
				alias: None,
				fields: Some(task_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_type) = &self.task_type {
			query.push(SelectionSet {
				operation: "taskType",
				alias: None,
				fields: Some(task_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(status) = &self.status {
			query.push(SelectionSet {
				operation: "status",
				alias: None,
				fields: Some(status.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(reference_task_name) = &self.reference_task_name {
			query.push(SelectionSet {
				operation: "referenceTaskName",
				alias: None,
				fields: Some(reference_task_name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(retry_count) = &self.retry_count {
			query.push(SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: Some(retry_count.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(seq) = &self.seq {
			query.push(SelectionSet {
				operation: "seq",
				alias: None,
				fields: Some(seq.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(correlation_id) = &self.correlation_id {
			query.push(SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: Some(correlation_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(poll_count) = &self.poll_count {
			query.push(SelectionSet {
				operation: "pollCount",
				alias: None,
				fields: Some(poll_count.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_def_name) = &self.task_def_name {
			query.push(SelectionSet {
				operation: "taskDefName",
				alias: None,
				fields: Some(task_def_name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_config_id) = &self.task_config_id {
			query.push(SelectionSet {
				operation: "taskConfigId",
				alias: None,
				fields: Some(task_config_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(scheduled_time) = &self.scheduled_time {
			query.push(SelectionSet {
				operation: "scheduledTime",
				alias: None,
				fields: Some(scheduled_time.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(start_time) = &self.start_time {
			query.push(SelectionSet {
				operation: "startTime",
				alias: None,
				fields: Some(start_time.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(end_time) = &self.end_time {
			query.push(SelectionSet {
				operation: "endTime",
				alias: None,
				fields: Some(end_time.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(update_time) = &self.update_time {
			query.push(SelectionSet {
				operation: "updateTime",
				alias: None,
				fields: Some(update_time.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(start_delay_in_seconds) = &self.start_delay_in_seconds {
			query.push(SelectionSet {
				operation: "startDelayInSeconds",
				alias: None,
				fields: Some(start_delay_in_seconds.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(retried_task_id) = &self.retried_task_id {
			query.push(SelectionSet {
				operation: "retriedTaskId",
				alias: None,
				fields: Some(retried_task_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(retried) = &self.retried {
			query.push(SelectionSet {
				operation: "retried",
				alias: None,
				fields: Some(retried.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(executed) = &self.executed {
			query.push(SelectionSet {
				operation: "executed",
				alias: None,
				fields: Some(executed.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(callback_from_worker) = &self.callback_from_worker {
			query.push(SelectionSet {
				operation: "callbackFromWorker",
				alias: None,
				fields: Some(callback_from_worker.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(response_timeout_seconds) = &self.response_timeout_seconds {
			query.push(SelectionSet {
				operation: "responseTimeoutSeconds",
				alias: None,
				fields: Some(response_timeout_seconds.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(workflow_instance_id) = &self.workflow_instance_id {
			query.push(SelectionSet {
				operation: "workflowInstanceId",
				alias: None,
				fields: Some(workflow_instance_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(workflow_type) = &self.workflow_type {
			query.push(SelectionSet {
				operation: "workflowType",
				alias: None,
				fields: Some(workflow_type.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(reason_for_incompletion) = &self.reason_for_incompletion {
			query.push(SelectionSet {
				operation: "reasonForIncompletion",
				alias: None,
				fields: Some(reason_for_incompletion.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(callback_after_seconds) = &self.callback_after_seconds {
			query.push(SelectionSet {
				operation: "callbackAfterSeconds",
				alias: None,
				fields: Some(callback_after_seconds.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(worker_id) = &self.worker_id {
			query.push(SelectionSet {
				operation: "workerId",
				alias: None,
				fields: Some(worker_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(domain) = &self.domain {
			query.push(SelectionSet {
				operation: "domain",
				alias: None,
				fields: Some(domain.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(rate_limit_per_frequency) = &self.rate_limit_per_frequency {
			query.push(SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: Some(rate_limit_per_frequency.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(rate_limit_frequency_in_seconds) = &self.rate_limit_frequency_in_seconds {
			query.push(SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: Some(rate_limit_frequency_in_seconds.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(external_input_payload_storage_path) = &self.external_input_payload_storage_path
		{
			query.push(SelectionSet {
				operation: "externalInputPayloadStoragePath",
				alias: None,
				fields: Some(external_input_payload_storage_path.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(external_output_payload_storage_path) =
			&self.external_output_payload_storage_path
		{
			query.push(SelectionSet {
				operation: "externalOutputPayloadStoragePath",
				alias: None,
				fields: Some(external_output_payload_storage_path.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(workflow_priority) = &self.workflow_priority {
			query.push(SelectionSet {
				operation: "workflowPriority",
				alias: None,
				fields: Some(workflow_priority.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(execution_name_space) = &self.execution_name_space {
			query.push(SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: Some(execution_name_space.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(isolation_group_id) = &self.isolation_group_id {
			query.push(SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: Some(isolation_group_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(iteration) = &self.iteration {
			query.push(SelectionSet {
				operation: "iteration",
				alias: None,
				fields: Some(iteration.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(subworkflow_changed) = &self.subworkflow_changed {
			query.push(SelectionSet {
				operation: "subworkflowChanged",
				alias: None,
				fields: Some(subworkflow_changed.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(wait_timeout) = &self.wait_timeout {
			query.push(SelectionSet {
				operation: "waitTimeout",
				alias: None,
				fields: Some(wait_timeout.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskModelInsertInput {
	#[serde(rename = "taskId")]
	pub task_id: String,
	#[serde(rename = "taskType")]
	pub task_type: TaskTypeEnum,
	#[serde(rename = "status")]
	pub status: TaskStatusEnum,
	#[serde(rename = "referenceTaskName")]
	pub reference_task_name: String,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<i64>,
	#[serde(rename = "seq")]
	pub seq: i64,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<String>,
	#[serde(rename = "pollCount")]
	pub poll_count: i64,
	#[serde(rename = "taskDefName")]
	pub task_def_name: String,
	#[serde(rename = "taskConfigId")]
	pub task_config_id: Option<String>,
	#[serde(rename = "scheduledTime")]
	pub scheduled_time: String,
	#[serde(rename = "startTime")]
	pub start_time: String,
	#[serde(rename = "endTime")]
	pub end_time: Option<String>,
	#[serde(rename = "updateTime")]
	pub update_time: Option<String>,
	#[serde(rename = "startDelayInSeconds")]
	pub start_delay_in_seconds: i64,
	#[serde(rename = "retriedTaskId")]
	pub retried_task_id: Option<String>,
	#[serde(rename = "retried")]
	pub retried: bool,
	#[serde(rename = "executed")]
	pub executed: bool,
	#[serde(rename = "callbackFromWorker")]
	pub callback_from_worker: bool,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: Option<i64>,
	#[serde(rename = "workflowInstanceId")]
	pub workflow_instance_id: Option<String>,
	#[serde(rename = "workflowType")]
	pub workflow_type: Option<String>,
	#[serde(rename = "reasonForIncompletion")]
	pub reason_for_incompletion: Option<String>,
	#[serde(rename = "callbackAfterSeconds")]
	pub callback_after_seconds: i64,
	#[serde(rename = "workerId")]
	pub worker_id: Option<String>,
	#[serde(rename = "domain")]
	pub domain: Option<String>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<i64>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<i64>,
	#[serde(rename = "externalInputPayloadStoragePath")]
	pub external_input_payload_storage_path: Option<String>,
	#[serde(rename = "externalOutputPayloadStoragePath")]
	pub external_output_payload_storage_path: Option<String>,
	#[serde(rename = "workflowPriority")]
	pub workflow_priority: i64,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<String>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<String>,
	#[serde(rename = "iteration")]
	pub iteration: i64,
	#[serde(rename = "subworkflowChanged")]
	pub subworkflow_changed: bool,
	#[serde(rename = "waitTimeout")]
	pub wait_timeout: Option<i64>,
}
impl TaskModelInsertInput {
	pub fn set_task_id(mut self, task_id: String) -> Self {
		self.task_id = task_id;
		self
	}
	pub fn set_task_type(mut self, task_type: TaskTypeEnum) -> Self {
		self.task_type = task_type;
		self
	}
	pub fn set_status(mut self, status: TaskStatusEnum) -> Self {
		self.status = status;
		self
	}
	pub fn set_reference_task_name(mut self, reference_task_name: String) -> Self {
		self.reference_task_name = reference_task_name;
		self
	}
	pub fn set_retry_count(mut self, retry_count: i64) -> Self {
		self.retry_count = Some(retry_count);
		self
	}
	pub fn set_seq(mut self, seq: i64) -> Self {
		self.seq = seq;
		self
	}
	pub fn set_correlation_id(mut self, correlation_id: String) -> Self {
		self.correlation_id = Some(correlation_id);
		self
	}
	pub fn set_poll_count(mut self, poll_count: i64) -> Self {
		self.poll_count = poll_count;
		self
	}
	pub fn set_task_def_name(mut self, task_def_name: String) -> Self {
		self.task_def_name = task_def_name;
		self
	}
	pub fn set_task_config_id(mut self, task_config_id: String) -> Self {
		self.task_config_id = Some(task_config_id);
		self
	}
	pub fn set_scheduled_time(mut self, scheduled_time: String) -> Self {
		self.scheduled_time = scheduled_time;
		self
	}
	pub fn set_start_time(mut self, start_time: String) -> Self {
		self.start_time = start_time;
		self
	}
	pub fn set_end_time(mut self, end_time: String) -> Self {
		self.end_time = Some(end_time);
		self
	}
	pub fn set_update_time(mut self, update_time: String) -> Self {
		self.update_time = Some(update_time);
		self
	}
	pub fn set_start_delay_in_seconds(mut self, start_delay_in_seconds: i64) -> Self {
		self.start_delay_in_seconds = start_delay_in_seconds;
		self
	}
	pub fn set_retried_task_id(mut self, retried_task_id: String) -> Self {
		self.retried_task_id = Some(retried_task_id);
		self
	}
	pub fn set_retried(mut self, retried: bool) -> Self {
		self.retried = retried;
		self
	}
	pub fn set_executed(mut self, executed: bool) -> Self {
		self.executed = executed;
		self
	}
	pub fn set_callback_from_worker(mut self, callback_from_worker: bool) -> Self {
		self.callback_from_worker = callback_from_worker;
		self
	}
	pub fn set_response_timeout_seconds(mut self, response_timeout_seconds: i64) -> Self {
		self.response_timeout_seconds = Some(response_timeout_seconds);
		self
	}
	pub fn set_workflow_instance_id(mut self, workflow_instance_id: String) -> Self {
		self.workflow_instance_id = Some(workflow_instance_id);
		self
	}
	pub fn set_workflow_type(mut self, workflow_type: String) -> Self {
		self.workflow_type = Some(workflow_type);
		self
	}
	pub fn set_reason_for_incompletion(mut self, reason_for_incompletion: String) -> Self {
		self.reason_for_incompletion = Some(reason_for_incompletion);
		self
	}
	pub fn set_callback_after_seconds(mut self, callback_after_seconds: i64) -> Self {
		self.callback_after_seconds = callback_after_seconds;
		self
	}
	pub fn set_worker_id(mut self, worker_id: String) -> Self {
		self.worker_id = Some(worker_id);
		self
	}
	pub fn set_domain(mut self, domain: String) -> Self {
		self.domain = Some(domain);
		self
	}
	pub fn set_rate_limit_per_frequency(mut self, rate_limit_per_frequency: i64) -> Self {
		self.rate_limit_per_frequency = Some(rate_limit_per_frequency);
		self
	}
	pub fn set_rate_limit_frequency_in_seconds(
		mut self,
		rate_limit_frequency_in_seconds: i64,
	) -> Self {
		self.rate_limit_frequency_in_seconds = Some(rate_limit_frequency_in_seconds);
		self
	}
	pub fn set_external_input_payload_storage_path(
		mut self,
		external_input_payload_storage_path: String,
	) -> Self {
		self.external_input_payload_storage_path = Some(external_input_payload_storage_path);
		self
	}
	pub fn set_external_output_payload_storage_path(
		mut self,
		external_output_payload_storage_path: String,
	) -> Self {
		self.external_output_payload_storage_path = Some(external_output_payload_storage_path);
		self
	}
	pub fn set_workflow_priority(mut self, workflow_priority: i64) -> Self {
		self.workflow_priority = workflow_priority;
		self
	}
	pub fn set_execution_name_space(mut self, execution_name_space: String) -> Self {
		self.execution_name_space = Some(execution_name_space);
		self
	}
	pub fn set_isolation_group_id(mut self, isolation_group_id: String) -> Self {
		self.isolation_group_id = Some(isolation_group_id);
		self
	}
	pub fn set_iteration(mut self, iteration: i64) -> Self {
		self.iteration = iteration;
		self
	}
	pub fn set_subworkflow_changed(mut self, subworkflow_changed: bool) -> Self {
		self.subworkflow_changed = subworkflow_changed;
		self
	}
	pub fn set_wait_timeout(mut self, wait_timeout: i64) -> Self {
		self.wait_timeout = Some(wait_timeout);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "taskId",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "taskType",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "status",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "referenceTaskName",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.retry_count.is_some() {
			query.push(SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "seq",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.correlation_id.is_some() {
			query.push(SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "pollCount",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "taskDefName",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_config_id.is_some() {
			query.push(SelectionSet {
				operation: "taskConfigId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "scheduledTime",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "startTime",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.end_time.is_some() {
			query.push(SelectionSet {
				operation: "endTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.update_time.is_some() {
			query.push(SelectionSet {
				operation: "updateTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "startDelayInSeconds",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.retried_task_id.is_some() {
			query.push(SelectionSet {
				operation: "retriedTaskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "retried",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "executed",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "callbackFromWorker",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.response_timeout_seconds.is_some() {
			query.push(SelectionSet {
				operation: "responseTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_instance_id.is_some() {
			query.push(SelectionSet {
				operation: "workflowInstanceId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_type.is_some() {
			query.push(SelectionSet {
				operation: "workflowType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.reason_for_incompletion.is_some() {
			query.push(SelectionSet {
				operation: "reasonForIncompletion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "callbackAfterSeconds",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.worker_id.is_some() {
			query.push(SelectionSet {
				operation: "workerId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.domain.is_some() {
			query.push(SelectionSet {
				operation: "domain",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_per_frequency.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_frequency_in_seconds.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.external_input_payload_storage_path.is_some() {
			query.push(SelectionSet {
				operation: "externalInputPayloadStoragePath",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.external_output_payload_storage_path.is_some() {
			query.push(SelectionSet {
				operation: "externalOutputPayloadStoragePath",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "workflowPriority",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.execution_name_space.is_some() {
			query.push(SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.isolation_group_id.is_some() {
			query.push(SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "iteration",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "subworkflowChanged",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.wait_timeout.is_some() {
			query.push(SelectionSet {
				operation: "waitTimeout",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskModelOrderInput {
	#[serde(rename = "taskId")]
	pub task_id: Option<OrderByEnum>,
	#[serde(rename = "taskType")]
	pub task_type: Option<OrderByEnum>,
	#[serde(rename = "status")]
	pub status: Option<OrderByEnum>,
	#[serde(rename = "referenceTaskName")]
	pub reference_task_name: Option<OrderByEnum>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<OrderByEnum>,
	#[serde(rename = "seq")]
	pub seq: Option<OrderByEnum>,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<OrderByEnum>,
	#[serde(rename = "pollCount")]
	pub poll_count: Option<OrderByEnum>,
	#[serde(rename = "taskDefName")]
	pub task_def_name: Option<OrderByEnum>,
	#[serde(rename = "taskConfigId")]
	pub task_config_id: Option<OrderByEnum>,
	#[serde(rename = "scheduledTime")]
	pub scheduled_time: Option<OrderByEnum>,
	#[serde(rename = "startTime")]
	pub start_time: Option<OrderByEnum>,
	#[serde(rename = "endTime")]
	pub end_time: Option<OrderByEnum>,
	#[serde(rename = "updateTime")]
	pub update_time: Option<OrderByEnum>,
	#[serde(rename = "startDelayInSeconds")]
	pub start_delay_in_seconds: Option<OrderByEnum>,
	#[serde(rename = "retriedTaskId")]
	pub retried_task_id: Option<OrderByEnum>,
	#[serde(rename = "retried")]
	pub retried: Option<OrderByEnum>,
	#[serde(rename = "executed")]
	pub executed: Option<OrderByEnum>,
	#[serde(rename = "callbackFromWorker")]
	pub callback_from_worker: Option<OrderByEnum>,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: Option<OrderByEnum>,
	#[serde(rename = "workflowInstanceId")]
	pub workflow_instance_id: Option<OrderByEnum>,
	#[serde(rename = "workflowType")]
	pub workflow_type: Option<OrderByEnum>,
	#[serde(rename = "reasonForIncompletion")]
	pub reason_for_incompletion: Option<OrderByEnum>,
	#[serde(rename = "callbackAfterSeconds")]
	pub callback_after_seconds: Option<OrderByEnum>,
	#[serde(rename = "workerId")]
	pub worker_id: Option<OrderByEnum>,
	#[serde(rename = "domain")]
	pub domain: Option<OrderByEnum>,
	#[serde(rename = "inputMessage")]
	pub input_message: Option<OrderByEnum>,
	#[serde(rename = "outputMessage")]
	pub output_message: Option<OrderByEnum>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<OrderByEnum>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<OrderByEnum>,
	#[serde(rename = "externalInputPayloadStoragePath")]
	pub external_input_payload_storage_path: Option<OrderByEnum>,
	#[serde(rename = "externalOutputPayloadStoragePath")]
	pub external_output_payload_storage_path: Option<OrderByEnum>,
	#[serde(rename = "workflowPriority")]
	pub workflow_priority: Option<OrderByEnum>,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<OrderByEnum>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<OrderByEnum>,
	#[serde(rename = "iteration")]
	pub iteration: Option<OrderByEnum>,
	#[serde(rename = "subworkflowChanged")]
	pub subworkflow_changed: Option<OrderByEnum>,
	#[serde(rename = "waitTimeout")]
	pub wait_timeout: Option<OrderByEnum>,
}
impl TaskModelOrderInput {
	pub fn set_task_id(mut self, task_id: OrderByEnum) -> Self {
		self.task_id = Some(task_id);
		self
	}
	pub fn set_task_type(mut self, task_type: OrderByEnum) -> Self {
		self.task_type = Some(task_type);
		self
	}
	pub fn set_status(mut self, status: OrderByEnum) -> Self {
		self.status = Some(status);
		self
	}
	pub fn set_reference_task_name(mut self, reference_task_name: OrderByEnum) -> Self {
		self.reference_task_name = Some(reference_task_name);
		self
	}
	pub fn set_retry_count(mut self, retry_count: OrderByEnum) -> Self {
		self.retry_count = Some(retry_count);
		self
	}
	pub fn set_seq(mut self, seq: OrderByEnum) -> Self {
		self.seq = Some(seq);
		self
	}
	pub fn set_correlation_id(mut self, correlation_id: OrderByEnum) -> Self {
		self.correlation_id = Some(correlation_id);
		self
	}
	pub fn set_poll_count(mut self, poll_count: OrderByEnum) -> Self {
		self.poll_count = Some(poll_count);
		self
	}
	pub fn set_task_def_name(mut self, task_def_name: OrderByEnum) -> Self {
		self.task_def_name = Some(task_def_name);
		self
	}
	pub fn set_task_config_id(mut self, task_config_id: OrderByEnum) -> Self {
		self.task_config_id = Some(task_config_id);
		self
	}
	pub fn set_scheduled_time(mut self, scheduled_time: OrderByEnum) -> Self {
		self.scheduled_time = Some(scheduled_time);
		self
	}
	pub fn set_start_time(mut self, start_time: OrderByEnum) -> Self {
		self.start_time = Some(start_time);
		self
	}
	pub fn set_end_time(mut self, end_time: OrderByEnum) -> Self {
		self.end_time = Some(end_time);
		self
	}
	pub fn set_update_time(mut self, update_time: OrderByEnum) -> Self {
		self.update_time = Some(update_time);
		self
	}
	pub fn set_start_delay_in_seconds(mut self, start_delay_in_seconds: OrderByEnum) -> Self {
		self.start_delay_in_seconds = Some(start_delay_in_seconds);
		self
	}
	pub fn set_retried_task_id(mut self, retried_task_id: OrderByEnum) -> Self {
		self.retried_task_id = Some(retried_task_id);
		self
	}
	pub fn set_retried(mut self, retried: OrderByEnum) -> Self {
		self.retried = Some(retried);
		self
	}
	pub fn set_executed(mut self, executed: OrderByEnum) -> Self {
		self.executed = Some(executed);
		self
	}
	pub fn set_callback_from_worker(mut self, callback_from_worker: OrderByEnum) -> Self {
		self.callback_from_worker = Some(callback_from_worker);
		self
	}
	pub fn set_response_timeout_seconds(mut self, response_timeout_seconds: OrderByEnum) -> Self {
		self.response_timeout_seconds = Some(response_timeout_seconds);
		self
	}
	pub fn set_workflow_instance_id(mut self, workflow_instance_id: OrderByEnum) -> Self {
		self.workflow_instance_id = Some(workflow_instance_id);
		self
	}
	pub fn set_workflow_type(mut self, workflow_type: OrderByEnum) -> Self {
		self.workflow_type = Some(workflow_type);
		self
	}
	pub fn set_reason_for_incompletion(mut self, reason_for_incompletion: OrderByEnum) -> Self {
		self.reason_for_incompletion = Some(reason_for_incompletion);
		self
	}
	pub fn set_callback_after_seconds(mut self, callback_after_seconds: OrderByEnum) -> Self {
		self.callback_after_seconds = Some(callback_after_seconds);
		self
	}
	pub fn set_worker_id(mut self, worker_id: OrderByEnum) -> Self {
		self.worker_id = Some(worker_id);
		self
	}
	pub fn set_domain(mut self, domain: OrderByEnum) -> Self {
		self.domain = Some(domain);
		self
	}
	pub fn set_input_message(mut self, input_message: OrderByEnum) -> Self {
		self.input_message = Some(input_message);
		self
	}
	pub fn set_output_message(mut self, output_message: OrderByEnum) -> Self {
		self.output_message = Some(output_message);
		self
	}
	pub fn set_rate_limit_per_frequency(mut self, rate_limit_per_frequency: OrderByEnum) -> Self {
		self.rate_limit_per_frequency = Some(rate_limit_per_frequency);
		self
	}
	pub fn set_rate_limit_frequency_in_seconds(
		mut self,
		rate_limit_frequency_in_seconds: OrderByEnum,
	) -> Self {
		self.rate_limit_frequency_in_seconds = Some(rate_limit_frequency_in_seconds);
		self
	}
	pub fn set_external_input_payload_storage_path(
		mut self,
		external_input_payload_storage_path: OrderByEnum,
	) -> Self {
		self.external_input_payload_storage_path = Some(external_input_payload_storage_path);
		self
	}
	pub fn set_external_output_payload_storage_path(
		mut self,
		external_output_payload_storage_path: OrderByEnum,
	) -> Self {
		self.external_output_payload_storage_path = Some(external_output_payload_storage_path);
		self
	}
	pub fn set_workflow_priority(mut self, workflow_priority: OrderByEnum) -> Self {
		self.workflow_priority = Some(workflow_priority);
		self
	}
	pub fn set_execution_name_space(mut self, execution_name_space: OrderByEnum) -> Self {
		self.execution_name_space = Some(execution_name_space);
		self
	}
	pub fn set_isolation_group_id(mut self, isolation_group_id: OrderByEnum) -> Self {
		self.isolation_group_id = Some(isolation_group_id);
		self
	}
	pub fn set_iteration(mut self, iteration: OrderByEnum) -> Self {
		self.iteration = Some(iteration);
		self
	}
	pub fn set_subworkflow_changed(mut self, subworkflow_changed: OrderByEnum) -> Self {
		self.subworkflow_changed = Some(subworkflow_changed);
		self
	}
	pub fn set_wait_timeout(mut self, wait_timeout: OrderByEnum) -> Self {
		self.wait_timeout = Some(wait_timeout);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.task_id.is_some() {
			query.push(SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_type.is_some() {
			query.push(SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.status.is_some() {
			query.push(SelectionSet {
				operation: "status",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.reference_task_name.is_some() {
			query.push(SelectionSet {
				operation: "referenceTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retry_count.is_some() {
			query.push(SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.seq.is_some() {
			query.push(SelectionSet {
				operation: "seq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.correlation_id.is_some() {
			query.push(SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.poll_count.is_some() {
			query.push(SelectionSet {
				operation: "pollCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_def_name.is_some() {
			query.push(SelectionSet {
				operation: "taskDefName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_config_id.is_some() {
			query.push(SelectionSet {
				operation: "taskConfigId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.scheduled_time.is_some() {
			query.push(SelectionSet {
				operation: "scheduledTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.start_time.is_some() {
			query.push(SelectionSet {
				operation: "startTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.end_time.is_some() {
			query.push(SelectionSet {
				operation: "endTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.update_time.is_some() {
			query.push(SelectionSet {
				operation: "updateTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.start_delay_in_seconds.is_some() {
			query.push(SelectionSet {
				operation: "startDelayInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retried_task_id.is_some() {
			query.push(SelectionSet {
				operation: "retriedTaskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retried.is_some() {
			query.push(SelectionSet {
				operation: "retried",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.executed.is_some() {
			query.push(SelectionSet {
				operation: "executed",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.callback_from_worker.is_some() {
			query.push(SelectionSet {
				operation: "callbackFromWorker",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.response_timeout_seconds.is_some() {
			query.push(SelectionSet {
				operation: "responseTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_instance_id.is_some() {
			query.push(SelectionSet {
				operation: "workflowInstanceId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_type.is_some() {
			query.push(SelectionSet {
				operation: "workflowType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.reason_for_incompletion.is_some() {
			query.push(SelectionSet {
				operation: "reasonForIncompletion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.callback_after_seconds.is_some() {
			query.push(SelectionSet {
				operation: "callbackAfterSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.worker_id.is_some() {
			query.push(SelectionSet {
				operation: "workerId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.domain.is_some() {
			query.push(SelectionSet {
				operation: "domain",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.input_message.is_some() {
			query.push(SelectionSet {
				operation: "inputMessage",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.output_message.is_some() {
			query.push(SelectionSet {
				operation: "outputMessage",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_per_frequency.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_frequency_in_seconds.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.external_input_payload_storage_path.is_some() {
			query.push(SelectionSet {
				operation: "externalInputPayloadStoragePath",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.external_output_payload_storage_path.is_some() {
			query.push(SelectionSet {
				operation: "externalOutputPayloadStoragePath",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_priority.is_some() {
			query.push(SelectionSet {
				operation: "workflowPriority",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.execution_name_space.is_some() {
			query.push(SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.isolation_group_id.is_some() {
			query.push(SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.iteration.is_some() {
			query.push(SelectionSet {
				operation: "iteration",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.subworkflow_changed.is_some() {
			query.push(SelectionSet {
				operation: "subworkflowChanged",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.wait_timeout.is_some() {
			query.push(SelectionSet {
				operation: "waitTimeout",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskModelUpdateInput {
	#[serde(rename = "taskId")]
	pub task_id: Option<String>,
	#[serde(rename = "taskType")]
	pub task_type: Option<TaskTypeEnum>,
	#[serde(rename = "status")]
	pub status: Option<TaskStatusEnum>,
	#[serde(rename = "referenceTaskName")]
	pub reference_task_name: Option<String>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<i64>,
	#[serde(rename = "seq")]
	pub seq: Option<i64>,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<String>,
	#[serde(rename = "pollCount")]
	pub poll_count: Option<i64>,
	#[serde(rename = "taskDefName")]
	pub task_def_name: Option<String>,
	#[serde(rename = "taskConfigId")]
	pub task_config_id: Option<String>,
	#[serde(rename = "scheduledTime")]
	pub scheduled_time: Option<String>,
	#[serde(rename = "startTime")]
	pub start_time: Option<String>,
	#[serde(rename = "endTime")]
	pub end_time: Option<String>,
	#[serde(rename = "updateTime")]
	pub update_time: Option<String>,
	#[serde(rename = "startDelayInSeconds")]
	pub start_delay_in_seconds: Option<i64>,
	#[serde(rename = "retriedTaskId")]
	pub retried_task_id: Option<String>,
	#[serde(rename = "retried")]
	pub retried: Option<bool>,
	#[serde(rename = "executed")]
	pub executed: Option<bool>,
	#[serde(rename = "callbackFromWorker")]
	pub callback_from_worker: Option<bool>,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: Option<i64>,
	#[serde(rename = "workflowInstanceId")]
	pub workflow_instance_id: Option<String>,
	#[serde(rename = "workflowType")]
	pub workflow_type: Option<String>,
	#[serde(rename = "reasonForIncompletion")]
	pub reason_for_incompletion: Option<String>,
	#[serde(rename = "callbackAfterSeconds")]
	pub callback_after_seconds: Option<i64>,
	#[serde(rename = "workerId")]
	pub worker_id: Option<String>,
	#[serde(rename = "domain")]
	pub domain: Option<String>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<i64>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<i64>,
	#[serde(rename = "externalInputPayloadStoragePath")]
	pub external_input_payload_storage_path: Option<String>,
	#[serde(rename = "externalOutputPayloadStoragePath")]
	pub external_output_payload_storage_path: Option<String>,
	#[serde(rename = "workflowPriority")]
	pub workflow_priority: Option<i64>,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<String>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<String>,
	#[serde(rename = "iteration")]
	pub iteration: Option<i64>,
	#[serde(rename = "subworkflowChanged")]
	pub subworkflow_changed: Option<bool>,
	#[serde(rename = "waitTimeout")]
	pub wait_timeout: Option<i64>,
}
impl TaskModelUpdateInput {
	pub fn set_task_id(mut self, task_id: String) -> Self {
		self.task_id = Some(task_id);
		self
	}
	pub fn set_task_type(mut self, task_type: TaskTypeEnum) -> Self {
		self.task_type = Some(task_type);
		self
	}
	pub fn set_status(mut self, status: TaskStatusEnum) -> Self {
		self.status = Some(status);
		self
	}
	pub fn set_reference_task_name(mut self, reference_task_name: String) -> Self {
		self.reference_task_name = Some(reference_task_name);
		self
	}
	pub fn set_retry_count(mut self, retry_count: i64) -> Self {
		self.retry_count = Some(retry_count);
		self
	}
	pub fn set_seq(mut self, seq: i64) -> Self {
		self.seq = Some(seq);
		self
	}
	pub fn set_correlation_id(mut self, correlation_id: String) -> Self {
		self.correlation_id = Some(correlation_id);
		self
	}
	pub fn set_poll_count(mut self, poll_count: i64) -> Self {
		self.poll_count = Some(poll_count);
		self
	}
	pub fn set_task_def_name(mut self, task_def_name: String) -> Self {
		self.task_def_name = Some(task_def_name);
		self
	}
	pub fn set_task_config_id(mut self, task_config_id: String) -> Self {
		self.task_config_id = Some(task_config_id);
		self
	}
	pub fn set_scheduled_time(mut self, scheduled_time: String) -> Self {
		self.scheduled_time = Some(scheduled_time);
		self
	}
	pub fn set_start_time(mut self, start_time: String) -> Self {
		self.start_time = Some(start_time);
		self
	}
	pub fn set_end_time(mut self, end_time: String) -> Self {
		self.end_time = Some(end_time);
		self
	}
	pub fn set_update_time(mut self, update_time: String) -> Self {
		self.update_time = Some(update_time);
		self
	}
	pub fn set_start_delay_in_seconds(mut self, start_delay_in_seconds: i64) -> Self {
		self.start_delay_in_seconds = Some(start_delay_in_seconds);
		self
	}
	pub fn set_retried_task_id(mut self, retried_task_id: String) -> Self {
		self.retried_task_id = Some(retried_task_id);
		self
	}
	pub fn set_retried(mut self, retried: bool) -> Self {
		self.retried = Some(retried);
		self
	}
	pub fn set_executed(mut self, executed: bool) -> Self {
		self.executed = Some(executed);
		self
	}
	pub fn set_callback_from_worker(mut self, callback_from_worker: bool) -> Self {
		self.callback_from_worker = Some(callback_from_worker);
		self
	}
	pub fn set_response_timeout_seconds(mut self, response_timeout_seconds: i64) -> Self {
		self.response_timeout_seconds = Some(response_timeout_seconds);
		self
	}
	pub fn set_workflow_instance_id(mut self, workflow_instance_id: String) -> Self {
		self.workflow_instance_id = Some(workflow_instance_id);
		self
	}
	pub fn set_workflow_type(mut self, workflow_type: String) -> Self {
		self.workflow_type = Some(workflow_type);
		self
	}
	pub fn set_reason_for_incompletion(mut self, reason_for_incompletion: String) -> Self {
		self.reason_for_incompletion = Some(reason_for_incompletion);
		self
	}
	pub fn set_callback_after_seconds(mut self, callback_after_seconds: i64) -> Self {
		self.callback_after_seconds = Some(callback_after_seconds);
		self
	}
	pub fn set_worker_id(mut self, worker_id: String) -> Self {
		self.worker_id = Some(worker_id);
		self
	}
	pub fn set_domain(mut self, domain: String) -> Self {
		self.domain = Some(domain);
		self
	}
	pub fn set_rate_limit_per_frequency(mut self, rate_limit_per_frequency: i64) -> Self {
		self.rate_limit_per_frequency = Some(rate_limit_per_frequency);
		self
	}
	pub fn set_rate_limit_frequency_in_seconds(
		mut self,
		rate_limit_frequency_in_seconds: i64,
	) -> Self {
		self.rate_limit_frequency_in_seconds = Some(rate_limit_frequency_in_seconds);
		self
	}
	pub fn set_external_input_payload_storage_path(
		mut self,
		external_input_payload_storage_path: String,
	) -> Self {
		self.external_input_payload_storage_path = Some(external_input_payload_storage_path);
		self
	}
	pub fn set_external_output_payload_storage_path(
		mut self,
		external_output_payload_storage_path: String,
	) -> Self {
		self.external_output_payload_storage_path = Some(external_output_payload_storage_path);
		self
	}
	pub fn set_workflow_priority(mut self, workflow_priority: i64) -> Self {
		self.workflow_priority = Some(workflow_priority);
		self
	}
	pub fn set_execution_name_space(mut self, execution_name_space: String) -> Self {
		self.execution_name_space = Some(execution_name_space);
		self
	}
	pub fn set_isolation_group_id(mut self, isolation_group_id: String) -> Self {
		self.isolation_group_id = Some(isolation_group_id);
		self
	}
	pub fn set_iteration(mut self, iteration: i64) -> Self {
		self.iteration = Some(iteration);
		self
	}
	pub fn set_subworkflow_changed(mut self, subworkflow_changed: bool) -> Self {
		self.subworkflow_changed = Some(subworkflow_changed);
		self
	}
	pub fn set_wait_timeout(mut self, wait_timeout: i64) -> Self {
		self.wait_timeout = Some(wait_timeout);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.task_id.is_some() {
			query.push(SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_type.is_some() {
			query.push(SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.status.is_some() {
			query.push(SelectionSet {
				operation: "status",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.reference_task_name.is_some() {
			query.push(SelectionSet {
				operation: "referenceTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retry_count.is_some() {
			query.push(SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.seq.is_some() {
			query.push(SelectionSet {
				operation: "seq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.correlation_id.is_some() {
			query.push(SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.poll_count.is_some() {
			query.push(SelectionSet {
				operation: "pollCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_def_name.is_some() {
			query.push(SelectionSet {
				operation: "taskDefName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_config_id.is_some() {
			query.push(SelectionSet {
				operation: "taskConfigId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.scheduled_time.is_some() {
			query.push(SelectionSet {
				operation: "scheduledTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.start_time.is_some() {
			query.push(SelectionSet {
				operation: "startTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.end_time.is_some() {
			query.push(SelectionSet {
				operation: "endTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.update_time.is_some() {
			query.push(SelectionSet {
				operation: "updateTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.start_delay_in_seconds.is_some() {
			query.push(SelectionSet {
				operation: "startDelayInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retried_task_id.is_some() {
			query.push(SelectionSet {
				operation: "retriedTaskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.retried.is_some() {
			query.push(SelectionSet {
				operation: "retried",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.executed.is_some() {
			query.push(SelectionSet {
				operation: "executed",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.callback_from_worker.is_some() {
			query.push(SelectionSet {
				operation: "callbackFromWorker",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.response_timeout_seconds.is_some() {
			query.push(SelectionSet {
				operation: "responseTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_instance_id.is_some() {
			query.push(SelectionSet {
				operation: "workflowInstanceId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_type.is_some() {
			query.push(SelectionSet {
				operation: "workflowType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.reason_for_incompletion.is_some() {
			query.push(SelectionSet {
				operation: "reasonForIncompletion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.callback_after_seconds.is_some() {
			query.push(SelectionSet {
				operation: "callbackAfterSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.worker_id.is_some() {
			query.push(SelectionSet {
				operation: "workerId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.domain.is_some() {
			query.push(SelectionSet {
				operation: "domain",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_per_frequency.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.rate_limit_frequency_in_seconds.is_some() {
			query.push(SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.external_input_payload_storage_path.is_some() {
			query.push(SelectionSet {
				operation: "externalInputPayloadStoragePath",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.external_output_payload_storage_path.is_some() {
			query.push(SelectionSet {
				operation: "externalOutputPayloadStoragePath",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_priority.is_some() {
			query.push(SelectionSet {
				operation: "workflowPriority",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.execution_name_space.is_some() {
			query.push(SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.isolation_group_id.is_some() {
			query.push(SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.iteration.is_some() {
			query.push(SelectionSet {
				operation: "iteration",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.subworkflow_changed.is_some() {
			query.push(SelectionSet {
				operation: "subworkflowChanged",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.wait_timeout.is_some() {
			query.push(SelectionSet {
				operation: "waitTimeout",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskStatusEnumFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<TaskStatusEnum>,
	#[serde(rename = "ne")]
	pub ne: Option<TaskStatusEnum>,
	#[serde(rename = "gt")]
	pub gt: Option<TaskStatusEnum>,
	#[serde(rename = "gte")]
	pub gte: Option<TaskStatusEnum>,
	#[serde(rename = "lt")]
	pub lt: Option<TaskStatusEnum>,
	#[serde(rename = "lte")]
	pub lte: Option<TaskStatusEnum>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<TaskStatusEnum>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<TaskStatusEnum>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<TaskStatusEnum>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<TaskStatusEnum>,
}
impl TaskStatusEnumFilterInput {
	pub fn set_eq(mut self, eq: TaskStatusEnum) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: TaskStatusEnum) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: TaskStatusEnum) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: TaskStatusEnum) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: TaskStatusEnum) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: TaskStatusEnum) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<TaskStatusEnum>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<TaskStatusEnum>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: TaskStatusEnum) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: TaskStatusEnum) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskTerminationStatusEnumFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<TaskTerminationStatusEnum>,
	#[serde(rename = "ne")]
	pub ne: Option<TaskTerminationStatusEnum>,
	#[serde(rename = "gt")]
	pub gt: Option<TaskTerminationStatusEnum>,
	#[serde(rename = "gte")]
	pub gte: Option<TaskTerminationStatusEnum>,
	#[serde(rename = "lt")]
	pub lt: Option<TaskTerminationStatusEnum>,
	#[serde(rename = "lte")]
	pub lte: Option<TaskTerminationStatusEnum>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<TaskTerminationStatusEnum>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<TaskTerminationStatusEnum>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<TaskTerminationStatusEnum>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<TaskTerminationStatusEnum>,
}
impl TaskTerminationStatusEnumFilterInput {
	pub fn set_eq(mut self, eq: TaskTerminationStatusEnum) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: TaskTerminationStatusEnum) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: TaskTerminationStatusEnum) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: TaskTerminationStatusEnum) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: TaskTerminationStatusEnum) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: TaskTerminationStatusEnum) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<TaskTerminationStatusEnum>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<TaskTerminationStatusEnum>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: TaskTerminationStatusEnum) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: TaskTerminationStatusEnum) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskTypeEnumFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<TaskTypeEnum>,
	#[serde(rename = "ne")]
	pub ne: Option<TaskTypeEnum>,
	#[serde(rename = "gt")]
	pub gt: Option<TaskTypeEnum>,
	#[serde(rename = "gte")]
	pub gte: Option<TaskTypeEnum>,
	#[serde(rename = "lt")]
	pub lt: Option<TaskTypeEnum>,
	#[serde(rename = "lte")]
	pub lte: Option<TaskTypeEnum>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<TaskTypeEnum>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<TaskTypeEnum>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<TaskTypeEnum>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<TaskTypeEnum>,
}
impl TaskTypeEnumFilterInput {
	pub fn set_eq(mut self, eq: TaskTypeEnum) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: TaskTypeEnum) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: TaskTypeEnum) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: TaskTypeEnum) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: TaskTypeEnum) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: TaskTypeEnum) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<TaskTypeEnum>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<TaskTypeEnum>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: TaskTypeEnum) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: TaskTypeEnum) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateTaskFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "terminationStatus")]
	pub termination_status: Option<TaskTerminationStatusEnumFilterInput>,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<StringFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<TerminateTaskFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<TerminateTaskFilterInput>>>,
}
impl TerminateTaskFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_termination_status(
		mut self,
		termination_status: TaskTerminationStatusEnumFilterInput,
	) -> Self {
		self.termination_status = Some(termination_status);
		self
	}
	pub fn set_termination_reason(mut self, termination_reason: StringFilterInput) -> Self {
		self.termination_reason = Some(termination_reason);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<TerminateTaskFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<TerminateTaskFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(termination_status) = &self.termination_status {
			query.push(SelectionSet {
				operation: "terminationStatus",
				alias: None,
				fields: Some(termination_status.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(termination_reason) = &self.termination_reason {
			query.push(SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: Some(termination_reason.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateTaskInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "terminationStatus")]
	pub termination_status: TaskTerminationStatusEnum,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl TerminateTaskInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_termination_status(mut self, termination_status: TaskTerminationStatusEnum) -> Self {
		self.termination_status = termination_status;
		self
	}
	pub fn set_termination_reason(mut self, termination_reason: String) -> Self {
		self.termination_reason = Some(termination_reason);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "terminationStatus",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.termination_reason.is_some() {
			query.push(SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateTaskOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "terminationStatus")]
	pub termination_status: Option<OrderByEnum>,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<OrderByEnum>,
	#[serde(rename = "workflowOutput")]
	pub workflow_output: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl TerminateTaskOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_termination_status(mut self, termination_status: OrderByEnum) -> Self {
		self.termination_status = Some(termination_status);
		self
	}
	pub fn set_termination_reason(mut self, termination_reason: OrderByEnum) -> Self {
		self.termination_reason = Some(termination_reason);
		self
	}
	pub fn set_workflow_output(mut self, workflow_output: OrderByEnum) -> Self {
		self.workflow_output = Some(workflow_output);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.termination_status.is_some() {
			query.push(SelectionSet {
				operation: "terminationStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.termination_reason.is_some() {
			query.push(SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_output.is_some() {
			query.push(SelectionSet {
				operation: "workflowOutput",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateTaskUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "terminationStatus")]
	pub termination_status: Option<TaskTerminationStatusEnum>,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl TerminateTaskUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_termination_status(mut self, termination_status: TaskTerminationStatusEnum) -> Self {
		self.termination_status = Some(termination_status);
		self
	}
	pub fn set_termination_reason(mut self, termination_reason: String) -> Self {
		self.termination_reason = Some(termination_reason);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.termination_status.is_some() {
			query.push(SelectionSet {
				operation: "terminationStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.termination_reason.is_some() {
			query.push(SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateWorkflowFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<StringFilterInput>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: Option<BooleanFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<TerminateWorkflowFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<TerminateWorkflowFilterInput>>>,
}
impl TerminateWorkflowFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_termination_reason(mut self, termination_reason: StringFilterInput) -> Self {
		self.termination_reason = Some(termination_reason);
		self
	}
	pub fn set_trigger_failure_workflow(
		mut self,
		trigger_failure_workflow: BooleanFilterInput,
	) -> Self {
		self.trigger_failure_workflow = Some(trigger_failure_workflow);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<TerminateWorkflowFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<TerminateWorkflowFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(termination_reason) = &self.termination_reason {
			query.push(SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: Some(termination_reason.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(trigger_failure_workflow) = &self.trigger_failure_workflow {
			query.push(SelectionSet {
				operation: "triggerFailureWorkflow",
				alias: None,
				fields: Some(trigger_failure_workflow.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateWorkflowInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<String>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: bool,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl TerminateWorkflowInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_termination_reason(mut self, termination_reason: String) -> Self {
		self.termination_reason = Some(termination_reason);
		self
	}
	pub fn set_trigger_failure_workflow(mut self, trigger_failure_workflow: bool) -> Self {
		self.trigger_failure_workflow = trigger_failure_workflow;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.termination_reason.is_some() {
			query.push(SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query.push(SelectionSet {
			operation: "triggerFailureWorkflow",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateWorkflowOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "workflowId")]
	pub workflow_id: Option<OrderByEnum>,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<OrderByEnum>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl TerminateWorkflowOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_workflow_id(mut self, workflow_id: OrderByEnum) -> Self {
		self.workflow_id = Some(workflow_id);
		self
	}
	pub fn set_termination_reason(mut self, termination_reason: OrderByEnum) -> Self {
		self.termination_reason = Some(termination_reason);
		self
	}
	pub fn set_trigger_failure_workflow(mut self, trigger_failure_workflow: OrderByEnum) -> Self {
		self.trigger_failure_workflow = Some(trigger_failure_workflow);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_id.is_some() {
			query.push(SelectionSet {
				operation: "workflowId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.termination_reason.is_some() {
			query.push(SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.trigger_failure_workflow.is_some() {
			query.push(SelectionSet {
				operation: "triggerFailureWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateWorkflowUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<String>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl TerminateWorkflowUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_termination_reason(mut self, termination_reason: String) -> Self {
		self.termination_reason = Some(termination_reason);
		self
	}
	pub fn set_trigger_failure_workflow(mut self, trigger_failure_workflow: bool) -> Self {
		self.trigger_failure_workflow = Some(trigger_failure_workflow);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.termination_reason.is_some() {
			query.push(SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.trigger_failure_workflow.is_some() {
			query.push(SelectionSet {
				operation: "triggerFailureWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TextFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<String>,
	#[serde(rename = "ne")]
	pub ne: Option<String>,
	#[serde(rename = "gt")]
	pub gt: Option<String>,
	#[serde(rename = "gte")]
	pub gte: Option<String>,
	#[serde(rename = "lt")]
	pub lt: Option<String>,
	#[serde(rename = "lte")]
	pub lte: Option<String>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<String>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<String>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<String>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<String>,
	#[serde(rename = "between")]
	pub between: Option<Vec<String>>,
	#[serde(rename = "not_between")]
	pub not_between: Option<Vec<String>>,
}
impl TextFilterInput {
	pub fn set_eq(mut self, eq: String) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: String) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: String) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: String) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: String) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: String) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<String>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<String>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: String) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: String) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn set_between(mut self, between: Vec<String>) -> Self {
		self.between = Some(between);
		self
	}
	pub fn set_not_between(mut self, not_between: Vec<String>) -> Self {
		self.not_between = Some(not_between);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.between.is_some() {
			query.push(SelectionSet {
				operation: "between",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.not_between.is_some() {
			query.push(SelectionSet {
				operation: "not_between",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TimeoutPolicyEnumFilterInput {
	#[serde(rename = "eq")]
	pub eq: Option<TimeoutPolicyEnum>,
	#[serde(rename = "ne")]
	pub ne: Option<TimeoutPolicyEnum>,
	#[serde(rename = "gt")]
	pub gt: Option<TimeoutPolicyEnum>,
	#[serde(rename = "gte")]
	pub gte: Option<TimeoutPolicyEnum>,
	#[serde(rename = "lt")]
	pub lt: Option<TimeoutPolicyEnum>,
	#[serde(rename = "lte")]
	pub lte: Option<TimeoutPolicyEnum>,
	#[serde(rename = "is_in")]
	pub is_in: Option<Vec<TimeoutPolicyEnum>>,
	#[serde(rename = "is_not_in")]
	pub is_not_in: Option<Vec<TimeoutPolicyEnum>>,
	#[serde(rename = "is_null")]
	pub is_null: Option<TimeoutPolicyEnum>,
	#[serde(rename = "is_not_null")]
	pub is_not_null: Option<TimeoutPolicyEnum>,
}
impl TimeoutPolicyEnumFilterInput {
	pub fn set_eq(mut self, eq: TimeoutPolicyEnum) -> Self {
		self.eq = Some(eq);
		self
	}
	pub fn set_ne(mut self, ne: TimeoutPolicyEnum) -> Self {
		self.ne = Some(ne);
		self
	}
	pub fn set_gt(mut self, gt: TimeoutPolicyEnum) -> Self {
		self.gt = Some(gt);
		self
	}
	pub fn set_gte(mut self, gte: TimeoutPolicyEnum) -> Self {
		self.gte = Some(gte);
		self
	}
	pub fn set_lt(mut self, lt: TimeoutPolicyEnum) -> Self {
		self.lt = Some(lt);
		self
	}
	pub fn set_lte(mut self, lte: TimeoutPolicyEnum) -> Self {
		self.lte = Some(lte);
		self
	}
	pub fn set_is_in(mut self, is_in: Vec<TimeoutPolicyEnum>) -> Self {
		self.is_in = Some(is_in);
		self
	}
	pub fn set_is_not_in(mut self, is_not_in: Vec<TimeoutPolicyEnum>) -> Self {
		self.is_not_in = Some(is_not_in);
		self
	}
	pub fn set_is_null(mut self, is_null: TimeoutPolicyEnum) -> Self {
		self.is_null = Some(is_null);
		self
	}
	pub fn set_is_not_null(mut self, is_not_null: TimeoutPolicyEnum) -> Self {
		self.is_not_null = Some(is_not_null);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.eq.is_some() {
			query.push(SelectionSet {
				operation: "eq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.ne.is_some() {
			query.push(SelectionSet {
				operation: "ne",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gt.is_some() {
			query.push(SelectionSet {
				operation: "gt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.gte.is_some() {
			query.push(SelectionSet {
				operation: "gte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lt.is_some() {
			query.push(SelectionSet {
				operation: "lt",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.lte.is_some() {
			query.push(SelectionSet {
				operation: "lte",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_in.is_some() {
			query.push(SelectionSet {
				operation: "is_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_in.is_some() {
			query.push(SelectionSet {
				operation: "is_not_in",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_null.is_some() {
			query.push(SelectionSet {
				operation: "is_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.is_not_null.is_some() {
			query.push(SelectionSet {
				operation: "is_not_null",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateSecretFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "secretKey")]
	pub secret_key: Option<StringFilterInput>,
	#[serde(rename = "secretValue")]
	pub secret_value: Option<StringFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<UpdateSecretFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<UpdateSecretFilterInput>>>,
}
impl UpdateSecretFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_secret_key(mut self, secret_key: StringFilterInput) -> Self {
		self.secret_key = Some(secret_key);
		self
	}
	pub fn set_secret_value(mut self, secret_value: StringFilterInput) -> Self {
		self.secret_value = Some(secret_value);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<UpdateSecretFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<UpdateSecretFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(secret_key) = &self.secret_key {
			query.push(SelectionSet {
				operation: "secretKey",
				alias: None,
				fields: Some(secret_key.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(secret_value) = &self.secret_value {
			query.push(SelectionSet {
				operation: "secretValue",
				alias: None,
				fields: Some(secret_value.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateSecretInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "secretKey")]
	pub secret_key: String,
	#[serde(rename = "secretValue")]
	pub secret_value: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl UpdateSecretInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_secret_key(mut self, secret_key: String) -> Self {
		self.secret_key = secret_key;
		self
	}
	pub fn set_secret_value(mut self, secret_value: String) -> Self {
		self.secret_value = secret_value;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "secretKey",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "secretValue",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateSecretOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "secretKey")]
	pub secret_key: Option<OrderByEnum>,
	#[serde(rename = "secretValue")]
	pub secret_value: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl UpdateSecretOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_secret_key(mut self, secret_key: OrderByEnum) -> Self {
		self.secret_key = Some(secret_key);
		self
	}
	pub fn set_secret_value(mut self, secret_value: OrderByEnum) -> Self {
		self.secret_value = Some(secret_value);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.secret_key.is_some() {
			query.push(SelectionSet {
				operation: "secretKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.secret_value.is_some() {
			query.push(SelectionSet {
				operation: "secretValue",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateSecretUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "secretKey")]
	pub secret_key: Option<String>,
	#[serde(rename = "secretValue")]
	pub secret_value: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl UpdateSecretUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_secret_key(mut self, secret_key: String) -> Self {
		self.secret_key = Some(secret_key);
		self
	}
	pub fn set_secret_value(mut self, secret_value: String) -> Self {
		self.secret_value = Some(secret_value);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.secret_key.is_some() {
			query.push(SelectionSet {
				operation: "secretKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.secret_value.is_some() {
			query.push(SelectionSet {
				operation: "secretValue",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateTaskFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "taskStatus")]
	pub task_status: Option<TaskStatusEnumFilterInput>,
	#[serde(rename = "workflowId")]
	pub workflow_id: Option<StringFilterInput>,
	#[serde(rename = "taskRefName")]
	pub task_ref_name: Option<StringFilterInput>,
	#[serde(rename = "taskId")]
	pub task_id: Option<StringFilterInput>,
	#[serde(rename = "mergeOutput")]
	pub merge_output: Option<BooleanFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<UpdateTaskFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<UpdateTaskFilterInput>>>,
}
impl UpdateTaskFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_status(mut self, task_status: TaskStatusEnumFilterInput) -> Self {
		self.task_status = Some(task_status);
		self
	}
	pub fn set_workflow_id(mut self, workflow_id: StringFilterInput) -> Self {
		self.workflow_id = Some(workflow_id);
		self
	}
	pub fn set_task_ref_name(mut self, task_ref_name: StringFilterInput) -> Self {
		self.task_ref_name = Some(task_ref_name);
		self
	}
	pub fn set_task_id(mut self, task_id: StringFilterInput) -> Self {
		self.task_id = Some(task_id);
		self
	}
	pub fn set_merge_output(mut self, merge_output: BooleanFilterInput) -> Self {
		self.merge_output = Some(merge_output);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<UpdateTaskFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<UpdateTaskFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_status) = &self.task_status {
			query.push(SelectionSet {
				operation: "taskStatus",
				alias: None,
				fields: Some(task_status.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(workflow_id) = &self.workflow_id {
			query.push(SelectionSet {
				operation: "workflowId",
				alias: None,
				fields: Some(workflow_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_ref_name) = &self.task_ref_name {
			query.push(SelectionSet {
				operation: "taskRefName",
				alias: None,
				fields: Some(task_ref_name.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_id) = &self.task_id {
			query.push(SelectionSet {
				operation: "taskId",
				alias: None,
				fields: Some(task_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(merge_output) = &self.merge_output {
			query.push(SelectionSet {
				operation: "mergeOutput",
				alias: None,
				fields: Some(merge_output.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateTaskInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskStatus")]
	pub task_status: TaskStatusEnum,
	#[serde(rename = "workflowId")]
	pub workflow_id: Option<String>,
	#[serde(rename = "taskRefName")]
	pub task_ref_name: Option<String>,
	#[serde(rename = "taskId")]
	pub task_id: Option<String>,
	#[serde(rename = "mergeOutput")]
	pub merge_output: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl UpdateTaskInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_task_status(mut self, task_status: TaskStatusEnum) -> Self {
		self.task_status = task_status;
		self
	}
	pub fn set_workflow_id(mut self, workflow_id: String) -> Self {
		self.workflow_id = Some(workflow_id);
		self
	}
	pub fn set_task_ref_name(mut self, task_ref_name: String) -> Self {
		self.task_ref_name = Some(task_ref_name);
		self
	}
	pub fn set_task_id(mut self, task_id: String) -> Self {
		self.task_id = Some(task_id);
		self
	}
	pub fn set_merge_output(mut self, merge_output: bool) -> Self {
		self.merge_output = Some(merge_output);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		query.push(SelectionSet {
			operation: "taskStatus",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.workflow_id.is_some() {
			query.push(SelectionSet {
				operation: "workflowId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_ref_name.is_some() {
			query.push(SelectionSet {
				operation: "taskRefName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_id.is_some() {
			query.push(SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.merge_output.is_some() {
			query.push(SelectionSet {
				operation: "mergeOutput",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateTaskOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "taskStatus")]
	pub task_status: Option<OrderByEnum>,
	#[serde(rename = "workflowId")]
	pub workflow_id: Option<OrderByEnum>,
	#[serde(rename = "taskRefName")]
	pub task_ref_name: Option<OrderByEnum>,
	#[serde(rename = "taskId")]
	pub task_id: Option<OrderByEnum>,
	#[serde(rename = "mergeOutput")]
	pub merge_output: Option<OrderByEnum>,
	#[serde(rename = "taskOutput")]
	pub task_output: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl UpdateTaskOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_status(mut self, task_status: OrderByEnum) -> Self {
		self.task_status = Some(task_status);
		self
	}
	pub fn set_workflow_id(mut self, workflow_id: OrderByEnum) -> Self {
		self.workflow_id = Some(workflow_id);
		self
	}
	pub fn set_task_ref_name(mut self, task_ref_name: OrderByEnum) -> Self {
		self.task_ref_name = Some(task_ref_name);
		self
	}
	pub fn set_task_id(mut self, task_id: OrderByEnum) -> Self {
		self.task_id = Some(task_id);
		self
	}
	pub fn set_merge_output(mut self, merge_output: OrderByEnum) -> Self {
		self.merge_output = Some(merge_output);
		self
	}
	pub fn set_task_output(mut self, task_output: OrderByEnum) -> Self {
		self.task_output = Some(task_output);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_status.is_some() {
			query.push(SelectionSet {
				operation: "taskStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_id.is_some() {
			query.push(SelectionSet {
				operation: "workflowId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_ref_name.is_some() {
			query.push(SelectionSet {
				operation: "taskRefName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_id.is_some() {
			query.push(SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.merge_output.is_some() {
			query.push(SelectionSet {
				operation: "mergeOutput",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_output.is_some() {
			query.push(SelectionSet {
				operation: "taskOutput",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateTaskUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "taskStatus")]
	pub task_status: Option<TaskStatusEnum>,
	#[serde(rename = "workflowId")]
	pub workflow_id: Option<String>,
	#[serde(rename = "taskRefName")]
	pub task_ref_name: Option<String>,
	#[serde(rename = "taskId")]
	pub task_id: Option<String>,
	#[serde(rename = "mergeOutput")]
	pub merge_output: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl UpdateTaskUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_status(mut self, task_status: TaskStatusEnum) -> Self {
		self.task_status = Some(task_status);
		self
	}
	pub fn set_workflow_id(mut self, workflow_id: String) -> Self {
		self.workflow_id = Some(workflow_id);
		self
	}
	pub fn set_task_ref_name(mut self, task_ref_name: String) -> Self {
		self.task_ref_name = Some(task_ref_name);
		self
	}
	pub fn set_task_id(mut self, task_id: String) -> Self {
		self.task_id = Some(task_id);
		self
	}
	pub fn set_merge_output(mut self, merge_output: bool) -> Self {
		self.merge_output = Some(merge_output);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_status.is_some() {
			query.push(SelectionSet {
				operation: "taskStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.workflow_id.is_some() {
			query.push(SelectionSet {
				operation: "workflowId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_ref_name.is_some() {
			query.push(SelectionSet {
				operation: "taskRefName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_id.is_some() {
			query.push(SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.merge_output.is_some() {
			query.push(SelectionSet {
				operation: "mergeOutput",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "until")]
	pub until: Option<TextFilterInput>,
	#[serde(rename = "duration")]
	pub duration: Option<StringFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<WaitFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<WaitFilterInput>>>,
}
impl WaitFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_until(mut self, until: TextFilterInput) -> Self {
		self.until = Some(until);
		self
	}
	pub fn set_duration(mut self, duration: StringFilterInput) -> Self {
		self.duration = Some(duration);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<WaitFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<WaitFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(until) = &self.until {
			query.push(SelectionSet {
				operation: "until",
				alias: None,
				fields: Some(until.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(duration) = &self.duration {
			query.push(SelectionSet {
				operation: "duration",
				alias: None,
				fields: Some(duration.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitForWebhookFilterInput {
	#[serde(rename = "id")]
	pub id: Option<TextFilterInput>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<TextFilterInput>,
	#[serde(rename = "and")]
	pub and: Option<Vec<Box<WaitForWebhookFilterInput>>>,
	#[serde(rename = "or")]
	pub or: Option<Vec<Box<WaitForWebhookFilterInput>>>,
}
impl WaitForWebhookFilterInput {
	pub fn set_id(mut self, id: TextFilterInput) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: TextFilterInput) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn set_and(mut self, and: Vec<Box<WaitForWebhookFilterInput>>) -> Self {
		self.and = Some(and);
		self
	}
	pub fn set_or(mut self, or: Vec<Box<WaitForWebhookFilterInput>>) -> Self {
		self.or = Some(or);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if let Some(id) = &self.id {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: Some(id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(task_model_id) = &self.task_model_id {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: Some(task_model_id.to_query()),
				arguments: None,
				is_union: false,
			});
		}
		if let Some(and) = &self.and {
			query.push(SelectionSet {
				operation: "and",
				alias: None,
				fields: match and.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		if let Some(or) = &self.or {
			query.push(SelectionSet {
				operation: "or",
				alias: None,
				fields: match or.get(0) {
					Some(d) => Some(d.to_query()),
					None => None,
				},
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitForWebhookInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl WaitForWebhookInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitForWebhookOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "matches")]
	pub matches: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl WaitForWebhookOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_matches(mut self, matches: OrderByEnum) -> Self {
		self.matches = Some(matches);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.matches.is_some() {
			query.push(SelectionSet {
				operation: "matches",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitForWebhookUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl WaitForWebhookUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitInsertInput {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "until")]
	pub until: Option<String>,
	#[serde(rename = "duration")]
	pub duration: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl WaitInsertInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = id;
		self
	}
	pub fn set_until(mut self, until: String) -> Self {
		self.until = Some(until);
		self
	}
	pub fn set_duration(mut self, duration: String) -> Self {
		self.duration = Some(duration);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		query.push(SelectionSet {
			operation: "id",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		});
		if self.until.is_some() {
			query.push(SelectionSet {
				operation: "until",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.duration.is_some() {
			query.push(SelectionSet {
				operation: "duration",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitOrderInput {
	#[serde(rename = "id")]
	pub id: Option<OrderByEnum>,
	#[serde(rename = "until")]
	pub until: Option<OrderByEnum>,
	#[serde(rename = "duration")]
	pub duration: Option<OrderByEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<OrderByEnum>,
}
impl WaitOrderInput {
	pub fn set_id(mut self, id: OrderByEnum) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_until(mut self, until: OrderByEnum) -> Self {
		self.until = Some(until);
		self
	}
	pub fn set_duration(mut self, duration: OrderByEnum) -> Self {
		self.duration = Some(duration);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: OrderByEnum) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.until.is_some() {
			query.push(SelectionSet {
				operation: "until",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.duration.is_some() {
			query.push(SelectionSet {
				operation: "duration",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitUpdateInput {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "until")]
	pub until: Option<String>,
	#[serde(rename = "duration")]
	pub duration: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl WaitUpdateInput {
	pub fn set_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}
	pub fn set_until(mut self, until: String) -> Self {
		self.until = Some(until);
		self
	}
	pub fn set_duration(mut self, duration: String) -> Self {
		self.duration = Some(duration);
		self
	}
	pub fn set_task_model_id(mut self, task_model_id: String) -> Self {
		self.task_model_id = Some(task_model_id);
		self
	}
	pub fn to_query(&self) -> Vec<SelectionSet> {
		let mut query = Vec::new();
		if self.id.is_some() {
			query.push(SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.until.is_some() {
			query.push(SelectionSet {
				operation: "until",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.duration.is_some() {
			query.push(SelectionSet {
				operation: "duration",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		if self.task_model_id.is_some() {
			query.push(SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			});
		}
		query
	}
}
