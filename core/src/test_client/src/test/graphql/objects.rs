// DO NOT EDIT THIS FILE
// This file was generated by https://github.com/tacogips/async-graphql-reverse

use super::enums::EvaluatorTypeEnum;
use super::enums::ForkTypeEnum;
use super::enums::IdempotencyStrategyEnum;
use super::enums::OperationTypeEnum;
use super::enums::RetryLogicEnum;
use super::enums::TaskStatusEnum;
use super::enums::TaskTerminationStatusEnum;
use super::enums::TaskTypeEnum;
use super::enums::TimeoutPolicyEnum;
use super::input_objects::BuissnessRuleFilterInput;
use super::input_objects::BuissnessRuleInsertInput;
use super::input_objects::BuissnessRuleOrderInput;
use super::input_objects::BuissnessRuleUpdateInput;
use super::input_objects::DoWhileFilterInput;
use super::input_objects::DoWhileInsertInput;
use super::input_objects::DoWhileOrderInput;
use super::input_objects::DoWhileUpdateInput;
use super::input_objects::DynamicFilterInput;
use super::input_objects::DynamicForkFilterInput;
use super::input_objects::DynamicForkInsertInput;
use super::input_objects::DynamicForkOrderInput;
use super::input_objects::DynamicForkUpdateInput;
use super::input_objects::DynamicInsertInput;
use super::input_objects::DynamicOrderInput;
use super::input_objects::DynamicUpdateInput;
use super::input_objects::EventFilterInput;
use super::input_objects::EventInsertInput;
use super::input_objects::EventOrderInput;
use super::input_objects::EventUpdateInput;
use super::input_objects::ForkFilterInput;
use super::input_objects::ForkInsertInput;
use super::input_objects::ForkOrderInput;
use super::input_objects::ForkUpdateInput;
use super::input_objects::GetSignedJwtFilterInput;
use super::input_objects::GetSignedJwtInsertInput;
use super::input_objects::GetSignedJwtOrderInput;
use super::input_objects::GetSignedJwtUpdateInput;
use super::input_objects::GetWorkflowFilterInput;
use super::input_objects::GetWorkflowInsertInput;
use super::input_objects::GetWorkflowOrderInput;
use super::input_objects::GetWorkflowUpdateInput;
use super::input_objects::HttpFilterInput;
use super::input_objects::HttpInsertInput;
use super::input_objects::HttpOrderInput;
use super::input_objects::HttpUpdateInput;
use super::input_objects::HumanFilterInput;
use super::input_objects::HumanInsertInput;
use super::input_objects::HumanOrderInput;
use super::input_objects::HumanUpdateInput;
use super::input_objects::InlineFilterInput;
use super::input_objects::InlineInsertInput;
use super::input_objects::InlineOrderInput;
use super::input_objects::InlineUpdateInput;
use super::input_objects::JoinFilterInput;
use super::input_objects::JoinInsertInput;
use super::input_objects::JoinOrderInput;
use super::input_objects::JoinUpdateInput;
use super::input_objects::JsonTransformFilterInput;
use super::input_objects::JsonTransformInsertInput;
use super::input_objects::JsonTransformOrderInput;
use super::input_objects::JsonTransformUpdateInput;
use super::input_objects::PaginationInput;
use super::input_objects::PollDataFilterInput;
use super::input_objects::PollDataInsertInput;
use super::input_objects::PollDataOrderInput;
use super::input_objects::PollDataUpdateInput;
use super::input_objects::SetVariableFilterInput;
use super::input_objects::SetVariableInsertInput;
use super::input_objects::SetVariableOrderInput;
use super::input_objects::SetVariableUpdateInput;
use super::input_objects::SimpleFilterInput;
use super::input_objects::SimpleInsertInput;
use super::input_objects::SimpleOrderInput;
use super::input_objects::SimpleUpdateInput;
use super::input_objects::SqlFilterInput;
use super::input_objects::SqlInsertInput;
use super::input_objects::SqlOrderInput;
use super::input_objects::SqlUpdateInput;
use super::input_objects::StartWorkflowFilterInput;
use super::input_objects::StartWorkflowInsertInput;
use super::input_objects::StartWorkflowOrderInput;
use super::input_objects::StartWorkflowUpdateInput;
use super::input_objects::SubWorkflowFilterInput;
use super::input_objects::SubWorkflowInsertInput;
use super::input_objects::SubWorkflowOrderInput;
use super::input_objects::SubWorkflowUpdateInput;
use super::input_objects::SwitchFilterInput;
use super::input_objects::SwitchInsertInput;
use super::input_objects::SwitchOrderInput;
use super::input_objects::SwitchUpdateInput;
use super::input_objects::TaskConfigFilterInput;
use super::input_objects::TaskConfigInsertInput;
use super::input_objects::TaskConfigOrderInput;
use super::input_objects::TaskConfigUpdateInput;
use super::input_objects::TaskDefinitionFilterInput;
use super::input_objects::TaskDefinitionInsertInput;
use super::input_objects::TaskDefinitionOrderInput;
use super::input_objects::TaskDefinitionUpdateInput;
use super::input_objects::TaskExecutionLogFilterInput;
use super::input_objects::TaskExecutionLogInsertInput;
use super::input_objects::TaskExecutionLogOrderInput;
use super::input_objects::TaskExecutionLogUpdateInput;
use super::input_objects::TaskModelFilterInput;
use super::input_objects::TaskModelInsertInput;
use super::input_objects::TaskModelOrderInput;
use super::input_objects::TaskModelUpdateInput;
use super::input_objects::TerminateTaskFilterInput;
use super::input_objects::TerminateTaskInsertInput;
use super::input_objects::TerminateTaskOrderInput;
use super::input_objects::TerminateTaskUpdateInput;
use super::input_objects::TerminateWorkflowFilterInput;
use super::input_objects::TerminateWorkflowInsertInput;
use super::input_objects::TerminateWorkflowOrderInput;
use super::input_objects::TerminateWorkflowUpdateInput;
use super::input_objects::UpdateSecretFilterInput;
use super::input_objects::UpdateSecretInsertInput;
use super::input_objects::UpdateSecretOrderInput;
use super::input_objects::UpdateSecretUpdateInput;
use super::input_objects::UpdateTaskFilterInput;
use super::input_objects::UpdateTaskInsertInput;
use super::input_objects::UpdateTaskOrderInput;
use super::input_objects::UpdateTaskUpdateInput;
use super::input_objects::WaitFilterInput;
use super::input_objects::WaitForWebhookFilterInput;
use super::input_objects::WaitForWebhookInsertInput;
use super::input_objects::WaitForWebhookOrderInput;
use super::input_objects::WaitForWebhookUpdateInput;
use super::input_objects::WaitInsertInput;
use super::input_objects::WaitOrderInput;
use super::input_objects::WaitUpdateInput;
use sdk::prelude::*;
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BuissnessRule {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "ruleFileLocation")]
	pub rule_file_location: String,
	#[serde(rename = "executionStrategy")]
	pub execution_strategy: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl BuissnessRule {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn rule_file_location(&self) -> String {
		self.rule_file_location.clone()
	}
	pub async fn execution_strategy(&self) -> String {
		self.execution_strategy.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "ruleFileLocation",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "executionStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BuissnessRuleBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "ruleFileLocation")]
	pub rule_file_location: String,
	#[serde(rename = "executionStrategy")]
	pub execution_strategy: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl BuissnessRuleBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn rule_file_location(&self) -> String {
		self.rule_file_location.clone()
	}
	pub async fn execution_strategy(&self) -> String {
		self.execution_strategy.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "ruleFileLocation",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "executionStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BuissnessRuleConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<BuissnessRule>,
	#[serde(rename = "edges")]
	pub edges: Vec<BuissnessRuleEdge>,
}
impl BuissnessRuleConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<BuissnessRule> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<BuissnessRuleEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(BuissnessRule::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(BuissnessRuleEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BuissnessRuleEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: BuissnessRule,
}
impl BuissnessRuleEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> BuissnessRule {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(BuissnessRule::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DoWhile {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: EvaluatorTypeEnum,
	#[serde(rename = "loopCondition")]
	pub loop_condition: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl DoWhile {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn evaluator_type(&self) -> EvaluatorTypeEnum {
		self.evaluator_type.clone()
	}
	pub async fn loop_condition(&self) -> String {
		self.loop_condition.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "loopCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DoWhileBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: EvaluatorTypeEnum,
	#[serde(rename = "loopCondition")]
	pub loop_condition: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl DoWhileBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn evaluator_type(&self) -> EvaluatorTypeEnum {
		self.evaluator_type.clone()
	}
	pub async fn loop_condition(&self) -> String {
		self.loop_condition.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "loopCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DoWhileConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<DoWhile>,
	#[serde(rename = "edges")]
	pub edges: Vec<DoWhileEdge>,
}
impl DoWhileConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<DoWhile> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<DoWhileEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(DoWhile::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(DoWhileEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DoWhileEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: DoWhile,
}
impl DoWhileEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> DoWhile {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(DoWhile::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Dynamic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "dynamicTaskName")]
	pub dynamic_task_name: String,
	#[serde(rename = "subWorkflowName")]
	pub sub_workflow_name: Option<String>,
	#[serde(rename = "subWorkflowVersion")]
	pub sub_workflow_version: Option<i64>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl Dynamic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn dynamic_task_name(&self) -> String {
		self.dynamic_task_name.clone()
	}
	pub async fn sub_workflow_name(&self) -> Option<String> {
		self.sub_workflow_name.clone()
	}
	pub async fn sub_workflow_version(&self) -> Option<i64> {
		self.sub_workflow_version
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "dynamicTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "subWorkflowName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "subWorkflowVersion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "dynamicTaskName")]
	pub dynamic_task_name: String,
	#[serde(rename = "subWorkflowName")]
	pub sub_workflow_name: Option<String>,
	#[serde(rename = "subWorkflowVersion")]
	pub sub_workflow_version: Option<i64>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl DynamicBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn dynamic_task_name(&self) -> String {
		self.dynamic_task_name.clone()
	}
	pub async fn sub_workflow_name(&self) -> Option<String> {
		self.sub_workflow_name.clone()
	}
	pub async fn sub_workflow_version(&self) -> Option<i64> {
		self.sub_workflow_version
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "dynamicTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "subWorkflowName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "subWorkflowVersion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<Dynamic>,
	#[serde(rename = "edges")]
	pub edges: Vec<DynamicEdge>,
}
impl DynamicConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<Dynamic> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<DynamicEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(Dynamic::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(DynamicEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: Dynamic,
}
impl DynamicEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> Dynamic {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(Dynamic::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicFork {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "forkType")]
	pub fork_type: ForkTypeEnum,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "forkTaskName")]
	pub fork_task_name: Option<String>,
	#[serde(rename = "forkTaskWorkflow")]
	pub fork_task_workflow: Option<String>,
	#[serde(rename = "forkTaskWorkflowVersion")]
	pub fork_task_workflow_version: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl DynamicFork {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn fork_type(&self) -> ForkTypeEnum {
		self.fork_type.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn fork_task_name(&self) -> Option<String> {
		self.fork_task_name.clone()
	}
	pub async fn fork_task_workflow(&self) -> Option<String> {
		self.fork_task_workflow.clone()
	}
	pub async fn fork_task_workflow_version(&self) -> Option<String> {
		self.fork_task_workflow_version.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "forkType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "forkTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "forkTaskWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "forkTaskWorkflowVersion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicForkBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "forkType")]
	pub fork_type: ForkTypeEnum,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "forkTaskName")]
	pub fork_task_name: Option<String>,
	#[serde(rename = "forkTaskWorkflow")]
	pub fork_task_workflow: Option<String>,
	#[serde(rename = "forkTaskWorkflowVersion")]
	pub fork_task_workflow_version: Option<String>,
}
impl DynamicForkBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn fork_type(&self) -> ForkTypeEnum {
		self.fork_type.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn fork_task_name(&self) -> Option<String> {
		self.fork_task_name.clone()
	}
	pub async fn fork_task_workflow(&self) -> Option<String> {
		self.fork_task_workflow.clone()
	}
	pub async fn fork_task_workflow_version(&self) -> Option<String> {
		self.fork_task_workflow_version.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "forkType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "forkTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "forkTaskWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "forkTaskWorkflowVersion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicForkConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<DynamicFork>,
	#[serde(rename = "edges")]
	pub edges: Vec<DynamicForkEdge>,
}
impl DynamicForkConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<DynamicFork> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<DynamicForkEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(DynamicFork::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(DynamicForkEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DynamicForkEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: DynamicFork,
}
impl DynamicForkEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> DynamicFork {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(DynamicFork::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Event {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "sink")]
	pub sink: String,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl Event {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn sink(&self) -> String {
		self.sink.clone()
	}
	pub async fn async_complete(&self) -> Option<bool> {
		self.async_complete
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "sink",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct EventBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "sink")]
	pub sink: String,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl EventBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn sink(&self) -> String {
		self.sink.clone()
	}
	pub async fn async_complete(&self) -> Option<bool> {
		self.async_complete
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "sink",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct EventConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<Event>,
	#[serde(rename = "edges")]
	pub edges: Vec<EventEdge>,
}
impl EventConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<Event> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<EventEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(Event::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(EventEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct EventEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: Event,
}
impl EventEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> Event {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(Event::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Fork {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl Fork {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ForkBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl ForkBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ForkConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<Fork>,
	#[serde(rename = "edges")]
	pub edges: Vec<ForkEdge>,
}
impl ForkConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<Fork> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<ForkEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(Fork::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(ForkEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ForkEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: Fork,
}
impl ForkEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> Fork {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(Fork::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetSignedJwt {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "subject")]
	pub subject: String,
	#[serde(rename = "issuer")]
	pub issuer: String,
	#[serde(rename = "privateKey")]
	pub private_key: String,
	#[serde(rename = "privateKeyId")]
	pub private_key_id: String,
	#[serde(rename = "audience")]
	pub audience: String,
	#[serde(rename = "ttlInSeconds")]
	pub ttl_in_seconds: i64,
	#[serde(rename = "scopes")]
	pub scopes: String,
	#[serde(rename = "algorithm")]
	pub algorithm: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl GetSignedJwt {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn subject(&self) -> String {
		self.subject.clone()
	}
	pub async fn issuer(&self) -> String {
		self.issuer.clone()
	}
	pub async fn private_key(&self) -> String {
		self.private_key.clone()
	}
	pub async fn private_key_id(&self) -> String {
		self.private_key_id.clone()
	}
	pub async fn audience(&self) -> String {
		self.audience.clone()
	}
	pub async fn ttl_in_seconds(&self) -> i64 {
		self.ttl_in_seconds
	}
	pub async fn scopes(&self) -> String {
		self.scopes.clone()
	}
	pub async fn algorithm(&self) -> String {
		self.algorithm.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "subject",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "issuer",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "privateKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "privateKeyId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "audience",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "ttlInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "scopes",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "algorithm",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetSignedJwtBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "subject")]
	pub subject: String,
	#[serde(rename = "issuer")]
	pub issuer: String,
	#[serde(rename = "privateKey")]
	pub private_key: String,
	#[serde(rename = "privateKeyId")]
	pub private_key_id: String,
	#[serde(rename = "audience")]
	pub audience: String,
	#[serde(rename = "ttlInSeconds")]
	pub ttl_in_seconds: i64,
	#[serde(rename = "scopes")]
	pub scopes: String,
	#[serde(rename = "algorithm")]
	pub algorithm: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl GetSignedJwtBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn subject(&self) -> String {
		self.subject.clone()
	}
	pub async fn issuer(&self) -> String {
		self.issuer.clone()
	}
	pub async fn private_key(&self) -> String {
		self.private_key.clone()
	}
	pub async fn private_key_id(&self) -> String {
		self.private_key_id.clone()
	}
	pub async fn audience(&self) -> String {
		self.audience.clone()
	}
	pub async fn ttl_in_seconds(&self) -> i64 {
		self.ttl_in_seconds
	}
	pub async fn scopes(&self) -> String {
		self.scopes.clone()
	}
	pub async fn algorithm(&self) -> String {
		self.algorithm.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "subject",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "issuer",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "privateKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "privateKeyId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "audience",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "ttlInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "scopes",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "algorithm",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetSignedJwtConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<GetSignedJwt>,
	#[serde(rename = "edges")]
	pub edges: Vec<GetSignedJwtEdge>,
}
impl GetSignedJwtConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<GetSignedJwt> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<GetSignedJwtEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(GetSignedJwt::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(GetSignedJwtEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetSignedJwtEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: GetSignedJwt,
}
impl GetSignedJwtEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> GetSignedJwt {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(GetSignedJwt::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetWorkflow {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "includeTasks")]
	pub include_tasks: bool,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl GetWorkflow {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn include_tasks(&self) -> bool {
		self.include_tasks
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "includeTasks",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetWorkflowBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "includeTasks")]
	pub include_tasks: bool,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl GetWorkflowBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn include_tasks(&self) -> bool {
		self.include_tasks
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "includeTasks",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetWorkflowConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<GetWorkflow>,
	#[serde(rename = "edges")]
	pub edges: Vec<GetWorkflowEdge>,
}
impl GetWorkflowConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<GetWorkflow> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<GetWorkflowEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(GetWorkflow::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(GetWorkflowEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GetWorkflowEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: GetWorkflow,
}
impl GetWorkflowEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> GetWorkflow {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(GetWorkflow::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Http {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "uri")]
	pub uri: String,
	#[serde(rename = "method")]
	pub method: String,
	#[serde(rename = "accept")]
	pub accept: Option<String>,
	#[serde(rename = "contentType")]
	pub content_type: Option<String>,
	#[serde(rename = "terminationCondition")]
	pub termination_condition: Option<String>,
	#[serde(rename = "pollingInterval")]
	pub polling_interval: Option<i64>,
	#[serde(rename = "pollingStrategy")]
	pub polling_strategy: Option<String>,
	#[serde(rename = "encode")]
	pub encode: Option<bool>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl Http {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn uri(&self) -> String {
		self.uri.clone()
	}
	pub async fn method(&self) -> String {
		self.method.clone()
	}
	pub async fn accept(&self) -> Option<String> {
		self.accept.clone()
	}
	pub async fn content_type(&self) -> Option<String> {
		self.content_type.clone()
	}
	pub async fn termination_condition(&self) -> Option<String> {
		self.termination_condition.clone()
	}
	pub async fn polling_interval(&self) -> Option<i64> {
		self.polling_interval
	}
	pub async fn polling_strategy(&self) -> Option<String> {
		self.polling_strategy.clone()
	}
	pub async fn encode(&self) -> Option<bool> {
		self.encode
	}
	pub async fn async_complete(&self) -> Option<bool> {
		self.async_complete
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "uri",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "method",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "accept",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "contentType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "terminationCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "pollingInterval",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "pollingStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "encode",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HttpBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "uri")]
	pub uri: String,
	#[serde(rename = "method")]
	pub method: String,
	#[serde(rename = "accept")]
	pub accept: Option<String>,
	#[serde(rename = "contentType")]
	pub content_type: Option<String>,
	#[serde(rename = "terminationCondition")]
	pub termination_condition: Option<String>,
	#[serde(rename = "pollingInterval")]
	pub polling_interval: Option<i64>,
	#[serde(rename = "pollingStrategy")]
	pub polling_strategy: Option<String>,
	#[serde(rename = "encode")]
	pub encode: Option<bool>,
	#[serde(rename = "asyncComplete")]
	pub async_complete: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl HttpBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn uri(&self) -> String {
		self.uri.clone()
	}
	pub async fn method(&self) -> String {
		self.method.clone()
	}
	pub async fn accept(&self) -> Option<String> {
		self.accept.clone()
	}
	pub async fn content_type(&self) -> Option<String> {
		self.content_type.clone()
	}
	pub async fn termination_condition(&self) -> Option<String> {
		self.termination_condition.clone()
	}
	pub async fn polling_interval(&self) -> Option<i64> {
		self.polling_interval
	}
	pub async fn polling_strategy(&self) -> Option<String> {
		self.polling_strategy.clone()
	}
	pub async fn encode(&self) -> Option<bool> {
		self.encode
	}
	pub async fn async_complete(&self) -> Option<bool> {
		self.async_complete
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "uri",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "method",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "accept",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "contentType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "terminationCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "pollingInterval",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "pollingStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "encode",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HttpConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<Http>,
	#[serde(rename = "edges")]
	pub edges: Vec<HttpEdge>,
}
impl HttpConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<Http> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<HttpEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(Http::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(HttpEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HttpEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: Http,
}
impl HttpEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> Http {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(Http::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Human {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskType")]
	pub task_type: TaskTypeEnum,
	#[serde(rename = "status")]
	pub status: TaskStatusEnum,
	#[serde(rename = "startTime")]
	pub start_time: String,
	#[serde(rename = "assignmentCompletionStrategy")]
	pub assignment_completion_strategy: String,
	#[serde(rename = "displayName")]
	pub display_name: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl Human {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_type(&self) -> TaskTypeEnum {
		self.task_type.clone()
	}
	pub async fn status(&self) -> TaskStatusEnum {
		self.status.clone()
	}
	pub async fn start_time(&self) -> String {
		self.start_time.clone()
	}
	pub async fn assignment_completion_strategy(&self) -> String {
		self.assignment_completion_strategy.clone()
	}
	pub async fn display_name(&self) -> String {
		self.display_name.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "status",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "startTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "assignmentCompletionStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "displayName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HumanBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskType")]
	pub task_type: TaskTypeEnum,
	#[serde(rename = "status")]
	pub status: TaskStatusEnum,
	#[serde(rename = "startTime")]
	pub start_time: String,
	#[serde(rename = "assignmentCompletionStrategy")]
	pub assignment_completion_strategy: String,
	#[serde(rename = "displayName")]
	pub display_name: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl HumanBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_type(&self) -> TaskTypeEnum {
		self.task_type.clone()
	}
	pub async fn status(&self) -> TaskStatusEnum {
		self.status.clone()
	}
	pub async fn start_time(&self) -> String {
		self.start_time.clone()
	}
	pub async fn assignment_completion_strategy(&self) -> String {
		self.assignment_completion_strategy.clone()
	}
	pub async fn display_name(&self) -> String {
		self.display_name.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "status",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "startTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "assignmentCompletionStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "displayName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HumanConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<Human>,
	#[serde(rename = "edges")]
	pub edges: Vec<HumanEdge>,
}
impl HumanConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<Human> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<HumanEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(Human::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(HumanEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HumanEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: Human,
}
impl HumanEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> Human {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(Human::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Inline {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: EvaluatorTypeEnum,
	#[serde(rename = "expression")]
	pub expression: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl Inline {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn evaluator_type(&self) -> EvaluatorTypeEnum {
		self.evaluator_type.clone()
	}
	pub async fn expression(&self) -> String {
		self.expression.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct InlineBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: EvaluatorTypeEnum,
	#[serde(rename = "expression")]
	pub expression: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl InlineBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn evaluator_type(&self) -> EvaluatorTypeEnum {
		self.evaluator_type.clone()
	}
	pub async fn expression(&self) -> String {
		self.expression.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct InlineConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<Inline>,
	#[serde(rename = "edges")]
	pub edges: Vec<InlineEdge>,
}
impl InlineConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<Inline> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<InlineEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(Inline::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(InlineEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct InlineEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: Inline,
}
impl InlineEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> Inline {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(Inline::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Join {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "expression")]
	pub expression: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl Join {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn expression(&self) -> Option<String> {
		self.expression.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JoinBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "expression")]
	pub expression: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl JoinBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn expression(&self) -> Option<String> {
		self.expression.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JoinConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<Join>,
	#[serde(rename = "edges")]
	pub edges: Vec<JoinEdge>,
}
impl JoinConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<Join> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<JoinEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(Join::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(JoinEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JoinEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: Join,
}
impl JoinEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> Join {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(Join::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JsonTransform {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "queryExpression")]
	pub query_expression: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl JsonTransform {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn query_expression(&self) -> String {
		self.query_expression.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "queryExpression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JsonTransformBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "queryExpression")]
	pub query_expression: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl JsonTransformBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn query_expression(&self) -> String {
		self.query_expression.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "queryExpression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JsonTransformConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<JsonTransform>,
	#[serde(rename = "edges")]
	pub edges: Vec<JsonTransformEdge>,
}
impl JsonTransformConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<JsonTransform> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<JsonTransformEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(JsonTransform::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(JsonTransformEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JsonTransformEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: JsonTransform,
}
impl JsonTransformEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> JsonTransform {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(JsonTransform::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Debug, Clone)]
pub struct Mutation<'a> {
	pub client: GraphQLClient<'a>,
}
impl<'a> Mutation<'a> {
	pub async fn _ping(&self) -> Result<Option<String>> {
		let data = SelectionSet {
			operation: "_ping",
			alias: None,
			fields: None,
			arguments: None,
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Option<String>>(&query, "_ping").await
	}
	pub async fn buissness_rule_create_one(
		&self,
		data: BuissnessRuleInsertInput,
	) -> Result<BuissnessRuleBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "buissnessRuleCreateOne",
			alias: None,
			fields: Some(BuissnessRuleBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<BuissnessRuleBasic>(&query, "buissnessRuleCreateOne").await
	}
	pub async fn buissness_rule_create_batch(
		&self,
		data: Vec<BuissnessRuleInsertInput>,
	) -> Result<Vec<BuissnessRuleBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "buissnessRuleCreateBatch",
			alias: None,
			fields: Some(BuissnessRuleBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<BuissnessRuleBasic>>(&query, "buissnessRuleCreateBatch").await
	}
	pub async fn buissness_rule_update(
		&self,
		data: BuissnessRuleUpdateInput,
		filter: Option<BuissnessRuleFilterInput>,
	) -> Result<Vec<BuissnessRuleBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "buissnessRuleUpdate",
			alias: None,
			fields: Some(BuissnessRuleBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<BuissnessRuleBasic>>(&query, "buissnessRuleUpdate").await
	}
	pub async fn buissness_rule_delete(
		&self,
		filter: Option<BuissnessRuleFilterInput>,
	) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "buissnessRuleDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "buissnessRuleDelete").await
	}
	pub async fn do_while_create_one(&self, data: DoWhileInsertInput) -> Result<DoWhileBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "doWhileCreateOne",
			alias: None,
			fields: Some(DoWhileBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<DoWhileBasic>(&query, "doWhileCreateOne").await
	}
	pub async fn do_while_create_batch(
		&self,
		data: Vec<DoWhileInsertInput>,
	) -> Result<Vec<DoWhileBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "doWhileCreateBatch",
			alias: None,
			fields: Some(DoWhileBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<DoWhileBasic>>(&query, "doWhileCreateBatch").await
	}
	pub async fn do_while_update(
		&self,
		data: DoWhileUpdateInput,
		filter: Option<DoWhileFilterInput>,
	) -> Result<Vec<DoWhileBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "doWhileUpdate",
			alias: None,
			fields: Some(DoWhileBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<DoWhileBasic>>(&query, "doWhileUpdate").await
	}
	pub async fn do_while_delete(&self, filter: Option<DoWhileFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "doWhileDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "doWhileDelete").await
	}
	pub async fn dynamic_create_one(&self, data: DynamicInsertInput) -> Result<DynamicBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "dynamicCreateOne",
			alias: None,
			fields: Some(DynamicBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<DynamicBasic>(&query, "dynamicCreateOne").await
	}
	pub async fn dynamic_create_batch(
		&self,
		data: Vec<DynamicInsertInput>,
	) -> Result<Vec<DynamicBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "dynamicCreateBatch",
			alias: None,
			fields: Some(DynamicBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<DynamicBasic>>(&query, "dynamicCreateBatch").await
	}
	pub async fn dynamic_update(
		&self,
		data: DynamicUpdateInput,
		filter: Option<DynamicFilterInput>,
	) -> Result<Vec<DynamicBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "dynamicUpdate",
			alias: None,
			fields: Some(DynamicBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<DynamicBasic>>(&query, "dynamicUpdate").await
	}
	pub async fn dynamic_delete(&self, filter: Option<DynamicFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "dynamicDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "dynamicDelete").await
	}
	pub async fn dynamic_fork_create_one(
		&self,
		data: DynamicForkInsertInput,
	) -> Result<DynamicForkBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "dynamicForkCreateOne",
			alias: None,
			fields: Some(DynamicForkBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<DynamicForkBasic>(&query, "dynamicForkCreateOne").await
	}
	pub async fn dynamic_fork_create_batch(
		&self,
		data: Vec<DynamicForkInsertInput>,
	) -> Result<Vec<DynamicForkBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "dynamicForkCreateBatch",
			alias: None,
			fields: Some(DynamicForkBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<DynamicForkBasic>>(&query, "dynamicForkCreateBatch").await
	}
	pub async fn dynamic_fork_update(
		&self,
		data: DynamicForkUpdateInput,
		filter: Option<DynamicForkFilterInput>,
	) -> Result<Vec<DynamicForkBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "dynamicForkUpdate",
			alias: None,
			fields: Some(DynamicForkBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<DynamicForkBasic>>(&query, "dynamicForkUpdate").await
	}
	pub async fn dynamic_fork_delete(&self, filter: Option<DynamicForkFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "dynamicForkDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "dynamicForkDelete").await
	}
	pub async fn event_create_one(&self, data: EventInsertInput) -> Result<EventBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "eventCreateOne",
			alias: None,
			fields: Some(EventBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<EventBasic>(&query, "eventCreateOne").await
	}
	pub async fn event_create_batch(&self, data: Vec<EventInsertInput>) -> Result<Vec<EventBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "eventCreateBatch",
			alias: None,
			fields: Some(EventBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<EventBasic>>(&query, "eventCreateBatch").await
	}
	pub async fn event_update(
		&self,
		data: EventUpdateInput,
		filter: Option<EventFilterInput>,
	) -> Result<Vec<EventBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "eventUpdate",
			alias: None,
			fields: Some(EventBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<EventBasic>>(&query, "eventUpdate").await
	}
	pub async fn event_delete(&self, filter: Option<EventFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "eventDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "eventDelete").await
	}
	pub async fn fork_create_one(&self, data: ForkInsertInput) -> Result<ForkBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "forkCreateOne",
			alias: None,
			fields: Some(ForkBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<ForkBasic>(&query, "forkCreateOne").await
	}
	pub async fn fork_create_batch(&self, data: Vec<ForkInsertInput>) -> Result<Vec<ForkBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "forkCreateBatch",
			alias: None,
			fields: Some(ForkBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<ForkBasic>>(&query, "forkCreateBatch").await
	}
	pub async fn fork_update(
		&self,
		data: ForkUpdateInput,
		filter: Option<ForkFilterInput>,
	) -> Result<Vec<ForkBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "forkUpdate",
			alias: None,
			fields: Some(ForkBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<ForkBasic>>(&query, "forkUpdate").await
	}
	pub async fn fork_delete(&self, filter: Option<ForkFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "forkDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "forkDelete").await
	}
	pub async fn get_signed_jwt_create_one(
		&self,
		data: GetSignedJwtInsertInput,
	) -> Result<GetSignedJwtBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "getSignedJwtCreateOne",
			alias: None,
			fields: Some(GetSignedJwtBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<GetSignedJwtBasic>(&query, "getSignedJwtCreateOne").await
	}
	pub async fn get_signed_jwt_create_batch(
		&self,
		data: Vec<GetSignedJwtInsertInput>,
	) -> Result<Vec<GetSignedJwtBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "getSignedJwtCreateBatch",
			alias: None,
			fields: Some(GetSignedJwtBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<GetSignedJwtBasic>>(&query, "getSignedJwtCreateBatch").await
	}
	pub async fn get_signed_jwt_update(
		&self,
		data: GetSignedJwtUpdateInput,
		filter: Option<GetSignedJwtFilterInput>,
	) -> Result<Vec<GetSignedJwtBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "getSignedJwtUpdate",
			alias: None,
			fields: Some(GetSignedJwtBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<GetSignedJwtBasic>>(&query, "getSignedJwtUpdate").await
	}
	pub async fn get_signed_jwt_delete(
		&self,
		filter: Option<GetSignedJwtFilterInput>,
	) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "getSignedJwtDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "getSignedJwtDelete").await
	}
	pub async fn get_workflow_create_one(
		&self,
		data: GetWorkflowInsertInput,
	) -> Result<GetWorkflowBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "getWorkflowCreateOne",
			alias: None,
			fields: Some(GetWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<GetWorkflowBasic>(&query, "getWorkflowCreateOne").await
	}
	pub async fn get_workflow_create_batch(
		&self,
		data: Vec<GetWorkflowInsertInput>,
	) -> Result<Vec<GetWorkflowBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "getWorkflowCreateBatch",
			alias: None,
			fields: Some(GetWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<GetWorkflowBasic>>(&query, "getWorkflowCreateBatch").await
	}
	pub async fn get_workflow_update(
		&self,
		data: GetWorkflowUpdateInput,
		filter: Option<GetWorkflowFilterInput>,
	) -> Result<Vec<GetWorkflowBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "getWorkflowUpdate",
			alias: None,
			fields: Some(GetWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<GetWorkflowBasic>>(&query, "getWorkflowUpdate").await
	}
	pub async fn get_workflow_delete(&self, filter: Option<GetWorkflowFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "getWorkflowDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "getWorkflowDelete").await
	}
	pub async fn http_create_one(&self, data: HttpInsertInput) -> Result<HttpBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "httpCreateOne",
			alias: None,
			fields: Some(HttpBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<HttpBasic>(&query, "httpCreateOne").await
	}
	pub async fn http_create_batch(&self, data: Vec<HttpInsertInput>) -> Result<Vec<HttpBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "httpCreateBatch",
			alias: None,
			fields: Some(HttpBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<HttpBasic>>(&query, "httpCreateBatch").await
	}
	pub async fn http_update(
		&self,
		data: HttpUpdateInput,
		filter: Option<HttpFilterInput>,
	) -> Result<Vec<HttpBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "httpUpdate",
			alias: None,
			fields: Some(HttpBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<HttpBasic>>(&query, "httpUpdate").await
	}
	pub async fn http_delete(&self, filter: Option<HttpFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "httpDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "httpDelete").await
	}
	pub async fn human_create_one(&self, data: HumanInsertInput) -> Result<HumanBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "humanCreateOne",
			alias: None,
			fields: Some(HumanBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<HumanBasic>(&query, "humanCreateOne").await
	}
	pub async fn human_create_batch(&self, data: Vec<HumanInsertInput>) -> Result<Vec<HumanBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "humanCreateBatch",
			alias: None,
			fields: Some(HumanBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<HumanBasic>>(&query, "humanCreateBatch").await
	}
	pub async fn human_update(
		&self,
		data: HumanUpdateInput,
		filter: Option<HumanFilterInput>,
	) -> Result<Vec<HumanBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "humanUpdate",
			alias: None,
			fields: Some(HumanBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<HumanBasic>>(&query, "humanUpdate").await
	}
	pub async fn human_delete(&self, filter: Option<HumanFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "humanDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "humanDelete").await
	}
	pub async fn inline_create_one(&self, data: InlineInsertInput) -> Result<InlineBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "inlineCreateOne",
			alias: None,
			fields: Some(InlineBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<InlineBasic>(&query, "inlineCreateOne").await
	}
	pub async fn inline_create_batch(
		&self,
		data: Vec<InlineInsertInput>,
	) -> Result<Vec<InlineBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "inlineCreateBatch",
			alias: None,
			fields: Some(InlineBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<InlineBasic>>(&query, "inlineCreateBatch").await
	}
	pub async fn inline_update(
		&self,
		data: InlineUpdateInput,
		filter: Option<InlineFilterInput>,
	) -> Result<Vec<InlineBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "inlineUpdate",
			alias: None,
			fields: Some(InlineBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<InlineBasic>>(&query, "inlineUpdate").await
	}
	pub async fn inline_delete(&self, filter: Option<InlineFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "inlineDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "inlineDelete").await
	}
	pub async fn join_create_one(&self, data: JoinInsertInput) -> Result<JoinBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "joinCreateOne",
			alias: None,
			fields: Some(JoinBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<JoinBasic>(&query, "joinCreateOne").await
	}
	pub async fn join_create_batch(&self, data: Vec<JoinInsertInput>) -> Result<Vec<JoinBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "joinCreateBatch",
			alias: None,
			fields: Some(JoinBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<JoinBasic>>(&query, "joinCreateBatch").await
	}
	pub async fn join_update(
		&self,
		data: JoinUpdateInput,
		filter: Option<JoinFilterInput>,
	) -> Result<Vec<JoinBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "joinUpdate",
			alias: None,
			fields: Some(JoinBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<JoinBasic>>(&query, "joinUpdate").await
	}
	pub async fn join_delete(&self, filter: Option<JoinFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "joinDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "joinDelete").await
	}
	pub async fn json_transform_create_one(
		&self,
		data: JsonTransformInsertInput,
	) -> Result<JsonTransformBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "jsonTransformCreateOne",
			alias: None,
			fields: Some(JsonTransformBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<JsonTransformBasic>(&query, "jsonTransformCreateOne").await
	}
	pub async fn json_transform_create_batch(
		&self,
		data: Vec<JsonTransformInsertInput>,
	) -> Result<Vec<JsonTransformBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "jsonTransformCreateBatch",
			alias: None,
			fields: Some(JsonTransformBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<JsonTransformBasic>>(&query, "jsonTransformCreateBatch").await
	}
	pub async fn json_transform_update(
		&self,
		data: JsonTransformUpdateInput,
		filter: Option<JsonTransformFilterInput>,
	) -> Result<Vec<JsonTransformBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "jsonTransformUpdate",
			alias: None,
			fields: Some(JsonTransformBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<JsonTransformBasic>>(&query, "jsonTransformUpdate").await
	}
	pub async fn json_transform_delete(
		&self,
		filter: Option<JsonTransformFilterInput>,
	) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "jsonTransformDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "jsonTransformDelete").await
	}
	pub async fn poll_data_create_one(&self, data: PollDataInsertInput) -> Result<PollDataBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "pollDataCreateOne",
			alias: None,
			fields: Some(PollDataBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<PollDataBasic>(&query, "pollDataCreateOne").await
	}
	pub async fn poll_data_create_batch(
		&self,
		data: Vec<PollDataInsertInput>,
	) -> Result<Vec<PollDataBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "pollDataCreateBatch",
			alias: None,
			fields: Some(PollDataBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<PollDataBasic>>(&query, "pollDataCreateBatch").await
	}
	pub async fn poll_data_update(
		&self,
		data: PollDataUpdateInput,
		filter: Option<PollDataFilterInput>,
	) -> Result<Vec<PollDataBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "pollDataUpdate",
			alias: None,
			fields: Some(PollDataBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<PollDataBasic>>(&query, "pollDataUpdate").await
	}
	pub async fn poll_data_delete(&self, filter: Option<PollDataFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "pollDataDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "pollDataDelete").await
	}
	pub async fn set_variable_create_one(
		&self,
		data: SetVariableInsertInput,
	) -> Result<SetVariableBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "setVariableCreateOne",
			alias: None,
			fields: Some(SetVariableBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<SetVariableBasic>(&query, "setVariableCreateOne").await
	}
	pub async fn set_variable_create_batch(
		&self,
		data: Vec<SetVariableInsertInput>,
	) -> Result<Vec<SetVariableBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "setVariableCreateBatch",
			alias: None,
			fields: Some(SetVariableBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<SetVariableBasic>>(&query, "setVariableCreateBatch").await
	}
	pub async fn set_variable_update(
		&self,
		data: SetVariableUpdateInput,
		filter: Option<SetVariableFilterInput>,
	) -> Result<Vec<SetVariableBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "setVariableUpdate",
			alias: None,
			fields: Some(SetVariableBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<SetVariableBasic>>(&query, "setVariableUpdate").await
	}
	pub async fn set_variable_delete(&self, filter: Option<SetVariableFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "setVariableDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "setVariableDelete").await
	}
	pub async fn simple_create_one(&self, data: SimpleInsertInput) -> Result<SimpleBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "simpleCreateOne",
			alias: None,
			fields: Some(SimpleBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<SimpleBasic>(&query, "simpleCreateOne").await
	}
	pub async fn simple_create_batch(
		&self,
		data: Vec<SimpleInsertInput>,
	) -> Result<Vec<SimpleBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "simpleCreateBatch",
			alias: None,
			fields: Some(SimpleBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<SimpleBasic>>(&query, "simpleCreateBatch").await
	}
	pub async fn simple_update(
		&self,
		data: SimpleUpdateInput,
		filter: Option<SimpleFilterInput>,
	) -> Result<Vec<SimpleBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "simpleUpdate",
			alias: None,
			fields: Some(SimpleBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<SimpleBasic>>(&query, "simpleUpdate").await
	}
	pub async fn simple_delete(&self, filter: Option<SimpleFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "simpleDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "simpleDelete").await
	}
	pub async fn sql_create_one(&self, data: SqlInsertInput) -> Result<SqlBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "sqlCreateOne",
			alias: None,
			fields: Some(SqlBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<SqlBasic>(&query, "sqlCreateOne").await
	}
	pub async fn sql_create_batch(&self, data: Vec<SqlInsertInput>) -> Result<Vec<SqlBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "sqlCreateBatch",
			alias: None,
			fields: Some(SqlBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<SqlBasic>>(&query, "sqlCreateBatch").await
	}
	pub async fn sql_update(
		&self,
		data: SqlUpdateInput,
		filter: Option<SqlFilterInput>,
	) -> Result<Vec<SqlBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "sqlUpdate",
			alias: None,
			fields: Some(SqlBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<SqlBasic>>(&query, "sqlUpdate").await
	}
	pub async fn sql_delete(&self, filter: Option<SqlFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "sqlDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "sqlDelete").await
	}
	pub async fn start_workflow_create_one(
		&self,
		data: StartWorkflowInsertInput,
	) -> Result<StartWorkflowBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "startWorkflowCreateOne",
			alias: None,
			fields: Some(StartWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<StartWorkflowBasic>(&query, "startWorkflowCreateOne").await
	}
	pub async fn start_workflow_create_batch(
		&self,
		data: Vec<StartWorkflowInsertInput>,
	) -> Result<Vec<StartWorkflowBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "startWorkflowCreateBatch",
			alias: None,
			fields: Some(StartWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<StartWorkflowBasic>>(&query, "startWorkflowCreateBatch").await
	}
	pub async fn start_workflow_update(
		&self,
		data: StartWorkflowUpdateInput,
		filter: Option<StartWorkflowFilterInput>,
	) -> Result<Vec<StartWorkflowBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "startWorkflowUpdate",
			alias: None,
			fields: Some(StartWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<StartWorkflowBasic>>(&query, "startWorkflowUpdate").await
	}
	pub async fn start_workflow_delete(
		&self,
		filter: Option<StartWorkflowFilterInput>,
	) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "startWorkflowDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "startWorkflowDelete").await
	}
	pub async fn sub_workflow_create_one(
		&self,
		data: SubWorkflowInsertInput,
	) -> Result<SubWorkflowBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "subWorkflowCreateOne",
			alias: None,
			fields: Some(SubWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<SubWorkflowBasic>(&query, "subWorkflowCreateOne").await
	}
	pub async fn sub_workflow_create_batch(
		&self,
		data: Vec<SubWorkflowInsertInput>,
	) -> Result<Vec<SubWorkflowBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "subWorkflowCreateBatch",
			alias: None,
			fields: Some(SubWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<SubWorkflowBasic>>(&query, "subWorkflowCreateBatch").await
	}
	pub async fn sub_workflow_update(
		&self,
		data: SubWorkflowUpdateInput,
		filter: Option<SubWorkflowFilterInput>,
	) -> Result<Vec<SubWorkflowBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "subWorkflowUpdate",
			alias: None,
			fields: Some(SubWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<SubWorkflowBasic>>(&query, "subWorkflowUpdate").await
	}
	pub async fn sub_workflow_delete(&self, filter: Option<SubWorkflowFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "subWorkflowDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "subWorkflowDelete").await
	}
	pub async fn switch_create_one(&self, data: SwitchInsertInput) -> Result<SwitchBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "switchCreateOne",
			alias: None,
			fields: Some(SwitchBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<SwitchBasic>(&query, "switchCreateOne").await
	}
	pub async fn switch_create_batch(
		&self,
		data: Vec<SwitchInsertInput>,
	) -> Result<Vec<SwitchBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "switchCreateBatch",
			alias: None,
			fields: Some(SwitchBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<SwitchBasic>>(&query, "switchCreateBatch").await
	}
	pub async fn switch_update(
		&self,
		data: SwitchUpdateInput,
		filter: Option<SwitchFilterInput>,
	) -> Result<Vec<SwitchBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "switchUpdate",
			alias: None,
			fields: Some(SwitchBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<SwitchBasic>>(&query, "switchUpdate").await
	}
	pub async fn switch_delete(&self, filter: Option<SwitchFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "switchDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "switchDelete").await
	}
	pub async fn task_config_create_one(
		&self,
		data: TaskConfigInsertInput,
	) -> Result<TaskConfigBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "taskConfigCreateOne",
			alias: None,
			fields: Some(TaskConfigBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<TaskConfigBasic>(&query, "taskConfigCreateOne").await
	}
	pub async fn task_config_create_batch(
		&self,
		data: Vec<TaskConfigInsertInput>,
	) -> Result<Vec<TaskConfigBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "taskConfigCreateBatch",
			alias: None,
			fields: Some(TaskConfigBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<TaskConfigBasic>>(&query, "taskConfigCreateBatch").await
	}
	pub async fn task_config_update(
		&self,
		data: TaskConfigUpdateInput,
		filter: Option<TaskConfigFilterInput>,
	) -> Result<Vec<TaskConfigBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "taskConfigUpdate",
			alias: None,
			fields: Some(TaskConfigBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<TaskConfigBasic>>(&query, "taskConfigUpdate").await
	}
	pub async fn task_config_delete(&self, filter: Option<TaskConfigFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "taskConfigDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "taskConfigDelete").await
	}
	pub async fn task_definition_create_one(
		&self,
		data: TaskDefinitionInsertInput,
	) -> Result<TaskDefinitionBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "taskDefinitionCreateOne",
			alias: None,
			fields: Some(TaskDefinitionBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<TaskDefinitionBasic>(&query, "taskDefinitionCreateOne").await
	}
	pub async fn task_definition_create_batch(
		&self,
		data: Vec<TaskDefinitionInsertInput>,
	) -> Result<Vec<TaskDefinitionBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "taskDefinitionCreateBatch",
			alias: None,
			fields: Some(TaskDefinitionBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<TaskDefinitionBasic>>(&query, "taskDefinitionCreateBatch").await
	}
	pub async fn task_definition_update(
		&self,
		data: TaskDefinitionUpdateInput,
		filter: Option<TaskDefinitionFilterInput>,
	) -> Result<Vec<TaskDefinitionBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "taskDefinitionUpdate",
			alias: None,
			fields: Some(TaskDefinitionBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<TaskDefinitionBasic>>(&query, "taskDefinitionUpdate").await
	}
	pub async fn task_definition_delete(
		&self,
		filter: Option<TaskDefinitionFilterInput>,
	) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "taskDefinitionDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "taskDefinitionDelete").await
	}
	pub async fn task_execution_log_create_one(
		&self,
		data: TaskExecutionLogInsertInput,
	) -> Result<TaskExecutionLogBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "taskExecutionLogCreateOne",
			alias: None,
			fields: Some(TaskExecutionLogBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<TaskExecutionLogBasic>(&query, "taskExecutionLogCreateOne").await
	}
	pub async fn task_execution_log_create_batch(
		&self,
		data: Vec<TaskExecutionLogInsertInput>,
	) -> Result<Vec<TaskExecutionLogBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "taskExecutionLogCreateBatch",
			alias: None,
			fields: Some(TaskExecutionLogBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client
			.request::<Vec<TaskExecutionLogBasic>>(&query, "taskExecutionLogCreateBatch")
			.await
	}
	pub async fn task_execution_log_update(
		&self,
		data: TaskExecutionLogUpdateInput,
		filter: Option<TaskExecutionLogFilterInput>,
	) -> Result<Vec<TaskExecutionLogBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "taskExecutionLogUpdate",
			alias: None,
			fields: Some(TaskExecutionLogBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<TaskExecutionLogBasic>>(&query, "taskExecutionLogUpdate").await
	}
	pub async fn task_execution_log_delete(
		&self,
		filter: Option<TaskExecutionLogFilterInput>,
	) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "taskExecutionLogDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "taskExecutionLogDelete").await
	}
	pub async fn task_model_create_one(
		&self,
		data: TaskModelInsertInput,
	) -> Result<TaskModelBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "taskModelCreateOne",
			alias: None,
			fields: Some(TaskModelBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<TaskModelBasic>(&query, "taskModelCreateOne").await
	}
	pub async fn task_model_create_batch(
		&self,
		data: Vec<TaskModelInsertInput>,
	) -> Result<Vec<TaskModelBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "taskModelCreateBatch",
			alias: None,
			fields: Some(TaskModelBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<TaskModelBasic>>(&query, "taskModelCreateBatch").await
	}
	pub async fn task_model_update(
		&self,
		data: TaskModelUpdateInput,
		filter: Option<TaskModelFilterInput>,
	) -> Result<Vec<TaskModelBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "taskModelUpdate",
			alias: None,
			fields: Some(TaskModelBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<TaskModelBasic>>(&query, "taskModelUpdate").await
	}
	pub async fn task_model_delete(&self, filter: Option<TaskModelFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "taskModelDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "taskModelDelete").await
	}
	pub async fn terminate_task_create_one(
		&self,
		data: TerminateTaskInsertInput,
	) -> Result<TerminateTaskBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "terminateTaskCreateOne",
			alias: None,
			fields: Some(TerminateTaskBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<TerminateTaskBasic>(&query, "terminateTaskCreateOne").await
	}
	pub async fn terminate_task_create_batch(
		&self,
		data: Vec<TerminateTaskInsertInput>,
	) -> Result<Vec<TerminateTaskBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "terminateTaskCreateBatch",
			alias: None,
			fields: Some(TerminateTaskBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<TerminateTaskBasic>>(&query, "terminateTaskCreateBatch").await
	}
	pub async fn terminate_task_update(
		&self,
		data: TerminateTaskUpdateInput,
		filter: Option<TerminateTaskFilterInput>,
	) -> Result<Vec<TerminateTaskBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "terminateTaskUpdate",
			alias: None,
			fields: Some(TerminateTaskBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<TerminateTaskBasic>>(&query, "terminateTaskUpdate").await
	}
	pub async fn terminate_task_delete(
		&self,
		filter: Option<TerminateTaskFilterInput>,
	) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "terminateTaskDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "terminateTaskDelete").await
	}
	pub async fn terminate_workflow_create_one(
		&self,
		data: TerminateWorkflowInsertInput,
	) -> Result<TerminateWorkflowBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "terminateWorkflowCreateOne",
			alias: None,
			fields: Some(TerminateWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<TerminateWorkflowBasic>(&query, "terminateWorkflowCreateOne").await
	}
	pub async fn terminate_workflow_create_batch(
		&self,
		data: Vec<TerminateWorkflowInsertInput>,
	) -> Result<Vec<TerminateWorkflowBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "terminateWorkflowCreateBatch",
			alias: None,
			fields: Some(TerminateWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client
			.request::<Vec<TerminateWorkflowBasic>>(&query, "terminateWorkflowCreateBatch")
			.await
	}
	pub async fn terminate_workflow_update(
		&self,
		data: TerminateWorkflowUpdateInput,
		filter: Option<TerminateWorkflowFilterInput>,
	) -> Result<Vec<TerminateWorkflowBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "terminateWorkflowUpdate",
			alias: None,
			fields: Some(TerminateWorkflowBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<TerminateWorkflowBasic>>(&query, "terminateWorkflowUpdate").await
	}
	pub async fn terminate_workflow_delete(
		&self,
		filter: Option<TerminateWorkflowFilterInput>,
	) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "terminateWorkflowDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "terminateWorkflowDelete").await
	}
	pub async fn update_secret_create_one(
		&self,
		data: UpdateSecretInsertInput,
	) -> Result<UpdateSecretBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "updateSecretCreateOne",
			alias: None,
			fields: Some(UpdateSecretBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<UpdateSecretBasic>(&query, "updateSecretCreateOne").await
	}
	pub async fn update_secret_create_batch(
		&self,
		data: Vec<UpdateSecretInsertInput>,
	) -> Result<Vec<UpdateSecretBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "updateSecretCreateBatch",
			alias: None,
			fields: Some(UpdateSecretBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<UpdateSecretBasic>>(&query, "updateSecretCreateBatch").await
	}
	pub async fn update_secret_update(
		&self,
		data: UpdateSecretUpdateInput,
		filter: Option<UpdateSecretFilterInput>,
	) -> Result<Vec<UpdateSecretBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "updateSecretUpdate",
			alias: None,
			fields: Some(UpdateSecretBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<UpdateSecretBasic>>(&query, "updateSecretUpdate").await
	}
	pub async fn update_secret_delete(
		&self,
		filter: Option<UpdateSecretFilterInput>,
	) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "updateSecretDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "updateSecretDelete").await
	}
	pub async fn update_task_create_one(
		&self,
		data: UpdateTaskInsertInput,
	) -> Result<UpdateTaskBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "updateTaskCreateOne",
			alias: None,
			fields: Some(UpdateTaskBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<UpdateTaskBasic>(&query, "updateTaskCreateOne").await
	}
	pub async fn update_task_create_batch(
		&self,
		data: Vec<UpdateTaskInsertInput>,
	) -> Result<Vec<UpdateTaskBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "updateTaskCreateBatch",
			alias: None,
			fields: Some(UpdateTaskBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<UpdateTaskBasic>>(&query, "updateTaskCreateBatch").await
	}
	pub async fn update_task_update(
		&self,
		data: UpdateTaskUpdateInput,
		filter: Option<UpdateTaskFilterInput>,
	) -> Result<Vec<UpdateTaskBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "updateTaskUpdate",
			alias: None,
			fields: Some(UpdateTaskBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<UpdateTaskBasic>>(&query, "updateTaskUpdate").await
	}
	pub async fn update_task_delete(&self, filter: Option<UpdateTaskFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "updateTaskDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "updateTaskDelete").await
	}
	pub async fn wait_create_one(&self, data: WaitInsertInput) -> Result<WaitBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "waitCreateOne",
			alias: None,
			fields: Some(WaitBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<WaitBasic>(&query, "waitCreateOne").await
	}
	pub async fn wait_create_batch(&self, data: Vec<WaitInsertInput>) -> Result<Vec<WaitBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "waitCreateBatch",
			alias: None,
			fields: Some(WaitBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<WaitBasic>>(&query, "waitCreateBatch").await
	}
	pub async fn wait_update(
		&self,
		data: WaitUpdateInput,
		filter: Option<WaitFilterInput>,
	) -> Result<Vec<WaitBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "waitUpdate",
			alias: None,
			fields: Some(WaitBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<WaitBasic>>(&query, "waitUpdate").await
	}
	pub async fn wait_delete(&self, filter: Option<WaitFilterInput>) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "waitDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "waitDelete").await
	}
	pub async fn wait_for_webhook_create_one(
		&self,
		data: WaitForWebhookInsertInput,
	) -> Result<WaitForWebhookBasic> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "waitForWebhookCreateOne",
			alias: None,
			fields: Some(WaitForWebhookBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<WaitForWebhookBasic>(&query, "waitForWebhookCreateOne").await
	}
	pub async fn wait_for_webhook_create_batch(
		&self,
		data: Vec<WaitForWebhookInsertInput>,
	) -> Result<Vec<WaitForWebhookBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		let data = SelectionSet {
			operation: "waitForWebhookCreateBatch",
			alias: None,
			fields: Some(WaitForWebhookBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<WaitForWebhookBasic>>(&query, "waitForWebhookCreateBatch").await
	}
	pub async fn wait_for_webhook_update(
		&self,
		data: WaitForWebhookUpdateInput,
		filter: Option<WaitForWebhookFilterInput>,
	) -> Result<Vec<WaitForWebhookBasic>> {
		let mut fileds = serde_json::Map::new();
		fileds.insert("data".to_owned(), serde_json::to_value(&data)?);
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "waitForWebhookUpdate",
			alias: None,
			fields: Some(WaitForWebhookBasic::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<Vec<WaitForWebhookBasic>>(&query, "waitForWebhookUpdate").await
	}
	pub async fn wait_for_webhook_delete(
		&self,
		filter: Option<WaitForWebhookFilterInput>,
	) -> Result<i64> {
		let mut fileds = serde_json::Map::new();
		if let Some(filter) = filter {
			fileds.insert("filter".to_owned(), serde_json::to_value(&filter)?);
		}
		let data = SelectionSet {
			operation: "waitForWebhookDelete",
			alias: None,
			fields: None,
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Mutation, &data);
		self.client.request::<i64>(&query, "waitForWebhookDelete").await
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PageInfo {
	#[serde(rename = "hasPreviousPage")]
	pub has_previous_page: bool,
	#[serde(rename = "hasNextPage")]
	pub has_next_page: bool,
	#[serde(rename = "startCursor")]
	pub start_cursor: Option<String>,
	#[serde(rename = "endCursor")]
	pub end_cursor: Option<String>,
}
impl PageInfo {
	pub async fn has_previous_page(&self) -> bool {
		self.has_previous_page
	}
	pub async fn has_next_page(&self) -> bool {
		self.has_next_page
	}
	pub async fn start_cursor(&self) -> Option<String> {
		self.start_cursor.clone()
	}
	pub async fn end_cursor(&self) -> Option<String> {
		self.end_cursor.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "hasPreviousPage",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "hasNextPage",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "startCursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "endCursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PaginationInfo {
	#[serde(rename = "pages")]
	pub pages: i64,
	#[serde(rename = "current")]
	pub current: i64,
	#[serde(rename = "offset")]
	pub offset: i64,
	#[serde(rename = "total")]
	pub total: i64,
}
impl PaginationInfo {
	pub async fn pages(&self) -> i64 {
		self.pages
	}
	pub async fn current(&self) -> i64 {
		self.current
	}
	pub async fn offset(&self) -> i64 {
		self.offset
	}
	pub async fn total(&self) -> i64 {
		self.total
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pages",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "current",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "offset",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "total",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PollData {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "createdOn")]
	pub created_on: String,
	#[serde(rename = "modifiedOn")]
	pub modified_on: String,
	#[serde(rename = "queueName")]
	pub queue_name: String,
	#[serde(rename = "domain")]
	pub domain: String,
	#[serde(rename = "jsonData")]
	pub json_data: String,
}
impl PollData {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn created_on(&self) -> String {
		self.created_on.clone()
	}
	pub async fn modified_on(&self) -> String {
		self.modified_on.clone()
	}
	pub async fn queue_name(&self) -> String {
		self.queue_name.clone()
	}
	pub async fn domain(&self) -> String {
		self.domain.clone()
	}
	pub async fn json_data(&self) -> String {
		self.json_data.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "createdOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "modifiedOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "queueName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "domain",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "jsonData",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PollDataBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "createdOn")]
	pub created_on: String,
	#[serde(rename = "modifiedOn")]
	pub modified_on: String,
	#[serde(rename = "queueName")]
	pub queue_name: String,
	#[serde(rename = "domain")]
	pub domain: String,
	#[serde(rename = "jsonData")]
	pub json_data: String,
}
impl PollDataBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn created_on(&self) -> String {
		self.created_on.clone()
	}
	pub async fn modified_on(&self) -> String {
		self.modified_on.clone()
	}
	pub async fn queue_name(&self) -> String {
		self.queue_name.clone()
	}
	pub async fn domain(&self) -> String {
		self.domain.clone()
	}
	pub async fn json_data(&self) -> String {
		self.json_data.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "createdOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "modifiedOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "queueName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "domain",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "jsonData",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PollDataConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<PollData>,
	#[serde(rename = "edges")]
	pub edges: Vec<PollDataEdge>,
}
impl PollDataConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<PollData> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<PollDataEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(PollData::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(PollDataEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PollDataEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: PollData,
}
impl PollDataEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> PollData {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(PollData::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Debug, Clone)]
pub struct Query<'a> {
	pub client: GraphQLClient<'a>,
}
impl<'a> Query<'a> {
	pub async fn buissness_rule(
		&self,
		filters: Option<BuissnessRuleFilterInput>,
		order_by: Option<BuissnessRuleOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<BuissnessRuleConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "buissnessRule",
			alias: None,
			fields: Some(BuissnessRuleConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<BuissnessRuleConnection>(&query, "buissnessRule").await
	}
	pub async fn do_while(
		&self,
		filters: Option<DoWhileFilterInput>,
		order_by: Option<DoWhileOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<DoWhileConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "doWhile",
			alias: None,
			fields: Some(DoWhileConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<DoWhileConnection>(&query, "doWhile").await
	}
	pub async fn dynamic(
		&self,
		filters: Option<DynamicFilterInput>,
		order_by: Option<DynamicOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<DynamicConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "dynamic",
			alias: None,
			fields: Some(DynamicConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<DynamicConnection>(&query, "dynamic").await
	}
	pub async fn dynamic_fork(
		&self,
		filters: Option<DynamicForkFilterInput>,
		order_by: Option<DynamicForkOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<DynamicForkConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "dynamicFork",
			alias: None,
			fields: Some(DynamicForkConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<DynamicForkConnection>(&query, "dynamicFork").await
	}
	pub async fn event(
		&self,
		filters: Option<EventFilterInput>,
		order_by: Option<EventOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<EventConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "event",
			alias: None,
			fields: Some(EventConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<EventConnection>(&query, "event").await
	}
	pub async fn fork(
		&self,
		filters: Option<ForkFilterInput>,
		order_by: Option<ForkOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<ForkConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "fork",
			alias: None,
			fields: Some(ForkConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<ForkConnection>(&query, "fork").await
	}
	pub async fn get_signed_jwt(
		&self,
		filters: Option<GetSignedJwtFilterInput>,
		order_by: Option<GetSignedJwtOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<GetSignedJwtConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "getSignedJwt",
			alias: None,
			fields: Some(GetSignedJwtConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<GetSignedJwtConnection>(&query, "getSignedJwt").await
	}
	pub async fn get_workflow(
		&self,
		filters: Option<GetWorkflowFilterInput>,
		order_by: Option<GetWorkflowOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<GetWorkflowConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "getWorkflow",
			alias: None,
			fields: Some(GetWorkflowConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<GetWorkflowConnection>(&query, "getWorkflow").await
	}
	pub async fn http(
		&self,
		filters: Option<HttpFilterInput>,
		order_by: Option<HttpOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<HttpConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "http",
			alias: None,
			fields: Some(HttpConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<HttpConnection>(&query, "http").await
	}
	pub async fn human(
		&self,
		filters: Option<HumanFilterInput>,
		order_by: Option<HumanOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<HumanConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "human",
			alias: None,
			fields: Some(HumanConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<HumanConnection>(&query, "human").await
	}
	pub async fn inline(
		&self,
		filters: Option<InlineFilterInput>,
		order_by: Option<InlineOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<InlineConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "inline",
			alias: None,
			fields: Some(InlineConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<InlineConnection>(&query, "inline").await
	}
	pub async fn join(
		&self,
		filters: Option<JoinFilterInput>,
		order_by: Option<JoinOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<JoinConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "join",
			alias: None,
			fields: Some(JoinConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<JoinConnection>(&query, "join").await
	}
	pub async fn json_transform(
		&self,
		filters: Option<JsonTransformFilterInput>,
		order_by: Option<JsonTransformOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<JsonTransformConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "jsonTransform",
			alias: None,
			fields: Some(JsonTransformConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<JsonTransformConnection>(&query, "jsonTransform").await
	}
	pub async fn poll_data(
		&self,
		filters: Option<PollDataFilterInput>,
		order_by: Option<PollDataOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<PollDataConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "pollData",
			alias: None,
			fields: Some(PollDataConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<PollDataConnection>(&query, "pollData").await
	}
	pub async fn set_variable(
		&self,
		filters: Option<SetVariableFilterInput>,
		order_by: Option<SetVariableOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<SetVariableConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "setVariable",
			alias: None,
			fields: Some(SetVariableConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<SetVariableConnection>(&query, "setVariable").await
	}
	pub async fn simple(
		&self,
		filters: Option<SimpleFilterInput>,
		order_by: Option<SimpleOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<SimpleConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "simple",
			alias: None,
			fields: Some(SimpleConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<SimpleConnection>(&query, "simple").await
	}
	pub async fn sql(
		&self,
		filters: Option<SqlFilterInput>,
		order_by: Option<SqlOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<SqlConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "sql",
			alias: None,
			fields: Some(SqlConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<SqlConnection>(&query, "sql").await
	}
	pub async fn start_workflow(
		&self,
		filters: Option<StartWorkflowFilterInput>,
		order_by: Option<StartWorkflowOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<StartWorkflowConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "startWorkflow",
			alias: None,
			fields: Some(StartWorkflowConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<StartWorkflowConnection>(&query, "startWorkflow").await
	}
	pub async fn sub_workflow(
		&self,
		filters: Option<SubWorkflowFilterInput>,
		order_by: Option<SubWorkflowOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<SubWorkflowConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "subWorkflow",
			alias: None,
			fields: Some(SubWorkflowConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<SubWorkflowConnection>(&query, "subWorkflow").await
	}
	pub async fn switch(
		&self,
		filters: Option<SwitchFilterInput>,
		order_by: Option<SwitchOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<SwitchConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "switch",
			alias: None,
			fields: Some(SwitchConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<SwitchConnection>(&query, "switch").await
	}
	pub async fn task_config(
		&self,
		filters: Option<TaskConfigFilterInput>,
		order_by: Option<TaskConfigOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<TaskConfigConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "taskConfig",
			alias: None,
			fields: Some(TaskConfigConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<TaskConfigConnection>(&query, "taskConfig").await
	}
	pub async fn task_definition(
		&self,
		filters: Option<TaskDefinitionFilterInput>,
		order_by: Option<TaskDefinitionOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<TaskDefinitionConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "taskDefinition",
			alias: None,
			fields: Some(TaskDefinitionConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<TaskDefinitionConnection>(&query, "taskDefinition").await
	}
	pub async fn task_execution_log(
		&self,
		filters: Option<TaskExecutionLogFilterInput>,
		order_by: Option<TaskExecutionLogOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<TaskExecutionLogConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "taskExecutionLog",
			alias: None,
			fields: Some(TaskExecutionLogConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<TaskExecutionLogConnection>(&query, "taskExecutionLog").await
	}
	pub async fn task_model(
		&self,
		filters: Option<TaskModelFilterInput>,
		order_by: Option<TaskModelOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<TaskModelConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "taskModel",
			alias: None,
			fields: Some(TaskModelConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<TaskModelConnection>(&query, "taskModel").await
	}
	pub async fn terminate_task(
		&self,
		filters: Option<TerminateTaskFilterInput>,
		order_by: Option<TerminateTaskOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<TerminateTaskConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "terminateTask",
			alias: None,
			fields: Some(TerminateTaskConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<TerminateTaskConnection>(&query, "terminateTask").await
	}
	pub async fn terminate_workflow(
		&self,
		filters: Option<TerminateWorkflowFilterInput>,
		order_by: Option<TerminateWorkflowOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<TerminateWorkflowConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "terminateWorkflow",
			alias: None,
			fields: Some(TerminateWorkflowConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<TerminateWorkflowConnection>(&query, "terminateWorkflow").await
	}
	pub async fn update_secret(
		&self,
		filters: Option<UpdateSecretFilterInput>,
		order_by: Option<UpdateSecretOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<UpdateSecretConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "updateSecret",
			alias: None,
			fields: Some(UpdateSecretConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<UpdateSecretConnection>(&query, "updateSecret").await
	}
	pub async fn update_task(
		&self,
		filters: Option<UpdateTaskFilterInput>,
		order_by: Option<UpdateTaskOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<UpdateTaskConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "updateTask",
			alias: None,
			fields: Some(UpdateTaskConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<UpdateTaskConnection>(&query, "updateTask").await
	}
	pub async fn wait(
		&self,
		filters: Option<WaitFilterInput>,
		order_by: Option<WaitOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<WaitConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "wait",
			alias: None,
			fields: Some(WaitConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<WaitConnection>(&query, "wait").await
	}
	pub async fn wait_for_webhook(
		&self,
		filters: Option<WaitForWebhookFilterInput>,
		order_by: Option<WaitForWebhookOrderInput>,
		pagination: Option<PaginationInput>,
	) -> Result<WaitForWebhookConnection> {
		let mut fileds = serde_json::Map::new();
		if let Some(filters) = filters {
			fileds.insert("filters".to_owned(), serde_json::to_value(&filters)?);
		}
		if let Some(order_by) = order_by {
			fileds.insert("orderBy".to_owned(), serde_json::to_value(&order_by)?);
		}
		if let Some(pagination) = pagination {
			fileds.insert("pagination".to_owned(), serde_json::to_value(&pagination)?);
		}
		let data = SelectionSet {
			operation: "waitForWebhook",
			alias: None,
			fields: Some(WaitForWebhookConnection::to_query()),
			arguments: Some(serde_json::Value::Object(fileds)),
			is_union: false,
		};
		let query = QueryBuilder::new(OperationType::Query, &data);
		self.client.request::<WaitForWebhookConnection>(&query, "waitForWebhook").await
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SetVariable {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl SetVariable {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SetVariableBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SetVariableBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SetVariableConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<SetVariable>,
	#[serde(rename = "edges")]
	pub edges: Vec<SetVariableEdge>,
}
impl SetVariableConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<SetVariable> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<SetVariableEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(SetVariable::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(SetVariableEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SetVariableEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: SetVariable,
}
impl SetVariableEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> SetVariable {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(SetVariable::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Simple {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl Simple {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SimpleBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SimpleBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SimpleConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<Simple>,
	#[serde(rename = "edges")]
	pub edges: Vec<SimpleEdge>,
}
impl SimpleConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<Simple> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<SimpleEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(Simple::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(SimpleEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SimpleEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: Simple,
}
impl SimpleEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> Simple {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(Simple::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Sql {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "integrationName")]
	pub integration_name: String,
	#[serde(rename = "statement")]
	pub statement: String,
	#[serde(rename = "operationType")]
	pub operation_type: OperationTypeEnum,
	#[serde(rename = "expectedOutputCount")]
	pub expected_output_count: Option<i64>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl Sql {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn integration_name(&self) -> String {
		self.integration_name.clone()
	}
	pub async fn statement(&self) -> String {
		self.statement.clone()
	}
	pub async fn operation_type(&self) -> OperationTypeEnum {
		self.operation_type.clone()
	}
	pub async fn expected_output_count(&self) -> Option<i64> {
		self.expected_output_count
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "integrationName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "statement",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "operationType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "expectedOutputCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SqlBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "integrationName")]
	pub integration_name: String,
	#[serde(rename = "statement")]
	pub statement: String,
	#[serde(rename = "operationType")]
	pub operation_type: OperationTypeEnum,
	#[serde(rename = "expectedOutputCount")]
	pub expected_output_count: Option<i64>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SqlBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn integration_name(&self) -> String {
		self.integration_name.clone()
	}
	pub async fn statement(&self) -> String {
		self.statement.clone()
	}
	pub async fn operation_type(&self) -> OperationTypeEnum {
		self.operation_type.clone()
	}
	pub async fn expected_output_count(&self) -> Option<i64> {
		self.expected_output_count
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "integrationName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "statement",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "operationType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "expectedOutputCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SqlConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<Sql>,
	#[serde(rename = "edges")]
	pub edges: Vec<SqlEdge>,
}
impl SqlConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<Sql> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<SqlEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(Sql::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(SqlEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SqlEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: Sql,
}
impl SqlEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> Sql {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(Sql::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct StartWorkflow {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "version")]
	pub version: Option<i64>,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<String>,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<String>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl StartWorkflow {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn name(&self) -> String {
		self.name.clone()
	}
	pub async fn version(&self) -> Option<i64> {
		self.version
	}
	pub async fn correlation_id(&self) -> Option<String> {
		self.correlation_id.clone()
	}
	pub async fn idempotency_key(&self) -> Option<String> {
		self.idempotency_key.clone()
	}
	pub async fn idempotency_strategy(&self) -> Option<IdempotencyStrategyEnum> {
		self.idempotency_strategy.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "version",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct StartWorkflowBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "version")]
	pub version: Option<i64>,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<String>,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<String>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl StartWorkflowBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn name(&self) -> String {
		self.name.clone()
	}
	pub async fn version(&self) -> Option<i64> {
		self.version
	}
	pub async fn correlation_id(&self) -> Option<String> {
		self.correlation_id.clone()
	}
	pub async fn idempotency_key(&self) -> Option<String> {
		self.idempotency_key.clone()
	}
	pub async fn idempotency_strategy(&self) -> Option<IdempotencyStrategyEnum> {
		self.idempotency_strategy.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "version",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct StartWorkflowConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<StartWorkflow>,
	#[serde(rename = "edges")]
	pub edges: Vec<StartWorkflowEdge>,
}
impl StartWorkflowConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<StartWorkflow> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<StartWorkflowEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(StartWorkflow::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(StartWorkflowEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct StartWorkflowEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: StartWorkflow,
}
impl StartWorkflowEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> StartWorkflow {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(StartWorkflow::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SubWorkflow {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "version")]
	pub version: i64,
	#[serde(rename = "priority")]
	pub priority: i64,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<String>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl SubWorkflow {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn name(&self) -> String {
		self.name.clone()
	}
	pub async fn version(&self) -> i64 {
		self.version
	}
	pub async fn priority(&self) -> i64 {
		self.priority
	}
	pub async fn idempotency_key(&self) -> Option<String> {
		self.idempotency_key.clone()
	}
	pub async fn idempotency_strategy(&self) -> Option<IdempotencyStrategyEnum> {
		self.idempotency_strategy.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "version",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "priority",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SubWorkflowBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "version")]
	pub version: i64,
	#[serde(rename = "priority")]
	pub priority: i64,
	#[serde(rename = "idempotencyKey")]
	pub idempotency_key: Option<String>,
	#[serde(rename = "idempotencyStrategy")]
	pub idempotency_strategy: Option<IdempotencyStrategyEnum>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SubWorkflowBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn name(&self) -> String {
		self.name.clone()
	}
	pub async fn version(&self) -> i64 {
		self.version
	}
	pub async fn priority(&self) -> i64 {
		self.priority
	}
	pub async fn idempotency_key(&self) -> Option<String> {
		self.idempotency_key.clone()
	}
	pub async fn idempotency_strategy(&self) -> Option<IdempotencyStrategyEnum> {
		self.idempotency_strategy.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "version",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "priority",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "idempotencyKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "idempotencyStrategy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SubWorkflowConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<SubWorkflow>,
	#[serde(rename = "edges")]
	pub edges: Vec<SubWorkflowEdge>,
}
impl SubWorkflowConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<SubWorkflow> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<SubWorkflowEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(SubWorkflow::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(SubWorkflowEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SubWorkflowEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: SubWorkflow,
}
impl SubWorkflowEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> SubWorkflow {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(SubWorkflow::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Switch {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: EvaluatorTypeEnum,
	#[serde(rename = "expression")]
	pub expression: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl Switch {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn evaluator_type(&self) -> EvaluatorTypeEnum {
		self.evaluator_type.clone()
	}
	pub async fn expression(&self) -> String {
		self.expression.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SwitchBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: EvaluatorTypeEnum,
	#[serde(rename = "expression")]
	pub expression: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl SwitchBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn evaluator_type(&self) -> EvaluatorTypeEnum {
		self.evaluator_type.clone()
	}
	pub async fn expression(&self) -> String {
		self.expression.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SwitchConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<Switch>,
	#[serde(rename = "edges")]
	pub edges: Vec<SwitchEdge>,
}
impl SwitchConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<Switch> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<SwitchEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(Switch::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(SwitchEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SwitchEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: Switch,
}
impl SwitchEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> Switch {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(Switch::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskConfig {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "taskReferenceName")]
	pub task_reference_name: String,
	#[serde(rename = "taskType")]
	pub task_type: TaskTypeEnum,
	#[serde(rename = "description")]
	pub description: Option<String>,
	#[serde(rename = "optional")]
	pub optional: bool,
	#[serde(rename = "asyncComplete")]
	pub async_complete: bool,
	#[serde(rename = "startDelay")]
	pub start_delay: i64,
	#[serde(rename = "permissive")]
	pub permissive: bool,
	#[serde(rename = "loopCondition")]
	pub loop_condition: Option<String>,
	#[serde(rename = "dynamicTaskNameParam")]
	pub dynamic_task_name_param: Option<String>,
	#[serde(rename = "dynamicForkTasksParam")]
	pub dynamic_fork_tasks_param: Option<String>,
	#[serde(rename = "dynamicForkTasksInputParamName")]
	pub dynamic_fork_tasks_input_param_name: Option<String>,
	#[serde(rename = "joinStatus")]
	pub join_status: Option<String>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<EvaluatorTypeEnum>,
	#[serde(rename = "expression")]
	pub expression: Option<String>,
	#[serde(rename = "sink")]
	pub sink: Option<String>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: Option<bool>,
	#[serde(rename = "scriptExpression")]
	pub script_expression: Option<String>,
	#[serde(rename = "taskDefinition")]
	pub task_definition: Option<String>,
	#[serde(rename = "rateLimited")]
	pub rate_limited: Option<bool>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<i64>,
	#[serde(rename = "taskModel")]
	pub task_model: TaskModelConnection,
}
impl TaskConfig {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn name(&self) -> String {
		self.name.clone()
	}
	pub async fn task_reference_name(&self) -> String {
		self.task_reference_name.clone()
	}
	pub async fn task_type(&self) -> TaskTypeEnum {
		self.task_type.clone()
	}
	pub async fn description(&self) -> Option<String> {
		self.description.clone()
	}
	pub async fn optional(&self) -> bool {
		self.optional
	}
	pub async fn async_complete(&self) -> bool {
		self.async_complete
	}
	pub async fn start_delay(&self) -> i64 {
		self.start_delay
	}
	pub async fn permissive(&self) -> bool {
		self.permissive
	}
	pub async fn loop_condition(&self) -> Option<String> {
		self.loop_condition.clone()
	}
	pub async fn dynamic_task_name_param(&self) -> Option<String> {
		self.dynamic_task_name_param.clone()
	}
	pub async fn dynamic_fork_tasks_param(&self) -> Option<String> {
		self.dynamic_fork_tasks_param.clone()
	}
	pub async fn dynamic_fork_tasks_input_param_name(&self) -> Option<String> {
		self.dynamic_fork_tasks_input_param_name.clone()
	}
	pub async fn join_status(&self) -> Option<String> {
		self.join_status.clone()
	}
	pub async fn evaluator_type(&self) -> Option<EvaluatorTypeEnum> {
		self.evaluator_type.clone()
	}
	pub async fn expression(&self) -> Option<String> {
		self.expression.clone()
	}
	pub async fn sink(&self) -> Option<String> {
		self.sink.clone()
	}
	pub async fn trigger_failure_workflow(&self) -> Option<bool> {
		self.trigger_failure_workflow
	}
	pub async fn script_expression(&self) -> Option<String> {
		self.script_expression.clone()
	}
	pub async fn task_definition(&self) -> Option<String> {
		self.task_definition.clone()
	}
	pub async fn rate_limited(&self) -> Option<bool> {
		self.rate_limited
	}
	pub async fn retry_count(&self) -> Option<i64> {
		self.retry_count
	}
	pub async fn task_model(&self) -> TaskModelConnection {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskReferenceName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "description",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "optional",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "startDelay",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "permissive",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "loopCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "dynamicTaskNameParam",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "dynamicForkTasksParam",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "dynamicForkTasksInputParamName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "joinStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "sink",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "triggerFailureWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "scriptExpression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskDefinition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "rateLimited",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModelConnection::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskConfigBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "taskReferenceName")]
	pub task_reference_name: String,
	#[serde(rename = "taskType")]
	pub task_type: TaskTypeEnum,
	#[serde(rename = "description")]
	pub description: Option<String>,
	#[serde(rename = "optional")]
	pub optional: bool,
	#[serde(rename = "asyncComplete")]
	pub async_complete: bool,
	#[serde(rename = "startDelay")]
	pub start_delay: i64,
	#[serde(rename = "permissive")]
	pub permissive: bool,
	#[serde(rename = "loopCondition")]
	pub loop_condition: Option<String>,
	#[serde(rename = "dynamicTaskNameParam")]
	pub dynamic_task_name_param: Option<String>,
	#[serde(rename = "dynamicForkTasksParam")]
	pub dynamic_fork_tasks_param: Option<String>,
	#[serde(rename = "dynamicForkTasksInputParamName")]
	pub dynamic_fork_tasks_input_param_name: Option<String>,
	#[serde(rename = "joinStatus")]
	pub join_status: Option<String>,
	#[serde(rename = "evaluatorType")]
	pub evaluator_type: Option<EvaluatorTypeEnum>,
	#[serde(rename = "expression")]
	pub expression: Option<String>,
	#[serde(rename = "sink")]
	pub sink: Option<String>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: Option<bool>,
	#[serde(rename = "scriptExpression")]
	pub script_expression: Option<String>,
	#[serde(rename = "taskDefinition")]
	pub task_definition: Option<String>,
	#[serde(rename = "rateLimited")]
	pub rate_limited: Option<bool>,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<i64>,
}
impl TaskConfigBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn name(&self) -> String {
		self.name.clone()
	}
	pub async fn task_reference_name(&self) -> String {
		self.task_reference_name.clone()
	}
	pub async fn task_type(&self) -> TaskTypeEnum {
		self.task_type.clone()
	}
	pub async fn description(&self) -> Option<String> {
		self.description.clone()
	}
	pub async fn optional(&self) -> bool {
		self.optional
	}
	pub async fn async_complete(&self) -> bool {
		self.async_complete
	}
	pub async fn start_delay(&self) -> i64 {
		self.start_delay
	}
	pub async fn permissive(&self) -> bool {
		self.permissive
	}
	pub async fn loop_condition(&self) -> Option<String> {
		self.loop_condition.clone()
	}
	pub async fn dynamic_task_name_param(&self) -> Option<String> {
		self.dynamic_task_name_param.clone()
	}
	pub async fn dynamic_fork_tasks_param(&self) -> Option<String> {
		self.dynamic_fork_tasks_param.clone()
	}
	pub async fn dynamic_fork_tasks_input_param_name(&self) -> Option<String> {
		self.dynamic_fork_tasks_input_param_name.clone()
	}
	pub async fn join_status(&self) -> Option<String> {
		self.join_status.clone()
	}
	pub async fn evaluator_type(&self) -> Option<EvaluatorTypeEnum> {
		self.evaluator_type.clone()
	}
	pub async fn expression(&self) -> Option<String> {
		self.expression.clone()
	}
	pub async fn sink(&self) -> Option<String> {
		self.sink.clone()
	}
	pub async fn trigger_failure_workflow(&self) -> Option<bool> {
		self.trigger_failure_workflow
	}
	pub async fn script_expression(&self) -> Option<String> {
		self.script_expression.clone()
	}
	pub async fn task_definition(&self) -> Option<String> {
		self.task_definition.clone()
	}
	pub async fn rate_limited(&self) -> Option<bool> {
		self.rate_limited
	}
	pub async fn retry_count(&self) -> Option<i64> {
		self.retry_count
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskReferenceName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "description",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "optional",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "asyncComplete",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "startDelay",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "permissive",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "loopCondition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "dynamicTaskNameParam",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "dynamicForkTasksParam",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "dynamicForkTasksInputParamName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "joinStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "evaluatorType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "expression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "sink",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "triggerFailureWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "scriptExpression",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskDefinition",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "rateLimited",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskConfigConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<TaskConfig>,
	#[serde(rename = "edges")]
	pub edges: Vec<TaskConfigEdge>,
}
impl TaskConfigConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<TaskConfig> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<TaskConfigEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(TaskConfig::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(TaskConfigEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskConfigEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: TaskConfig,
}
impl TaskConfigEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> TaskConfig {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(TaskConfig::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskDefinition {
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "description")]
	pub description: Option<String>,
	#[serde(rename = "retryCount")]
	pub retry_count: i64,
	#[serde(rename = "timeoutSeconds")]
	pub timeout_seconds: Option<i64>,
	#[serde(rename = "timeoutPolicy")]
	pub timeout_policy: TimeoutPolicyEnum,
	#[serde(rename = "retryLogic")]
	pub retry_logic: RetryLogicEnum,
	#[serde(rename = "retryDelaySeconds")]
	pub retry_delay_seconds: i64,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: i64,
	#[serde(rename = "concurrentExecLimit")]
	pub concurrent_exec_limit: Option<i64>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<i64>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<i64>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<String>,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<String>,
	#[serde(rename = "ownerEmail")]
	pub owner_email: Option<String>,
	#[serde(rename = "pollTimeoutSeconds")]
	pub poll_timeout_seconds: Option<i64>,
	#[serde(rename = "backoffScaleFactor")]
	pub backoff_scale_factor: i64,
	#[serde(rename = "baseType")]
	pub base_type: Option<String>,
	#[serde(rename = "enforceSchema")]
	pub enforce_schema: bool,
	#[serde(rename = "createdOn")]
	pub created_on: String,
	#[serde(rename = "createdBy")]
	pub created_by: Option<String>,
	#[serde(rename = "modifiedOn")]
	pub modified_on: String,
	#[serde(rename = "modifiedBy")]
	pub modified_by: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: TaskModelConnection,
}
impl TaskDefinition {
	pub async fn name(&self) -> String {
		self.name.clone()
	}
	pub async fn description(&self) -> Option<String> {
		self.description.clone()
	}
	pub async fn retry_count(&self) -> i64 {
		self.retry_count
	}
	pub async fn timeout_seconds(&self) -> Option<i64> {
		self.timeout_seconds
	}
	pub async fn timeout_policy(&self) -> TimeoutPolicyEnum {
		self.timeout_policy.clone()
	}
	pub async fn retry_logic(&self) -> RetryLogicEnum {
		self.retry_logic.clone()
	}
	pub async fn retry_delay_seconds(&self) -> i64 {
		self.retry_delay_seconds
	}
	pub async fn response_timeout_seconds(&self) -> i64 {
		self.response_timeout_seconds
	}
	pub async fn concurrent_exec_limit(&self) -> Option<i64> {
		self.concurrent_exec_limit
	}
	pub async fn rate_limit_per_frequency(&self) -> Option<i64> {
		self.rate_limit_per_frequency
	}
	pub async fn rate_limit_frequency_in_seconds(&self) -> Option<i64> {
		self.rate_limit_frequency_in_seconds
	}
	pub async fn isolation_group_id(&self) -> Option<String> {
		self.isolation_group_id.clone()
	}
	pub async fn execution_name_space(&self) -> Option<String> {
		self.execution_name_space.clone()
	}
	pub async fn owner_email(&self) -> Option<String> {
		self.owner_email.clone()
	}
	pub async fn poll_timeout_seconds(&self) -> Option<i64> {
		self.poll_timeout_seconds
	}
	pub async fn backoff_scale_factor(&self) -> i64 {
		self.backoff_scale_factor
	}
	pub async fn base_type(&self) -> Option<String> {
		self.base_type.clone()
	}
	pub async fn enforce_schema(&self) -> bool {
		self.enforce_schema
	}
	pub async fn created_on(&self) -> String {
		self.created_on.clone()
	}
	pub async fn created_by(&self) -> Option<String> {
		self.created_by.clone()
	}
	pub async fn modified_on(&self) -> String {
		self.modified_on.clone()
	}
	pub async fn modified_by(&self) -> Option<String> {
		self.modified_by.clone()
	}
	pub async fn task_model(&self) -> TaskModelConnection {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "description",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "timeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "timeoutPolicy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retryLogic",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retryDelaySeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "responseTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "concurrentExecLimit",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "ownerEmail",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "pollTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "backoffScaleFactor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "baseType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "enforceSchema",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "createdOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "createdBy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "modifiedOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "modifiedBy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModelConnection::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskDefinitionBasic {
	#[serde(rename = "name")]
	pub name: String,
	#[serde(rename = "description")]
	pub description: Option<String>,
	#[serde(rename = "retryCount")]
	pub retry_count: i64,
	#[serde(rename = "timeoutSeconds")]
	pub timeout_seconds: Option<i64>,
	#[serde(rename = "timeoutPolicy")]
	pub timeout_policy: TimeoutPolicyEnum,
	#[serde(rename = "retryLogic")]
	pub retry_logic: RetryLogicEnum,
	#[serde(rename = "retryDelaySeconds")]
	pub retry_delay_seconds: i64,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: i64,
	#[serde(rename = "concurrentExecLimit")]
	pub concurrent_exec_limit: Option<i64>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<i64>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<i64>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<String>,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<String>,
	#[serde(rename = "ownerEmail")]
	pub owner_email: Option<String>,
	#[serde(rename = "pollTimeoutSeconds")]
	pub poll_timeout_seconds: Option<i64>,
	#[serde(rename = "backoffScaleFactor")]
	pub backoff_scale_factor: i64,
	#[serde(rename = "baseType")]
	pub base_type: Option<String>,
	#[serde(rename = "enforceSchema")]
	pub enforce_schema: bool,
	#[serde(rename = "createdOn")]
	pub created_on: String,
	#[serde(rename = "createdBy")]
	pub created_by: Option<String>,
	#[serde(rename = "modifiedOn")]
	pub modified_on: String,
	#[serde(rename = "modifiedBy")]
	pub modified_by: Option<String>,
}
impl TaskDefinitionBasic {
	pub async fn name(&self) -> String {
		self.name.clone()
	}
	pub async fn description(&self) -> Option<String> {
		self.description.clone()
	}
	pub async fn retry_count(&self) -> i64 {
		self.retry_count
	}
	pub async fn timeout_seconds(&self) -> Option<i64> {
		self.timeout_seconds
	}
	pub async fn timeout_policy(&self) -> TimeoutPolicyEnum {
		self.timeout_policy.clone()
	}
	pub async fn retry_logic(&self) -> RetryLogicEnum {
		self.retry_logic.clone()
	}
	pub async fn retry_delay_seconds(&self) -> i64 {
		self.retry_delay_seconds
	}
	pub async fn response_timeout_seconds(&self) -> i64 {
		self.response_timeout_seconds
	}
	pub async fn concurrent_exec_limit(&self) -> Option<i64> {
		self.concurrent_exec_limit
	}
	pub async fn rate_limit_per_frequency(&self) -> Option<i64> {
		self.rate_limit_per_frequency
	}
	pub async fn rate_limit_frequency_in_seconds(&self) -> Option<i64> {
		self.rate_limit_frequency_in_seconds
	}
	pub async fn isolation_group_id(&self) -> Option<String> {
		self.isolation_group_id.clone()
	}
	pub async fn execution_name_space(&self) -> Option<String> {
		self.execution_name_space.clone()
	}
	pub async fn owner_email(&self) -> Option<String> {
		self.owner_email.clone()
	}
	pub async fn poll_timeout_seconds(&self) -> Option<i64> {
		self.poll_timeout_seconds
	}
	pub async fn backoff_scale_factor(&self) -> i64 {
		self.backoff_scale_factor
	}
	pub async fn base_type(&self) -> Option<String> {
		self.base_type.clone()
	}
	pub async fn enforce_schema(&self) -> bool {
		self.enforce_schema
	}
	pub async fn created_on(&self) -> String {
		self.created_on.clone()
	}
	pub async fn created_by(&self) -> Option<String> {
		self.created_by.clone()
	}
	pub async fn modified_on(&self) -> String {
		self.modified_on.clone()
	}
	pub async fn modified_by(&self) -> Option<String> {
		self.modified_by.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "name",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "description",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "timeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "timeoutPolicy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retryLogic",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retryDelaySeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "responseTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "concurrentExecLimit",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "ownerEmail",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "pollTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "backoffScaleFactor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "baseType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "enforceSchema",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "createdOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "createdBy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "modifiedOn",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "modifiedBy",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskDefinitionConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<TaskDefinition>,
	#[serde(rename = "edges")]
	pub edges: Vec<TaskDefinitionEdge>,
}
impl TaskDefinitionConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<TaskDefinition> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<TaskDefinitionEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(TaskDefinition::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(TaskDefinitionEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskDefinitionEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: TaskDefinition,
}
impl TaskDefinitionEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> TaskDefinition {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(TaskDefinition::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskExecutionLog {
	#[serde(rename = "logId")]
	pub log_id: String,
	#[serde(rename = "taskId")]
	pub task_id: String,
	#[serde(rename = "log")]
	pub log: String,
	#[serde(rename = "createdTime")]
	pub created_time: String,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl TaskExecutionLog {
	pub async fn log_id(&self) -> String {
		self.log_id.clone()
	}
	pub async fn task_id(&self) -> String {
		self.task_id.clone()
	}
	pub async fn log(&self) -> String {
		self.log.clone()
	}
	pub async fn created_time(&self) -> String {
		self.created_time.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "logId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "log",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "createdTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskExecutionLogBasic {
	#[serde(rename = "logId")]
	pub log_id: String,
	#[serde(rename = "taskId")]
	pub task_id: String,
	#[serde(rename = "log")]
	pub log: String,
	#[serde(rename = "createdTime")]
	pub created_time: String,
}
impl TaskExecutionLogBasic {
	pub async fn log_id(&self) -> String {
		self.log_id.clone()
	}
	pub async fn task_id(&self) -> String {
		self.task_id.clone()
	}
	pub async fn log(&self) -> String {
		self.log.clone()
	}
	pub async fn created_time(&self) -> String {
		self.created_time.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "logId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "log",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "createdTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskExecutionLogConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<TaskExecutionLog>,
	#[serde(rename = "edges")]
	pub edges: Vec<TaskExecutionLogEdge>,
}
impl TaskExecutionLogConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<TaskExecutionLog> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<TaskExecutionLogEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(TaskExecutionLog::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(TaskExecutionLogEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskExecutionLogEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: TaskExecutionLog,
}
impl TaskExecutionLogEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> TaskExecutionLog {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(TaskExecutionLog::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskModel {
	#[serde(rename = "taskId")]
	pub task_id: String,
	#[serde(rename = "taskType")]
	pub task_type: TaskTypeEnum,
	#[serde(rename = "status")]
	pub status: TaskStatusEnum,
	#[serde(rename = "referenceTaskName")]
	pub reference_task_name: String,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<i64>,
	#[serde(rename = "seq")]
	pub seq: i64,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<String>,
	#[serde(rename = "pollCount")]
	pub poll_count: i64,
	#[serde(rename = "taskDefName")]
	pub task_def_name: String,
	#[serde(rename = "taskConfigId")]
	pub task_config_id: Option<String>,
	#[serde(rename = "scheduledTime")]
	pub scheduled_time: String,
	#[serde(rename = "startTime")]
	pub start_time: String,
	#[serde(rename = "endTime")]
	pub end_time: Option<String>,
	#[serde(rename = "updateTime")]
	pub update_time: Option<String>,
	#[serde(rename = "startDelayInSeconds")]
	pub start_delay_in_seconds: i64,
	#[serde(rename = "retriedTaskId")]
	pub retried_task_id: Option<String>,
	#[serde(rename = "retried")]
	pub retried: bool,
	#[serde(rename = "executed")]
	pub executed: bool,
	#[serde(rename = "callbackFromWorker")]
	pub callback_from_worker: bool,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: Option<i64>,
	#[serde(rename = "workflowInstanceId")]
	pub workflow_instance_id: Option<String>,
	#[serde(rename = "workflowType")]
	pub workflow_type: Option<String>,
	#[serde(rename = "reasonForIncompletion")]
	pub reason_for_incompletion: Option<String>,
	#[serde(rename = "callbackAfterSeconds")]
	pub callback_after_seconds: i64,
	#[serde(rename = "workerId")]
	pub worker_id: Option<String>,
	#[serde(rename = "domain")]
	pub domain: Option<String>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<i64>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<i64>,
	#[serde(rename = "externalInputPayloadStoragePath")]
	pub external_input_payload_storage_path: Option<String>,
	#[serde(rename = "externalOutputPayloadStoragePath")]
	pub external_output_payload_storage_path: Option<String>,
	#[serde(rename = "workflowPriority")]
	pub workflow_priority: i64,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<String>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<String>,
	#[serde(rename = "iteration")]
	pub iteration: i64,
	#[serde(rename = "subworkflowChanged")]
	pub subworkflow_changed: bool,
	#[serde(rename = "waitTimeout")]
	pub wait_timeout: Option<i64>,
	#[serde(rename = "buissnessRule")]
	pub buissness_rule: BuissnessRuleConnection,
	#[serde(rename = "doWhile")]
	pub do_while: DoWhileConnection,
	#[serde(rename = "dynamic")]
	pub dynamic: DynamicConnection,
	#[serde(rename = "dynamicFork")]
	pub dynamic_fork: DynamicForkConnection,
	#[serde(rename = "event")]
	pub event: EventConnection,
	#[serde(rename = "fork")]
	pub fork: ForkConnection,
	#[serde(rename = "getSignedJwt")]
	pub get_signed_jwt: GetSignedJwtConnection,
	#[serde(rename = "getWorkflow")]
	pub get_workflow: GetWorkflowConnection,
	#[serde(rename = "http")]
	pub http: HttpConnection,
	#[serde(rename = "human")]
	pub human: HumanConnection,
	#[serde(rename = "inline")]
	pub inline: InlineConnection,
	#[serde(rename = "join")]
	pub join: JoinConnection,
	#[serde(rename = "jsonTransform")]
	pub json_transform: JsonTransformConnection,
	#[serde(rename = "setVariable")]
	pub set_variable: SetVariableConnection,
	#[serde(rename = "simple")]
	pub simple: SimpleConnection,
	#[serde(rename = "sql")]
	pub sql: SqlConnection,
	#[serde(rename = "startWorkflow")]
	pub start_workflow: StartWorkflowConnection,
	#[serde(rename = "subWorkflow")]
	pub sub_workflow: SubWorkflowConnection,
	#[serde(rename = "switch")]
	pub switch: SwitchConnection,
	#[serde(rename = "taskConfig")]
	pub task_config: Option<TaskConfig>,
	#[serde(rename = "taskDefinition")]
	pub task_definition: Option<TaskDefinition>,
	#[serde(rename = "taskExecutionLog")]
	pub task_execution_log: TaskExecutionLogConnection,
	#[serde(rename = "terminateTask")]
	pub terminate_task: TerminateTaskConnection,
	#[serde(rename = "terminateWorkflow")]
	pub terminate_workflow: TerminateWorkflowConnection,
	#[serde(rename = "updateSecret")]
	pub update_secret: UpdateSecretConnection,
	#[serde(rename = "updateTask")]
	pub update_task: UpdateTaskConnection,
	#[serde(rename = "wait")]
	pub wait: WaitConnection,
	#[serde(rename = "waitForWebhook")]
	pub wait_for_webhook: WaitForWebhookConnection,
}
impl TaskModel {
	pub async fn task_id(&self) -> String {
		self.task_id.clone()
	}
	pub async fn task_type(&self) -> TaskTypeEnum {
		self.task_type.clone()
	}
	pub async fn status(&self) -> TaskStatusEnum {
		self.status.clone()
	}
	pub async fn reference_task_name(&self) -> String {
		self.reference_task_name.clone()
	}
	pub async fn retry_count(&self) -> Option<i64> {
		self.retry_count
	}
	pub async fn seq(&self) -> i64 {
		self.seq
	}
	pub async fn correlation_id(&self) -> Option<String> {
		self.correlation_id.clone()
	}
	pub async fn poll_count(&self) -> i64 {
		self.poll_count
	}
	pub async fn task_def_name(&self) -> String {
		self.task_def_name.clone()
	}
	pub async fn task_config_id(&self) -> Option<String> {
		self.task_config_id.clone()
	}
	pub async fn scheduled_time(&self) -> String {
		self.scheduled_time.clone()
	}
	pub async fn start_time(&self) -> String {
		self.start_time.clone()
	}
	pub async fn end_time(&self) -> Option<String> {
		self.end_time.clone()
	}
	pub async fn update_time(&self) -> Option<String> {
		self.update_time.clone()
	}
	pub async fn start_delay_in_seconds(&self) -> i64 {
		self.start_delay_in_seconds
	}
	pub async fn retried_task_id(&self) -> Option<String> {
		self.retried_task_id.clone()
	}
	pub async fn retried(&self) -> bool {
		self.retried
	}
	pub async fn executed(&self) -> bool {
		self.executed
	}
	pub async fn callback_from_worker(&self) -> bool {
		self.callback_from_worker
	}
	pub async fn response_timeout_seconds(&self) -> Option<i64> {
		self.response_timeout_seconds
	}
	pub async fn workflow_instance_id(&self) -> Option<String> {
		self.workflow_instance_id.clone()
	}
	pub async fn workflow_type(&self) -> Option<String> {
		self.workflow_type.clone()
	}
	pub async fn reason_for_incompletion(&self) -> Option<String> {
		self.reason_for_incompletion.clone()
	}
	pub async fn callback_after_seconds(&self) -> i64 {
		self.callback_after_seconds
	}
	pub async fn worker_id(&self) -> Option<String> {
		self.worker_id.clone()
	}
	pub async fn domain(&self) -> Option<String> {
		self.domain.clone()
	}
	pub async fn rate_limit_per_frequency(&self) -> Option<i64> {
		self.rate_limit_per_frequency
	}
	pub async fn rate_limit_frequency_in_seconds(&self) -> Option<i64> {
		self.rate_limit_frequency_in_seconds
	}
	pub async fn external_input_payload_storage_path(&self) -> Option<String> {
		self.external_input_payload_storage_path.clone()
	}
	pub async fn external_output_payload_storage_path(&self) -> Option<String> {
		self.external_output_payload_storage_path.clone()
	}
	pub async fn workflow_priority(&self) -> i64 {
		self.workflow_priority
	}
	pub async fn execution_name_space(&self) -> Option<String> {
		self.execution_name_space.clone()
	}
	pub async fn isolation_group_id(&self) -> Option<String> {
		self.isolation_group_id.clone()
	}
	pub async fn iteration(&self) -> i64 {
		self.iteration
	}
	pub async fn subworkflow_changed(&self) -> bool {
		self.subworkflow_changed
	}
	pub async fn wait_timeout(&self) -> Option<i64> {
		self.wait_timeout
	}
	pub async fn buissness_rule(&self) -> BuissnessRuleConnection {
		self.buissness_rule.clone()
	}
	pub async fn do_while(&self) -> DoWhileConnection {
		self.do_while.clone()
	}
	pub async fn dynamic(&self) -> DynamicConnection {
		self.dynamic.clone()
	}
	pub async fn dynamic_fork(&self) -> DynamicForkConnection {
		self.dynamic_fork.clone()
	}
	pub async fn event(&self) -> EventConnection {
		self.event.clone()
	}
	pub async fn fork(&self) -> ForkConnection {
		self.fork.clone()
	}
	pub async fn get_signed_jwt(&self) -> GetSignedJwtConnection {
		self.get_signed_jwt.clone()
	}
	pub async fn get_workflow(&self) -> GetWorkflowConnection {
		self.get_workflow.clone()
	}
	pub async fn http(&self) -> HttpConnection {
		self.http.clone()
	}
	pub async fn human(&self) -> HumanConnection {
		self.human.clone()
	}
	pub async fn inline(&self) -> InlineConnection {
		self.inline.clone()
	}
	pub async fn join(&self) -> JoinConnection {
		self.join.clone()
	}
	pub async fn json_transform(&self) -> JsonTransformConnection {
		self.json_transform.clone()
	}
	pub async fn set_variable(&self) -> SetVariableConnection {
		self.set_variable.clone()
	}
	pub async fn simple(&self) -> SimpleConnection {
		self.simple.clone()
	}
	pub async fn sql(&self) -> SqlConnection {
		self.sql.clone()
	}
	pub async fn start_workflow(&self) -> StartWorkflowConnection {
		self.start_workflow.clone()
	}
	pub async fn sub_workflow(&self) -> SubWorkflowConnection {
		self.sub_workflow.clone()
	}
	pub async fn switch(&self) -> SwitchConnection {
		self.switch.clone()
	}
	pub async fn task_config(&self) -> Option<TaskConfig> {
		self.task_config.clone()
	}
	pub async fn task_definition(&self) -> Option<TaskDefinition> {
		self.task_definition.clone()
	}
	pub async fn task_execution_log(&self) -> TaskExecutionLogConnection {
		self.task_execution_log.clone()
	}
	pub async fn terminate_task(&self) -> TerminateTaskConnection {
		self.terminate_task.clone()
	}
	pub async fn terminate_workflow(&self) -> TerminateWorkflowConnection {
		self.terminate_workflow.clone()
	}
	pub async fn update_secret(&self) -> UpdateSecretConnection {
		self.update_secret.clone()
	}
	pub async fn update_task(&self) -> UpdateTaskConnection {
		self.update_task.clone()
	}
	pub async fn wait(&self) -> WaitConnection {
		self.wait.clone()
	}
	pub async fn wait_for_webhook(&self) -> WaitForWebhookConnection {
		self.wait_for_webhook.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "status",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "referenceTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "seq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "pollCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskDefName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskConfigId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "scheduledTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "startTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "endTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "updateTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "startDelayInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retriedTaskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retried",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "executed",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "callbackFromWorker",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "responseTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "workflowInstanceId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "workflowType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "reasonForIncompletion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "callbackAfterSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "workerId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "domain",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "externalInputPayloadStoragePath",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "externalOutputPayloadStoragePath",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "workflowPriority",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "iteration",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "subworkflowChanged",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "waitTimeout",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "buissnessRule",
				alias: None,
				fields: Some(BuissnessRuleConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "doWhile",
				alias: None,
				fields: Some(DoWhileConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "dynamic",
				alias: None,
				fields: Some(DynamicConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "dynamicFork",
				alias: None,
				fields: Some(DynamicForkConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "event",
				alias: None,
				fields: Some(EventConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "fork",
				alias: None,
				fields: Some(ForkConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "getSignedJwt",
				alias: None,
				fields: Some(GetSignedJwtConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "getWorkflow",
				alias: None,
				fields: Some(GetWorkflowConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "http",
				alias: None,
				fields: Some(HttpConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "human",
				alias: None,
				fields: Some(HumanConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "inline",
				alias: None,
				fields: Some(InlineConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "join",
				alias: None,
				fields: Some(JoinConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "jsonTransform",
				alias: None,
				fields: Some(JsonTransformConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "setVariable",
				alias: None,
				fields: Some(SetVariableConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "simple",
				alias: None,
				fields: Some(SimpleConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "sql",
				alias: None,
				fields: Some(SqlConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "startWorkflow",
				alias: None,
				fields: Some(StartWorkflowConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "subWorkflow",
				alias: None,
				fields: Some(SubWorkflowConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "switch",
				alias: None,
				fields: Some(SwitchConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskConfig",
				alias: None,
				fields: Some(TaskConfig::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskDefinition",
				alias: None,
				fields: Some(TaskDefinition::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskExecutionLog",
				alias: None,
				fields: Some(TaskExecutionLogConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "terminateTask",
				alias: None,
				fields: Some(TerminateTaskConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "terminateWorkflow",
				alias: None,
				fields: Some(TerminateWorkflowConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "updateSecret",
				alias: None,
				fields: Some(UpdateSecretConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "updateTask",
				alias: None,
				fields: Some(UpdateTaskConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "wait",
				alias: None,
				fields: Some(WaitConnection::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "waitForWebhook",
				alias: None,
				fields: Some(WaitForWebhookConnection::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskModelBasic {
	#[serde(rename = "taskId")]
	pub task_id: String,
	#[serde(rename = "taskType")]
	pub task_type: TaskTypeEnum,
	#[serde(rename = "status")]
	pub status: TaskStatusEnum,
	#[serde(rename = "referenceTaskName")]
	pub reference_task_name: String,
	#[serde(rename = "retryCount")]
	pub retry_count: Option<i64>,
	#[serde(rename = "seq")]
	pub seq: i64,
	#[serde(rename = "correlationId")]
	pub correlation_id: Option<String>,
	#[serde(rename = "pollCount")]
	pub poll_count: i64,
	#[serde(rename = "taskDefName")]
	pub task_def_name: String,
	#[serde(rename = "taskConfigId")]
	pub task_config_id: Option<String>,
	#[serde(rename = "scheduledTime")]
	pub scheduled_time: String,
	#[serde(rename = "startTime")]
	pub start_time: String,
	#[serde(rename = "endTime")]
	pub end_time: Option<String>,
	#[serde(rename = "updateTime")]
	pub update_time: Option<String>,
	#[serde(rename = "startDelayInSeconds")]
	pub start_delay_in_seconds: i64,
	#[serde(rename = "retriedTaskId")]
	pub retried_task_id: Option<String>,
	#[serde(rename = "retried")]
	pub retried: bool,
	#[serde(rename = "executed")]
	pub executed: bool,
	#[serde(rename = "callbackFromWorker")]
	pub callback_from_worker: bool,
	#[serde(rename = "responseTimeoutSeconds")]
	pub response_timeout_seconds: Option<i64>,
	#[serde(rename = "workflowInstanceId")]
	pub workflow_instance_id: Option<String>,
	#[serde(rename = "workflowType")]
	pub workflow_type: Option<String>,
	#[serde(rename = "reasonForIncompletion")]
	pub reason_for_incompletion: Option<String>,
	#[serde(rename = "callbackAfterSeconds")]
	pub callback_after_seconds: i64,
	#[serde(rename = "workerId")]
	pub worker_id: Option<String>,
	#[serde(rename = "domain")]
	pub domain: Option<String>,
	#[serde(rename = "rateLimitPerFrequency")]
	pub rate_limit_per_frequency: Option<i64>,
	#[serde(rename = "rateLimitFrequencyInSeconds")]
	pub rate_limit_frequency_in_seconds: Option<i64>,
	#[serde(rename = "externalInputPayloadStoragePath")]
	pub external_input_payload_storage_path: Option<String>,
	#[serde(rename = "externalOutputPayloadStoragePath")]
	pub external_output_payload_storage_path: Option<String>,
	#[serde(rename = "workflowPriority")]
	pub workflow_priority: i64,
	#[serde(rename = "executionNameSpace")]
	pub execution_name_space: Option<String>,
	#[serde(rename = "isolationGroupId")]
	pub isolation_group_id: Option<String>,
	#[serde(rename = "iteration")]
	pub iteration: i64,
	#[serde(rename = "subworkflowChanged")]
	pub subworkflow_changed: bool,
	#[serde(rename = "waitTimeout")]
	pub wait_timeout: Option<i64>,
}
impl TaskModelBasic {
	pub async fn task_id(&self) -> String {
		self.task_id.clone()
	}
	pub async fn task_type(&self) -> TaskTypeEnum {
		self.task_type.clone()
	}
	pub async fn status(&self) -> TaskStatusEnum {
		self.status.clone()
	}
	pub async fn reference_task_name(&self) -> String {
		self.reference_task_name.clone()
	}
	pub async fn retry_count(&self) -> Option<i64> {
		self.retry_count
	}
	pub async fn seq(&self) -> i64 {
		self.seq
	}
	pub async fn correlation_id(&self) -> Option<String> {
		self.correlation_id.clone()
	}
	pub async fn poll_count(&self) -> i64 {
		self.poll_count
	}
	pub async fn task_def_name(&self) -> String {
		self.task_def_name.clone()
	}
	pub async fn task_config_id(&self) -> Option<String> {
		self.task_config_id.clone()
	}
	pub async fn scheduled_time(&self) -> String {
		self.scheduled_time.clone()
	}
	pub async fn start_time(&self) -> String {
		self.start_time.clone()
	}
	pub async fn end_time(&self) -> Option<String> {
		self.end_time.clone()
	}
	pub async fn update_time(&self) -> Option<String> {
		self.update_time.clone()
	}
	pub async fn start_delay_in_seconds(&self) -> i64 {
		self.start_delay_in_seconds
	}
	pub async fn retried_task_id(&self) -> Option<String> {
		self.retried_task_id.clone()
	}
	pub async fn retried(&self) -> bool {
		self.retried
	}
	pub async fn executed(&self) -> bool {
		self.executed
	}
	pub async fn callback_from_worker(&self) -> bool {
		self.callback_from_worker
	}
	pub async fn response_timeout_seconds(&self) -> Option<i64> {
		self.response_timeout_seconds
	}
	pub async fn workflow_instance_id(&self) -> Option<String> {
		self.workflow_instance_id.clone()
	}
	pub async fn workflow_type(&self) -> Option<String> {
		self.workflow_type.clone()
	}
	pub async fn reason_for_incompletion(&self) -> Option<String> {
		self.reason_for_incompletion.clone()
	}
	pub async fn callback_after_seconds(&self) -> i64 {
		self.callback_after_seconds
	}
	pub async fn worker_id(&self) -> Option<String> {
		self.worker_id.clone()
	}
	pub async fn domain(&self) -> Option<String> {
		self.domain.clone()
	}
	pub async fn rate_limit_per_frequency(&self) -> Option<i64> {
		self.rate_limit_per_frequency
	}
	pub async fn rate_limit_frequency_in_seconds(&self) -> Option<i64> {
		self.rate_limit_frequency_in_seconds
	}
	pub async fn external_input_payload_storage_path(&self) -> Option<String> {
		self.external_input_payload_storage_path.clone()
	}
	pub async fn external_output_payload_storage_path(&self) -> Option<String> {
		self.external_output_payload_storage_path.clone()
	}
	pub async fn workflow_priority(&self) -> i64 {
		self.workflow_priority
	}
	pub async fn execution_name_space(&self) -> Option<String> {
		self.execution_name_space.clone()
	}
	pub async fn isolation_group_id(&self) -> Option<String> {
		self.isolation_group_id.clone()
	}
	pub async fn iteration(&self) -> i64 {
		self.iteration
	}
	pub async fn subworkflow_changed(&self) -> bool {
		self.subworkflow_changed
	}
	pub async fn wait_timeout(&self) -> Option<i64> {
		self.wait_timeout
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "status",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "referenceTaskName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retryCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "seq",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "correlationId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "pollCount",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskDefName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskConfigId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "scheduledTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "startTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "endTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "updateTime",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "startDelayInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retriedTaskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "retried",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "executed",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "callbackFromWorker",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "responseTimeoutSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "workflowInstanceId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "workflowType",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "reasonForIncompletion",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "callbackAfterSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "workerId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "domain",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "rateLimitPerFrequency",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "rateLimitFrequencyInSeconds",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "externalInputPayloadStoragePath",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "externalOutputPayloadStoragePath",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "workflowPriority",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "executionNameSpace",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "isolationGroupId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "iteration",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "subworkflowChanged",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "waitTimeout",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskModelConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<TaskModel>,
	#[serde(rename = "edges")]
	pub edges: Vec<TaskModelEdge>,
}
impl TaskModelConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<TaskModel> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<TaskModelEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(TaskModelEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskModelEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: TaskModel,
}
impl TaskModelEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> TaskModel {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateTask {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "terminationStatus")]
	pub termination_status: TaskTerminationStatusEnum,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl TerminateTask {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn termination_status(&self) -> TaskTerminationStatusEnum {
		self.termination_status.clone()
	}
	pub async fn termination_reason(&self) -> Option<String> {
		self.termination_reason.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "terminationStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateTaskBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "terminationStatus")]
	pub termination_status: TaskTerminationStatusEnum,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl TerminateTaskBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn termination_status(&self) -> TaskTerminationStatusEnum {
		self.termination_status.clone()
	}
	pub async fn termination_reason(&self) -> Option<String> {
		self.termination_reason.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "terminationStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateTaskConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<TerminateTask>,
	#[serde(rename = "edges")]
	pub edges: Vec<TerminateTaskEdge>,
}
impl TerminateTaskConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<TerminateTask> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<TerminateTaskEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(TerminateTask::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(TerminateTaskEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateTaskEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: TerminateTask,
}
impl TerminateTaskEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> TerminateTask {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(TerminateTask::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateWorkflow {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<String>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: bool,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl TerminateWorkflow {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn termination_reason(&self) -> Option<String> {
		self.termination_reason.clone()
	}
	pub async fn trigger_failure_workflow(&self) -> bool {
		self.trigger_failure_workflow
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "triggerFailureWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateWorkflowBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "terminationReason")]
	pub termination_reason: Option<String>,
	#[serde(rename = "triggerFailureWorkflow")]
	pub trigger_failure_workflow: bool,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl TerminateWorkflowBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn termination_reason(&self) -> Option<String> {
		self.termination_reason.clone()
	}
	pub async fn trigger_failure_workflow(&self) -> bool {
		self.trigger_failure_workflow
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "terminationReason",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "triggerFailureWorkflow",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateWorkflowConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<TerminateWorkflow>,
	#[serde(rename = "edges")]
	pub edges: Vec<TerminateWorkflowEdge>,
}
impl TerminateWorkflowConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<TerminateWorkflow> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<TerminateWorkflowEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(TerminateWorkflow::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(TerminateWorkflowEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TerminateWorkflowEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: TerminateWorkflow,
}
impl TerminateWorkflowEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> TerminateWorkflow {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(TerminateWorkflow::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateSecret {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "secretKey")]
	pub secret_key: String,
	#[serde(rename = "secretValue")]
	pub secret_value: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl UpdateSecret {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn secret_key(&self) -> String {
		self.secret_key.clone()
	}
	pub async fn secret_value(&self) -> String {
		self.secret_value.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "secretKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "secretValue",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateSecretBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "secretKey")]
	pub secret_key: String,
	#[serde(rename = "secretValue")]
	pub secret_value: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl UpdateSecretBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn secret_key(&self) -> String {
		self.secret_key.clone()
	}
	pub async fn secret_value(&self) -> String {
		self.secret_value.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "secretKey",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "secretValue",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateSecretConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<UpdateSecret>,
	#[serde(rename = "edges")]
	pub edges: Vec<UpdateSecretEdge>,
}
impl UpdateSecretConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<UpdateSecret> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<UpdateSecretEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(UpdateSecret::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(UpdateSecretEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateSecretEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: UpdateSecret,
}
impl UpdateSecretEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> UpdateSecret {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(UpdateSecret::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateTask {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskStatus")]
	pub task_status: TaskStatusEnum,
	#[serde(rename = "workflowId")]
	pub workflow_id: Option<String>,
	#[serde(rename = "taskRefName")]
	pub task_ref_name: Option<String>,
	#[serde(rename = "taskId")]
	pub task_id: Option<String>,
	#[serde(rename = "mergeOutput")]
	pub merge_output: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl UpdateTask {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_status(&self) -> TaskStatusEnum {
		self.task_status.clone()
	}
	pub async fn workflow_id(&self) -> Option<String> {
		self.workflow_id.clone()
	}
	pub async fn task_ref_name(&self) -> Option<String> {
		self.task_ref_name.clone()
	}
	pub async fn task_id(&self) -> Option<String> {
		self.task_id.clone()
	}
	pub async fn merge_output(&self) -> Option<bool> {
		self.merge_output
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "workflowId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskRefName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "mergeOutput",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateTaskBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskStatus")]
	pub task_status: TaskStatusEnum,
	#[serde(rename = "workflowId")]
	pub workflow_id: Option<String>,
	#[serde(rename = "taskRefName")]
	pub task_ref_name: Option<String>,
	#[serde(rename = "taskId")]
	pub task_id: Option<String>,
	#[serde(rename = "mergeOutput")]
	pub merge_output: Option<bool>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl UpdateTaskBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_status(&self) -> TaskStatusEnum {
		self.task_status.clone()
	}
	pub async fn workflow_id(&self) -> Option<String> {
		self.workflow_id.clone()
	}
	pub async fn task_ref_name(&self) -> Option<String> {
		self.task_ref_name.clone()
	}
	pub async fn task_id(&self) -> Option<String> {
		self.task_id.clone()
	}
	pub async fn merge_output(&self) -> Option<bool> {
		self.merge_output
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskStatus",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "workflowId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskRefName",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "mergeOutput",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateTaskConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<UpdateTask>,
	#[serde(rename = "edges")]
	pub edges: Vec<UpdateTaskEdge>,
}
impl UpdateTaskConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<UpdateTask> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<UpdateTaskEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(UpdateTask::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(UpdateTaskEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UpdateTaskEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: UpdateTask,
}
impl UpdateTaskEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> UpdateTask {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(UpdateTask::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Wait {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "until")]
	pub until: Option<String>,
	#[serde(rename = "duration")]
	pub duration: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl Wait {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn until(&self) -> Option<String> {
		self.until.clone()
	}
	pub async fn duration(&self) -> Option<String> {
		self.duration.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "until",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "duration",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "until")]
	pub until: Option<String>,
	#[serde(rename = "duration")]
	pub duration: Option<String>,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl WaitBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn until(&self) -> Option<String> {
		self.until.clone()
	}
	pub async fn duration(&self) -> Option<String> {
		self.duration.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "until",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "duration",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<Wait>,
	#[serde(rename = "edges")]
	pub edges: Vec<WaitEdge>,
}
impl WaitConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<Wait> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<WaitEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(Wait::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(WaitEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: Wait,
}
impl WaitEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> Wait {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(Wait::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitForWebhook {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
	#[serde(rename = "taskModel")]
	pub task_model: Option<TaskModel>,
}
impl WaitForWebhook {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub async fn task_model(&self) -> Option<TaskModel> {
		self.task_model.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModel",
				alias: None,
				fields: Some(TaskModel::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitForWebhookBasic {
	#[serde(rename = "id")]
	pub id: String,
	#[serde(rename = "taskModelId")]
	pub task_model_id: Option<String>,
}
impl WaitForWebhookBasic {
	pub async fn id(&self) -> String {
		self.id.clone()
	}
	pub async fn task_model_id(&self) -> Option<String> {
		self.task_model_id.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "id",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "taskModelId",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitForWebhookConnection {
	#[serde(rename = "pageInfo")]
	pub page_info: PageInfo,
	#[serde(rename = "paginationInfo")]
	pub pagination_info: Option<PaginationInfo>,
	#[serde(rename = "nodes")]
	pub nodes: Vec<WaitForWebhook>,
	#[serde(rename = "edges")]
	pub edges: Vec<WaitForWebhookEdge>,
}
impl WaitForWebhookConnection {
	pub async fn page_info(&self) -> PageInfo {
		self.page_info.clone()
	}
	pub async fn pagination_info(&self) -> Option<PaginationInfo> {
		self.pagination_info.clone()
	}
	pub async fn nodes(&self) -> Vec<WaitForWebhook> {
		self.nodes.clone()
	}
	pub async fn edges(&self) -> Vec<WaitForWebhookEdge> {
		self.edges.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "pageInfo",
				alias: None,
				fields: Some(PageInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "paginationInfo",
				alias: None,
				fields: Some(PaginationInfo::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "nodes",
				alias: None,
				fields: Some(WaitForWebhook::to_query()),
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "edges",
				alias: None,
				fields: Some(WaitForWebhookEdge::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WaitForWebhookEdge {
	#[serde(rename = "cursor")]
	pub cursor: String,
	#[serde(rename = "node")]
	pub node: WaitForWebhook,
}
impl WaitForWebhookEdge {
	pub async fn cursor(&self) -> String {
		self.cursor.clone()
	}
	pub async fn node(&self) -> WaitForWebhook {
		self.node.clone()
	}
	pub fn to_query() -> Vec<SelectionSet> {
		vec![
			SelectionSet {
				operation: "cursor",
				alias: None,
				fields: None,
				arguments: None,
				is_union: false,
			},
			SelectionSet {
				operation: "node",
				alias: None,
				fields: Some(WaitForWebhook::to_query()),
				arguments: None,
				is_union: false,
			},
		]
	}
}
